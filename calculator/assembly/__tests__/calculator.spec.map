{"version":3,"sources":["~lib/rt/common.ts","~lib/rt/tlsf.ts","~lib/shared/typeinfo.ts","~lib/rt/itcms.ts","assembly/__tests__/calculator.spec.ts","assembly/Calculator.ts","~lib/bindings/wasi_snapshot_preview1.ts","~lib/util/math.ts","~lib/util/string.ts","~lib/util/number.ts","~lib/wasi/index.ts","~lib/as-proto/WireType.ts","~lib/shared/runtime.ts","~lib/util/sort.ts","~lib/string.ts","~lib/util/error.ts","~lib/rt.ts","~lib/memory.ts","~lib/util/memory.ts","~lib/as-proto/internal/FixedWriter.ts","~lib/as-proto/internal/FixedSizer.ts","~lib/arraybuffer.ts","~lib/typedarray.ts","~lib/as-proto/Protobuf.ts","~lib/as-proto/internal/FixedReader.ts","~lib/@koinos/proto-as/koinos/contracts/governance/governance.ts","~lib/@koinos/proto-as/koinos/chain/chain.ts","~lib/@koinos/proto-as/koinos/options.ts","~lib/@koinos/proto-as/koinos/chain/error.ts","~lib/@koinos/proto-as/koinos/chain/authority.ts","~lib/@koinos/proto-as/koinos/chain/system_call_ids.ts","~lib/@koinos/proto-as/koinos/chain/object_spaces.ts","~lib/@koinos/sdk-as/util/crypto.ts","~lib/@koinos/sdk-as/util/mockVM.ts","~lib/@koinos/sdk-as/util/token.ts","~lib/@koinos/sdk-as/systemCalls.ts","assembly/proto/calculator.ts","~lib/@koinos/sdk-as/util/safeMath.ts","~lib/number.ts","~lib/builtins.ts","~lib/staticarray.ts","~lib/@koinos/proto-as/koinos/chain/system_calls.ts","~lib/array.ts","~lib/process.ts","~lib/console.ts","~lib/bindings/wasi.ts","node_modules/@as-pect/assembly/assembly/internal/Expectation.ts","node_modules/@as-pect/assembly/assembly/internal/comparison/toIncludeComparison.ts","node_modules/@as-pect/assembly/assembly/internal/Actual.ts","node_modules/@as-pect/assembly/assembly/internal/Expected.ts","node_modules/@as-pect/assembly/assembly/internal/assert.ts","node_modules/@as-pect/assembly/assembly/internal/comparison/toIncludeEqualComparison.ts","node_modules/@as-pect/assembly/assembly/internal/Reflect.ts","~lib/util/hash.ts","~lib/set.ts","node_modules/@as-pect/assembly/assembly/internal/ReflectedValueType.ts","~lib/map.ts","node_modules/@as-pect/assembly/assembly/internal/noOp.ts","node_modules/@as-pect/assembly/assembly/internal/log.ts","node_modules/@as-pect/assembly/assembly/internal/call.ts","~lib/function.ts"],"names":[],"mappings":"01BcgsBM,AAAa,AAAO,EAAc,GAArB,KACb,AAAa,IACb,EAAO,EAAM,KAEX,AAAI,AADK,AAAe,OACf,MACP,AAAU,UAAQ,KAClB,MAGK,AAAI,EAAK,MACd,AAAS,EAAM,GAAI,MACnB,AAAS,EAAK,GAAK,MACnB,AAAW,UAAQ,AAAU,EAAV,EAAM,OACzB,EAAU,IAQV,AACM,EAAK,KAAU,AAAU,EAAV,EAAM,KADvB,AAAC,EAAK,KAAW,QAGjB,AAAI,AAAC,AADI,AAAe,OACd,KAAW,OAEnB,AAAS,AADJ,AAAW,AAAC,EAAK,IAAW,GAA5B,KAAmC,EAAK,OAC9B,GAAK,MACpB,AAAS,EAAM,GAAK,GAAK,MACzB,AAAS,EAAM,GAAK,GAAK,MACzB,AAAS,EAAW,GAAK,MACzB,AAAW,UAAQ,AAAgC,EAAhC,EAAM,GAAK,EAAM,IAAK,EAAM,QAC/C,EAAU,KAAG,EAAO,SAS1B,AAAS,EAAM,GAAK,MACpB,AAAS,EAAM,GAAK,GAAK,MACzB,AAAS,EAAW,GAAK,MACzB,AAAW,UAAQ,AAAU,EAAV,EAAM,OACzB,AAAU,UAAQ,KAClB,EAAU,OAEZ,EAAO,SAKT,AAAO,EAAS,wBJptBpB,AAAW,UAAK,YAIhB,AAHA,AAAI,IIiBF,AAAO,AAAmB,EAA0B,MAA0B,SJhBvE,AAAyB,EAA4B,MAA5D,iBAEc,SAAa,EAAO,KAIpC,EAHA,AAAI,IIaF,AAAO,AAAmB,EAA0B,MAA0B,SJZvE,AAAyB,EAA6B,EAAiB,IAA9E,iBAEe,KACqB,AD4FtC,AAAI,EAAQ,OACV,AAAI,EAAQ,MACH,AAAI,AAAI,EAAS,GAAjB,IAEA,AAAI,AAAI,EAAS,KAAjB,GAA0B,AAAI,EAAS,OAGhD,AAAI,EAAQ,QACH,AAAI,AAAI,EAAS,KAAjB,IAEA,AAAI,AAAI,EAAS,OAAjB,GAA+B,AAAI,EAAS,WCvG7C,QAEV,EAEE,AAAU,AAAE,eAAK,AAAO,EAAa,GAApB,MAEV,AADM,AAFL,EAAa,QAIvB,AAAU,AADY,EAAO,aACZ,KACmB,ADqFpC,AAAI,EAAQ,OACV,AAAI,EAAQ,MACH,AAAI,AAAI,EAAS,GAAjB,IAEA,AAAI,AAAI,EAAS,KAAjB,GAA0B,AAAI,EAAS,OAGhD,AAAI,EAAQ,QACH,AAAI,AAAI,EAAS,KAAjB,IAEA,AAAI,AAAI,EAAS,OAAjB,GAA+B,AAAI,EAAS,mBC9FvD,EAEE,AAAU,AAAE,eAAK,AAAO,EAAe,GAAtB,MAEV,AADQ,AAFP,EAAe,QAIzB,AAAW,AADa,EAAO,aACf,gBACoB,AADX,QAEhB,EAAG,EAAQ,EAAG,KACvB,AAAU,QPHV,eACA,eACA,wGAoGA,AAAW,AA/DiB,AA8DnB,OA9DwC,KAgEjD,EAAO,EAAQ,KACF,AAAO,AAvDP,KAAqB,GAuDA,mBAChC,AAAgB,EAA0B,KAC1C,AAAO,AAnEmB,KAAqB,YAe1B,AAAqC,EAApC,KAAqB,MAA3C,kBAVqB,AAA0B,KAAqB,GAA/C,KAArB,oBAuCA,AAAW,OACU,EAA0B,KAA/C,eACA,eACA,EAAY,IACZ,qBAKA,AAAI,AAAQ,EAAR,KAA4B,wBAAd,AAAO,KACzB,EAtBA,AAAI,AADO,AA/Be,KAAqB,QAiClC,AAAO,EAAqB,EAA0B,KAA/C,0BAIT,AAAO,AADP,wBAEX,UAAY,KACZ,EAAY,SAbL,AADI,OACI,QalGjB,AAAI,AAAK,AADC,ObmGqC,KalGN,cbkGL,AajGpC,AAAO,AAA2C,EAAK,GAA3B,QbiG2B,MA6BrD,EAAY,EAAS,AAAqB,AAAK,GAAS,EAAnC,WFuHZ,AAAO,AADF,OACc,oBAEnB,AAAO,AADP,EAAY,KACG,mBAcf,AAAO,AAAgB,AAVlC,AAAI,EAAO,MAEJ,AAAM,EAAQ,IAMnB,AAFK,EAAM,AAAW,AADJ,AAAI,EAAM,sBAGtB,KADD,AAAO,EAAgB,EAAK,IAAa,MAGT,GAArB,EAAK,qBAIvB,AAAW,OACX,AAAI,AAFO,SAED,gBACV,AAAI,IAAM,gBA9HV,AACE,AAA2B,AAAC,AAAkB,EAAjB,EAAM,IAAyB,GAA5D,MAgIE,KAxHJ,AACE,AAA2B,AAAC,AAAkB,EAAjB,EAAM,IAAyB,GAA5D,YACA,KA0HA,AAAI,AAAC,KAEa,AAzJlB,AAA2B,EAAM,GAAjC,QAyJ2B,EAAO,MAjJpC,AACE,UACA,KAkJE,AAAI,AAAC,KAAO,KAAc,EAAO,MAArB,wBArGL,AAAO,mBAEP,AAAO,AADF,OACc,oBAM1B,AAHY,qBAGA,KACd,AAAY,EAAM,IACS,EAAY,GAAkB,EAAY,MAArE,eAEY,AADJ,AAnHe,EAA2B,GAAkB,KAAe,YAyHrF,AAAI,EAAY,KAGH,AAAO,AADH,AADJ,AAhIM,EAA2B,aAkIf,oBAC7B,AAAY,EAAM,IAES,EAAW,GAAkB,EAAY,MAApE,gBAIa,EAAY,KAA3B,eAKW,AAAO,AADP,EAAY,KACG,mBACf,AAAO,AAA4C,EAA5C,EAA2B,IAAyB,mBAGtE,AAAa,EAA2B,WAAiB,KAc9C,AAAO,AAAgB,AAVlC,AAAI,EAAO,MAEJ,AAAM,EAAQ,IAMnB,AAFK,EAAM,AAAW,AADJ,AAAI,EAAM,sBAGtB,KADD,AAAO,EAAgB,EAAK,IAAa,MAGT,GAArB,EAAK,qBAvFvB,AACE,AAA2B,AAAC,AAAkB,EAAjB,EAAM,IAAyB,GAA5D,QA0FF,eACA,eACA,AAAI,IAAM,gBApFV,AACE,AAA2B,AAAC,AAAkB,EAAjB,EAAM,IAAyB,GAA5D,YACA,KAsFF,KAAe,EAAK,MAApB,eApHA,AACE,AAA2B,EAAM,GAAjC,QAoHiC,EAAK,MA5GxC,AACE,UACA,WA6NS,AAAO,EAAS,mBAC3B,AAAQ,AAAC,AAAC,QAAgD,KAK1D,AAAI,AAxMJ,AACE,UAwMW,AAAO,EAAS,EAA0B,oBAIrD,AAAI,AAAwB,EAAxB,EAAQ,MAEV,AAAW,OADX,EAAS,OAON,AACE,EAAS,EAA0B,sBAK5C,AAAI,AADO,AAtBX,EAAO,GAsBU,KACN,OAOG,AAAmB,EAAW,GAA9B,AAFC,EAAO,KAEG,MADd,eAEX,eACA,eAIA,AADO,AAA2C,EAAzB,EAAQ,mBA9NjC,AACE,WACA,MAgOF,AAAY,EAAM,UA8CS,AAAO,MAIlC,AAAI,AAAc,AAFA,IACA,KACe,AAAY,EAAc,KAAe,WAE1E,AADW,YACE,KACb,AAAQ,aAAM,QACU,EAAK,KAC3B,AAAY,KAAN,aAAU,KACX,AAAc,MAAG,EAAK,KACzB,AAAkB,EAAJ,SAAN,cAAc,KADY,AAAE,WAFF,AAAE,WAY5B,IAAM,IAAU,EAAiB,KAE7C,AAAO,WAoGP,AAAI,EAAM,SACV,AAAI,AAAC,KAAM,GACD,IA9BV,AAAY,AA8BmB,EA9BK,KACpC,AACgB,EAAM,KAApB,QACE,KAAe,oBAVQ,AAAO,IACnB,KAAe,KAA9B,eACA,AAAY,EAAM,UEpXlB,QAAQ,SAEJ,AAAQ,IACR,AAAa,IACb,EACA,AAAO,IACA,IAGP,AAAY,AAAK,KACjB,AAAM,AAjGkB,KAAqB,KAkG7C,EAAO,AAAO,EAAP,KACL,AAAO,IACP,AAAI,AA1FG,KAAqB,GA0FX,KACf,EAAY,IACZ,AAAa,IACb,AAAgB,EAAyB,KAClC,IAET,AAAM,AA1GgB,KAAqB,SA4G7C,AAAa,IACb,EAEA,AAAI,AAAO,EADL,AA9GkB,KAAqB,MAyEjD,AAAU,IACV,EAAO,EAAM,OACX,AAAQ,AAAY,cACpB,EAAO,SAqCH,AAAM,AAjHgB,KAAqB,KAkH3C,EAAO,AAAO,EAAP,KACL,AAAI,AAzGC,KAAqB,GAyGT,KACf,EAAY,IACZ,AAAgB,EAAyB,MAE3C,AAAM,AAvHc,KAAqB,SAyH3C,AAAW,IACX,AAAY,IACZ,AAAU,IACV,AAAQ,IACR,AAAO,AA7He,KAAqB,KA8H3C,AAAQ,KAEH,IAIP,AAAI,AADE,IACK,KACT,AAAO,AArIe,OAAqB,KAsIhC,AAAO,AAAa,AAAK,GAAlB,AA5HX,EAAqB,oBA6H5B,AAcF,AAdO,EAckB,OAC3B,UAAoB,KACpB,UAAW,MAEX,EAAS,AArIgB,KAAc,GAAhC,MAyIP,AAAO,EAAyB,MArBrB,IAET,iBACe,IAAf,eACA,AAAQ,KAIZ,QF4FW,AAAO,AAAgB,AAdlC,AAAI,EAAO,MAEJ,AAAM,EAAQ,IAUnB,AAFK,EAAM,AAAW,AAHJ,AACd,AAAQ,EAAM,EAAW,AAAW,KAApC,GAA8C,GAC9C,EAFc,EAAO,cAKnB,KADD,AAAO,EAAgB,EAAK,IAAa,MAGT,GAArB,EAAK,qBAKlB,AAFmB,KAAN,MAAa,EAAM,QAzKrC,AACE,AAA2B,AAAC,AAAkB,AAsLZ,GAtLL,EAAM,IAAyB,GAA5D,OA6KA,AAAK,AADO,KAAc,EAAO,EAAK,SAMzB,AAAO,AAtMtB,AACE,AAA2B,AAmMpB,AAAW,KAnMe,GAAjC,yBAsM2B,AAAS,GAAb,SAAN,iBAkHnB,AAAI,EAAO,SAA+B,eAmC1C,AAAI,AAAC,AADO,AAAY,EAAM,AAzC9B,AACI,EACA,AAAC,AAAC,KAAmC,GAAY,GAF9C,EAAQ,aAVf,AAAI,AAAY,AADM,AAHJ,IAGiB,AADjB,AAAO,AAAC,AADlB,EA/PR,AACE,MA8P8B,AAAC,EAAsB,GAAM,KALnD,AAAC,EAAM,EAAW,AAAW,KAAU,GAA/C,KAFE,EAAO,SAQsB,KAAU,KAAa,aAEzB,KAC7B,AAAI,AAAY,IAAe,QAGvB,EAAM,EAAsB,GAAI,EAAqB,KAmDlD,AAAO,AADV,AAA8B,EAAM,wBAGnC,AAAO,AAAC,KAAe,GAAe,mBACjD,AAAY,EAAM,IA/IlB,AAAgB,AAgJG,OA/IC,AAAC,EAAO,GAAkB,mBAI9C,AAAI,AADY,AAAC,EAAY,GAAc,KAC1B,KACA,AAAQ,EAAY,GAApB,KAAf,eAGe,AAAC,EAAY,GAAkB,KAA9C,AADY,AAA8D,EAA5C,EAA2B,mBAEzD,AAAY,EAAM,KAIH,EAAY,KAA3B,eACA,AAAS,mBAAiB,KAlR5B,gBAoZ2B,AAAQ,IACnC,QgBjeE,ECsLA,AAAI,ADtLW,KCuLf,AAAW,ADvLJ,ECuLW,KAClB,AAAU,UAAM,KAChB,AAAU,EAAO,WAAG,KACpB,AAAI,EAAK,KACT,AAAU,UAAM,KAChB,AAAU,UAAM,KAChB,AAAU,EAAO,WAAG,KACpB,AAAU,EAAO,WAAG,KACpB,AAAI,EAAK,KACT,AAAU,UAAM,KAChB,AAAU,EAAO,WAAG,KACpB,AAAI,EAAK,KAWT,AAAO,AAPP,EAAQ,AADO,EAAC,GAAO,QAQT,AALd,AADA,EAAK,GACA,QAML,AAAW,UAAM,KACjB,AAAW,EAAO,WAAG,KACrB,AAAI,EAAK,KACT,AAAW,UAAM,KACjB,AAAW,UAAM,KACjB,AAAW,EAAO,WAAI,KACtB,AAAW,EAAO,WAAG,KACrB,AAAI,EAAK,KACT,AAAW,UAAM,KACjB,AAAW,UAAM,KACjB,AAAW,UAAM,KACjB,AAAW,UAAM,KACjB,AAAW,EAAO,WAAI,KACtB,AAAW,EAAO,WAAI,KACtB,AAAW,EAAO,WAAI,KACtB,AAAW,EAAO,WAAI,KAItB,EAAQ,AADJ,AAAM,EAAO,GAAb,QAEJ,EAAK,KAIL,EAAO,EAAK,KACV,AAAW,UAAM,KACjB,AAAW,UAAM,KACjB,AAAW,UAAM,KACjB,AAAW,UAAM,KACjB,EAAK,KACL,EAAQ,gBfGZ,AAAI,EAAQ,SAAgC,eAC5C,AAAI,EAAS,KAAW,EA2IxB,AAAoB,KACpB,EACE,EAAU,KACV,AAAI,KAEF,AAAY,AAAQ,OAA0B,KAAO,SAIhD,EAAS,MAElB,AAAY,AAAQ,AAAc,AAAM,IAAQ,GAAY,IAAxC,GAAR,OF8JZ,AAAI,AAAC,KAAM,GElTX,AFmTO,AAAgC,EEpTF,AAAkB,EAAlB,oBAErC,eACA,EAAW,EAAW,IACtB,EAxJE,AAAyB,KAAc,GAAhC,MA2JT,AAAY,AAFF,EAAyB,KAEf,IACpB,QezQA,EAAO,AAAM,EAAM,KAAZ,KACK,qBAAiB,SAA3B,EAAkB,QAClB,WAIF,AAAI,AAAC,EAAO,MACV,EAAO,EAAK,KACV,AAAW,UAAW,AAAU,QAChC,AAAW,EAAQ,WAAG,AAAU,QAChC,AAAW,EAAQ,WAAG,AAAU,QAChC,AAAW,EAAO,WAAI,AAAU,QAChC,EAAO,KAAI,EAAQ,KAAI,EAAK,SAE9B,AAAI,EAAI,KACN,AAAW,UAAU,AAAU,QAC/B,AAAW,EAAO,WAAG,AAAU,QACpB,EAAO,KAAlB,EAAQ,MAEV,AAAI,EAAI,KACN,AAAW,UAAM,AAAU,QAChB,EAAO,KAAlB,EAAQ,MAEV,AAAI,EAAI,KACN,AAAW,UAAM,AAAU,QAChB,EAAO,KAAlB,EAAQ,MAEV,AAAI,EAAI,KACN,AAAU,UAAQ,WAOtB,AAAI,EAAK,KACP,QAAQ,EAAY,aAGhB,AAAI,AAAU,OACJ,mBAAiB,OAA3B,EAAkB,QACR,mBAAiB,OAA3B,EAAkB,QACR,mBAAiB,OAA3B,EAAkB,QAClB,EAAK,KACL,EAAO,EAAK,KACV,AAAI,AAAU,OACd,AAAW,UAAM,AAAU,EAAK,GAAf,EAAK,OACtB,AAAI,AAAU,OACd,AAAW,EAAO,WAAG,AAAU,EAAK,GAAf,EAAK,OAC1B,AAAI,AAAU,OACd,AAAW,EAAO,WAAG,AAAU,EAAK,GAAf,EAAK,OAC1B,AAAI,AAAU,OACd,AAAW,EAAO,WAAI,AAAU,EAAK,GAAf,EAAK,OAC3B,EAAO,KAAI,EAAQ,KAAI,EAAK,YAK9B,AAAI,AAAU,OACJ,mBAAiB,OAA3B,EAAkB,QACR,mBAAiB,OAA3B,EAAkB,QAClB,EAAK,KACL,EAAO,EAAK,KACV,AAAI,AAAU,OACd,AAAW,UAAM,AAAU,EAAK,GAAf,EAAK,OACtB,AAAI,AAAU,OACd,AAAW,EAAO,WAAG,AAAU,EAAK,GAAf,EAAK,OAC1B,AAAI,AAAU,OACd,AAAW,EAAO,WAAG,AAAU,EAAK,GAAf,EAAK,OAC1B,AAAI,AAAU,OACd,AAAW,EAAO,WAAI,AAAU,EAAK,GAAf,EAAK,OAC3B,EAAO,KAAI,EAAQ,KAAI,EAAK,YAK9B,AAAI,AAAU,OACJ,qBAAiB,SAA3B,EAAkB,QAClB,EAAK,KACL,EAAO,EAAK,KACV,AAAI,AAAU,OACd,AAAW,UAAM,AAAS,EAAK,GAAd,EAAK,OACtB,AAAI,AAAU,OACd,AAAW,EAAO,WAAG,AAAS,EAAK,GAAd,EAAK,OAC1B,AAAI,AAAU,OACd,AAAW,EAAO,WAAG,AAAS,EAAK,GAAd,EAAK,OAC1B,AAAI,AAAU,OACd,AAAW,EAAO,WAAI,AAAS,EAAK,GAAd,EAAK,OAC3B,EAAO,KAAI,EAAQ,KAAI,EAAK,WAQpC,AAAI,EAAI,KACI,mBAAiB,OAA3B,EAAkB,QACR,mBAAiB,OAA3B,EAAkB,QACR,mBAAiB,OAA3B,EAAkB,QACR,mBAAiB,OAA3B,EAAkB,QACR,mBAAiB,OAA3B,EAAkB,QACR,mBAAiB,OAA3B,EAAkB,QACR,mBAAiB,OAA3B,EAAkB,QACR,mBAAiB,OAA3B,EAAkB,QACR,mBAAiB,OAA3B,EAAkB,QACR,mBAAiB,OAA3B,EAAkB,QACR,mBAAiB,OAA3B,EAAkB,QACR,mBAAiB,OAA3B,EAAkB,QACR,mBAAiB,OAA3B,EAAkB,QACR,mBAAiB,OAA3B,EAAkB,QACR,mBAAiB,OAA3B,EAAkB,QACR,OAAV,AAAU,UAAQ,QAAS,QAE7B,AAAI,EAAI,KACI,mBAAiB,OAA3B,EAAkB,QACR,mBAAiB,OAA3B,EAAkB,QACR,mBAAiB,OAA3B,EAAkB,QACR,mBAAiB,OAA3B,EAAkB,QACR,mBAAiB,OAA3B,EAAkB,QACR,mBAAiB,OAA3B,EAAkB,QACR,mBAAiB,OAA3B,EAAkB,QACR,OAAV,AAAU,UAAQ,QAAS,QAE7B,AAAI,EAAI,KACI,mBAAiB,OAA3B,EAAkB,QACR,mBAAiB,OAA3B,EAAkB,QACR,mBAAiB,OAA3B,EAAkB,QACR,OAAV,AAAU,UAAQ,QAAS,QAE7B,AAAI,EAAI,KACI,mBAAiB,OAA3B,EAAkB,QACR,OAAV,AAAU,UAAQ,QAAS,QAE7B,AAAI,EAAI,KACN,AAAU,UAAQ,eDhHlB,EAAkB,ICuHpB,AAAI,EAAS,KACa,AACpB,EAAM,GAAO,GAAK,EAAE,EAAK,OAC3B,AAAO,EAAM,EAAK,OAItB,AAAI,EAAO,KACiB,AACpB,AAAC,EAAM,GAAO,EAAO,MACvB,EAAO,EAAO,KACZ,AAAI,AAAC,KACL,AAAE,OACQ,qBAAiB,SAA3B,EAAkB,YAEpB,EAAO,EAAK,KACV,AAAW,UAAM,AAAU,QAC3B,EAAQ,KACR,EAAQ,KACR,EAAQ,UAId,EAAO,IACK,qBAAiB,SAA3B,EAAkB,QAClB,AAAE,YAGsB,AACpB,AAAC,EAAM,GAAO,EAAO,MACvB,EAAO,AAAC,EAAO,GAAK,KAClB,AAAI,AAAC,KACL,AAAU,AAAO,AAAE,OAAT,WAAY,AAAS,EAAM,aAEvC,EAAO,EAAK,KAEV,AAAW,AAAO,AADlB,EAAK,KACM,WAAU,AAAU,EAAM,cAI3C,EAAO,IACL,AAAU,AAAO,AAAE,OAAT,WAAY,AAAS,EAAM,45BTHzC,EAAO,EAAO,OAGZ,AAAQ,EAAM,OACd,AAAM,AAFE,EAAM,OAOd,AAAc,AAAe,AAAU,AAH9B,EAAI,IAGuC,GAAvB,SAC7B,AAAc,AAAe,AAAU,AAH9B,EAAI,IAGuC,GAAvB,SAG7B,AAAW,AAAU,AADrB,EAAU,KACqB,GAApB,WAAwB,AAAW,EAAW,GAAtB,UAGrC,AAAI,EAAO,MAET,AAAS,EAAM,MACf,AAAM,AAFG,EAAM,MAIf,AAAa,AAAU,AAAU,EAAa,GAAvB,SACvB,AAAW,AAAU,AAFrB,EAAU,KAEqB,GAApB,WAAwB,MAGrC,AAAI,EAAO,KAET,AAAa,AAAU,AAAU,EAAc,GAAxB,SACvB,AAAW,AAAU,AAFrB,EAAU,GAEqB,GAApB,WAAwB,MAGnC,AAAY,AAAc,EAAd,KACZ,AAAW,AAAU,AAFrB,EAAU,GAEqB,GAApB,WAAwB,S+B/EnC,AAAS,AAA2B,EAAgB,GAA3C,WAA0D,qEdnInC,UAC9B,AAAI,IACF,EAAc,UACd,wFgB0EJ,uL5BjCO,AAAmB,EAA0B,MAA0B,kBAA9E,kEA6mBE,AAAa,AAAS,AAAO,AADhB,EAC4D,aAEzE,AAAO,EAAS,KAEd,AAAI,AADK,AAAe,OACf,MAGP,EAAU,IACL,AAAI,EAAK,MACd,EAAU,IAEV,AAAI,AAAC,EAAK,KAAW,KAAU,AAAa,EAAb,EAAS,OACtC,AAAI,AAAC,AAAe,KAAa,KAAW,OAC1C,EAAU,KAAG,EAAU,SAI3B,EAAU,OAEZ,EAAU,4OYxoBe,UAC3B,AAAI,IACF,EAAc,IACd,+BPLa,OAsGjB,EAAO,EAAM,MACD,2BAAV,AAAU,UAAY,AAAC,EAAM,IAAQ,OACrC,AAAM,AAAI,EAAQ,SAEV,2BAAV,AAAU,UAAY,KArCtB,AAAY,KAAU,KAAiB,OACvC,KAAY,QAAZ,kBC0CM,AAnHQ,OAmHA,MACR,GACA,EAAQ,OACR,GACA,AACA,EACA,AACA,EACA,EAFA,EAAQ,QAFR,EAAQ,SAPd,uBA1CA,KAAY,QAAZ,+BM3D4B,UAC1B,AAAI,IACF,EAAc,IACd,IACA,AAAkB,EAAmB,IACrC,mEe4sGF,AAAI,OACF,EAAc,IACD,OAAb,+BtBttGJ,AAAI,EAAQ,KAmBK,uHA8EjB,EAAO,EAAM,MACD,2BAAV,AAAU,UAAY,AAAC,EAAM,IAAQ,OACrC,AAAM,AAAI,EAAQ,SAEV,2BAAV,AAAU,UAAY,SCxGtB,AAAI,EAAQ,KAEV,KAAY,KAAZ,gBA4GI,EAAQ,MACR,GACA,EAAQ,OACR,GACA,AACA,EACA,AACA,EACA,EAFA,EAAQ,QAFR,EAAQ,SAPd,AAvGE,wCqBwtGwB,UACxB,AAAI,IACF,EAAc,IACd,IACA,AAAoB,EAAiB,IACrC,kBC1vGN,AAAI,AAAU,AADI,AAAO,OACK,GAA1B,KACF,AAAI,EAAU,SAAkD,cAChE,AAAc,AAAkB,OAGhC,AAAkB,AAAI,EAAS,QAAa,OvC+P9C,AAAI,AuC9PF,AAAI,IAAuB,AAAI,AAAI,EAAe,KAAG,kBAAgB,cvC8P3D,AAAC,AAFA,AuC3PW,EvC2PiB,QAEZ,GAAM,MACjC,UAAgB,KACT,OAKT,AAAY,AADC,AAAM,EAAM,SACL,EAAQ,AAAI,EAAM,gBuC9PhC,AANU,EAME,KACd,AAAa,UAAO,KACpB,AAAa,UAAO,mBAGtB,AAAW,UAAO,6D5BelB,AAAO,AAAmB,EAA0B,MAA0B,QAA9E,AAAO,AAAmB,EAA0B,MAA0B,6EAmC9E,MR42BF,4JAAQ,wFACqB,KACD,KACD,KACI,KACG,KACD,KACN,KACE,KACH,KACE,KACF,KACI,KACH,KACM,KACA,KACF,KACH,KACK,KACR,KACE,KACA,KACA,KACD,KACO,KACP,KACC,KACK,KACN,KACC,KACH,KACI,KACD,KACD,KACC,KACA,KACE,KACC,KACG,KACJ,KACC,KACE,KACL,KACC,KACD,KACA,KACC,KACD,KACC,KACD,KACA,KACK,KACL,KACA,KACE,KACD,KACE,KACM,KACP,KACD,KACD,KACD,KACI,KACC,KACL,KACA,KACC,KACS,KACL,KACJ,KACD,KACC,KACD,KACC,KACG,KACF,KACF,KACM,KAEhC,SqCn3BA,YAAQ,AALE,A7BtGD,AAAmB,EAA0B,MAA0B,c6B4GtE,AAEF,AADI,AAAe,OACV,OAEP,AAEF,AADI,AAAe,OACV,OAEP,AAEF,AADI,AAAe,OACV,OAIb,AAAI,AADQ,AAAe,OACd,MACb,AAAa,WAAS,MACtB,AAAa,WAAS,KACtB,AAAW,WAAS,AAAQ,EAAS,GAAjB,GAAqB,EAAS,IAAK,EAAS,OAEhE,AAAI,AADM,AAAS,EAAS,GAAS,EAAG,cACf,AAAc,uB7B8evC,AAAa,A6B1e2B,I7B0elB,AAAO,AADhB,EAC4D,WAEzE,AAAO,EAAS,KAEd,AAAI,AADK,AAAe,OACf,MAGP,EAAU,IACL,AAAI,EAAK,MACd,EAAU,IAEV,AAAI,AAAC,EAAK,KAAW,KAAU,AAAa,EAAb,EAAS,OACtC,AAAI,AAAC,AAAe,KAAa,KAAW,OAC1C,EAAU,KAAG,EAAU,SAI3B,EAAU,OAEZ,EAAU,Sb1HhB,AAAI,AAAC,KAAM,GACX,AAAO,AAAgC,EAAM,IAAS,S0ClY/C,AAAyB,EAAyB,EAAK,IAAY,mBAC1E,AAAa,WAAS,KACtB,AAAa,WAAS,KACtB,AAAU,AAAS,EAAS,GAAS,EAAG,OACxC,AAAO,IACP,AAAI,SAAqB,AAAc,wLG9JvC,QAAqD,QAEnD,AAAa,AAAc,EAAV,AADJ,UAEb,AAAc,OEvBhB,QAAkC,YACpB,AAAyB,MIqbvC,QAA8C,QAC5C,AAAiC,IJpbjC,AAA2B,YCa7B,OAAsD,YACxC,AAAyB,MGqavC,QAA8C,QAC5C,AAAiC,IHpajC,AAA6B,EAAO,IHwB7B,AAAS,EAAT,KIrDX,QAA8D,QAC5D,AAAI,AAAC,aAA2B,cFehC,QAAqB,QACnB,ECkCF,QAAqB,QACnB,SS9CJ,QAAgD,WhB2G5C,AAAI,AAAc,AAAK,KAAnB,KAAsD,eAO1D,AANoB,KAAkB,EAAgB,YAkHtD,AAAe,EAAyB,AAD9B,AADG,OACM,KArN+D,IA0N3E,AACI,KAAkB,EAAiB,YAAe,KAE7D,kDvB7FA,EAAO,EAAM,MACD,2BAAV,AAAU,UAAY,AAAC,EAAM,IAAQ,OACrC,AAAM,AAAI,EAAQ,SAEV,2BAAV,AAAU,UAAY,cCMhB,EAAQ,MACR,GACA,EAAQ,OACR,GACA,AACA,EACA,AACA,EACA,EAFA,EAAQ,QAFR,EAAQ,SAPd,2HsBlEA,ujBA+MU,KACV,AAAU,AAAQ,KAAkB,AAAU,OAAQ,SACtD,UAAe,kCAFL,KACV,AAAU,AAAQ,KAAkB,AAAU,OAAQ,SACtD,UAAe,4CAnKb,AAAI,EAAQ,KAAwB,eACpC,AAAe,EAAyB,EAAQ,KApHgC,IAqHhF,UAAe,MAEjB,AAIS,KAAkB,EAAgB,YAAe,yFAyJxB,qKFqGhC,AAAU,AAAM,AAAmB,EAA0B,MAAnD,KACV,EAAO,EAAM,KAEX,AAAI,AADM,AAAY,cAEtB,EAAO,8BgBlKX,AAAQ,qCItMR,AAAQ,gBJ8NR,AAAQ,AAvBwB,gBdqThC,AAAQ,AAAkB,w+HAxc1B,AAAe,EAAyB,EAAyB,IACjE,qCADA,AAAe,EAAyB,EAAyB,IACjE,qCADA,AAAe,EAAyB,EAAyB,IACjE,gFvB+CW,AAAe,wCACf,UAAX,eACA,UAAiB,8sBwBlBE,AACyB,oBADzB,AACyB,uiQ1Cgc9C,AAAI,AAAC,KAAM,GACX,AAAO,AAAgC,EAAM,IAAS,iCmC7gBpD,QAAoC,QAClC,UAAS,KACT,UAAS,mEnC0gBb,AAAI,AAAC,KAAM,GACX,AAAO,AAAgC,EAAM,IAAS,kBmCxepD,QAA4B,QAC1B,wGCnDkB,AAOZ,AAAuB,EAAI,GAAK,AAAI,EAAJ,AAL5B,SAKH,AAAU,AAAK,EAAL,GAAV,EAAK,OACD,AAAmB,EAAG,OAqBnC,AAA0B,EAAG,2DCmC7B,AAAc,mBAAd,AAAc,2FEmRe,AAAgB,GAAyB,AA9Q/D,MAAwE,oEFL/E,AAAc,qNrCydhB,AAAI,AAAC,KAAM,GACX,AAAO,AAAgC,EAAM,IAAS,iCmC1bpD,QAAoC,QAClC,UAAS,KACT,UAAS,kEnCubb,AAAI,AAAC,KAAM,GACX,AAAO,AAAgC,EAAM,IAAS,kBmCrZpD,QAA4B,QAC1B,wGCxDkB,AAMZ,AAAuB,EAAI,GAAK,AAAI,EAAJ,AAF1B,SAEL,AAAU,AAAK,EAAL,GAAV,EAAK,OAED,AAAmB,EAAG,OAoBnC,AAA0B,EAAG,2DC1C7B,AAAc,mBAAd,AAAc,gGEmRe,AAAgB,IAAyB,AA9Q/D,OAAwE,qEFL/E,AAAc,qNrCydhB,AAAI,AAAC,KAAM,GACX,AAAO,AAAgC,EAAM,IAAS,iCmCvWpD,QAAoC,QAClC,UAAS,KACT,UAAS,kEnCoWb,AAAI,AAAC,KAAM,GACX,AAAO,AAAgC,EAAM,IAAS,kBmClUpD,QAA4B,QAC1B,wGC5DA,AAAI,KAEK,AAAmB,EAAG,OAI/B,AAAI,AAAiB,EAAK,GAGtB,AAAqB,EAAK,eASnB,AAAmB,EAAG,OAOjC,AAAI,AAFM,EAAI,KAEN,GAAK,KAEJ,AAAmB,EAAG,OAsBjC,AAA0B,EAAG,2DC9I7B,AAAc,mBAAd,AAAc,gGEmRe,AAAgB,IAAyB,AA9Q/D,OAAwE,qEFL/E,AAAc,sNrCydhB,AAAI,AAAC,KAAM,GACX,AAAO,AAAgC,EAAM,IAAS,iCmCpRpD,QAAoC,QAClC,UAAS,MACT,UAAS,kEnCiRb,AAAI,AAAC,KAAM,GACX,AAAO,AAAgC,EAAM,IAAS,kBmC/OpD,QAA4B,QAC1B,wGC3CA,AAAI,EAAsB,GAGtB,EAA0B,eASnB,AAAmB,EAAG,OAKjC,AAAI,EAAK,KAEA,AAAmB,EAAI,GAAG,OAcrC,AAA0B,EAAG,2DClO7B,AAAc,mBAAd,AAAc,gGEmRe,AAAgB,IAAyB,AA9Q/D,OAAwE,qEFL/E,AAAc,w/CtBvDhB,AAAa,AAAM,EAAM,MACzB,IAAU,AAAY,EAAQ,EAAM,OACpC,wwBP2FI,KAAQ,OACN,EAAQ,MACH,AAAI,AAAI,EAAS,GAAjB,IAEA,AAAI,AAAI,EAAS,KAAjB,GAA0B,AAAI,EAAS,OAG5C,EAAQ,QACH,AAAI,AAAI,EAAS,KAAjB,IAEA,AAAI,AAAI,EAAS,OAAjB,GAA+B,AAAI,EAAS,6CAQnD,EAAQ,YACN,EAAQ,UACH,AAAK,AAAI,EAAS,QAAlB,GAAkC,AAAI,EAAS,SAE/C,AAAK,AAAI,EAAS,SAAlB,GAAqC,AAAI,EAAS,YAGvD,EAAQ,aACH,AAAK,AAAI,EAAS,UAAlB,IAEA,AAAK,AAAI,EAAS,YAAlB,GAA0C,AAAI,EAAS,+BA4DlE,EAAO,EAAO,QAaZ,AAAc,AAAe,AAAU,AAH9B,AAJD,AAJA,AAAQ,EAAM,AADd,EAAM,QACY,UAId,OAIC,IAGuC,GAAvB,SAC7B,AAAc,AAAe,AAAU,AAH9B,EAAI,IAGuC,GAAvB,SAG7B,AAAW,AAAU,AADrB,EAAU,KACqB,GAApB,WAAwB,AAAW,EAAW,GAAtB,MAEnC,AAAU,AAAe,AAAU,AAX1B,AAHD,EAAI,OAGC,IAWmC,GAAvB,SACzB,AAAU,AAAe,AAAU,AAX1B,EAAI,IAWmC,GAAvB,SAGzB,AAAW,AAAU,AADrB,EAAU,KACqB,GAApB,WAAwB,AAAW,EAAW,GAAtB,UAGrC,AAAe,EAAQ,GAAU,+MKrM/B,AAAO,AAAmB,EAA0B,MAA0B,wBAA9E,AAAO,MAAuE,wFAA9E,AAAO,AAAmB,EAA0B,MAA0B,mGAA9E,AAAO,AAAmB,EAA0B,MAA0B,6kB6ClDlF,OAA+C,YAC7C","sourceRoot":"./output.wasm","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n// @ts-ignore: decorator\n@inline export const TRACE = false;\n// @ts-ignore: decorator\n@inline export const RTRACE = isDefined(ASC_RTRACE);\n// @ts-ignore: decorator\n@inline export const PROFILE = isDefined(ASC_PROFILE);\n\n// Memory manager\n\n// ╒════════════ Memory manager block layout (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                           MM info                             │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize;\n}\n\n/** Overhead of a memory manager block. */\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = offsetof<BLOCK>();\n\n/** Maximum size of a memory manager block's payload. */\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n\n// Garbage collector\n\n// ╒══════════ Garbage collector object layout (32-bit) ═══════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                     Memory manager block                      │ -20\n// ╞═══════════════════════════════════════════════════════════════╡\n// │                            GC info                            │ -16\n// ├───────────────────────────────────────────────────────────────┤\n// │                            GC info                            │ -12\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT id                              │ -8\n// ├───────────────────────────────────────────────────────────────┤\n// │                            RT size                            │ -4\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                              ...                              │\n@unmanaged export class OBJECT extends BLOCK {\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Garbage collector info. */\n  gcInfo2: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n/** Overhead of a garbage collector object. Excludes memory manager block overhead. */\n// @ts-ignore: decorator\n@inline export const OBJECT_OVERHEAD: usize = (offsetof<OBJECT>() - BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK;\n\n/** Maximum size of a garbage collector object's payload. */\n// @ts-ignore: decorator\n@inline export const OBJECT_MAXSIZE: usize = BLOCK_MAXSIZE - OBJECT_OVERHEAD;\n\n/** Total of memory manager and garbage collector overhead. */\n// @ts-ignore: decorator\n@inline export const TOTAL_OVERHEAD: usize = BLOCK_OVERHEAD + OBJECT_OVERHEAD;\n","import { AL_BITS, AL_SIZE, AL_MASK, DEBUG, BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE } from \"./common\";\nimport { oninit, onalloc, onresize, onmove, onfree } from \"./rtrace\";\nimport { E_ALLOCATION_TOO_LARGE } from \"../util/error\";\n\n// === The TLSF (Two-Level Segregate Fit) memory allocator ===\n// see: http://www.gii.upv.es/tlsf/\n\n// - `ffs(x)` is equivalent to `ctz(x)` with x != 0\n// - `fls(x)` is equivalent to `sizeof(x) * 8 - clz(x) - 1`\n\n// ╒══════════════ Block size interpretation (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┴─┴─┴─╫─┴─┴─┴─┤\n// │ |                    FL                       │ SB = SL + AL  │ ◄─ usize\n// └───────────────────────────────────────────────┴───────╨───────┘\n// FL: first level, SL: second level, AL: alignment, SB: small block\n\n// @ts-ignore: decorator\n@inline const SL_BITS: u32 = 4;\n// @ts-ignore: decorator\n@inline const SL_SIZE: u32 = 1 << SL_BITS;\n\n// @ts-ignore: decorator\n@inline const SB_BITS: u32 = SL_BITS + AL_BITS;\n// @ts-ignore: decorator\n@inline const SB_SIZE: u32 = 1 << SB_BITS;\n\n// @ts-ignore: decorator\n@inline const FL_BITS: u32 = 31 - SB_BITS;\n\n// [00]: < 256B (SB)  [12]: < 1M\n// [01]: < 512B       [13]: < 2M\n// [02]: < 1K         [14]: < 4M\n// [03]: < 2K         [15]: < 8M\n// [04]: < 4K         [16]: < 16M\n// [05]: < 8K         [17]: < 32M\n// [06]: < 16K        [18]: < 64M\n// [07]: < 32K        [19]: < 128M\n// [08]: < 64K        [20]: < 256M\n// [09]: < 128K       [21]: < 512M\n// [10]: < 256K       [22]: <= 1G - OVERHEAD\n// [11]: < 512K\n// VMs limit to 2GB total (currently), making one 1G block max (or three 512M etc.) due to block overhead\n\n// Tags stored in otherwise unused alignment bits\n\n// @ts-ignore: decorator\n@inline const FREE: usize = 1 << 0;\n// @ts-ignore: decorator\n@inline const LEFTFREE: usize = 1 << 1;\n// @ts-ignore: decorator\n@inline const TAGS_MASK: usize = FREE | LEFTFREE; // <= AL_MASK\n\n// ╒════════════════════ Block layout (32-bit) ════════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┼─┤            ┐\n// │                          size                             │L│F│ ◄─┐ info   overhead\n// ╞>ptr═══════════════════════════════════════════════════════╧═╧═╡   │        ┘\n// │                        if free: ◄ prev                        │ ◄─┤ usize\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                        if free: next ►                        │ ◄─┤\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                             ...                               │   │ >= 0\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                        if free: back ▲                        │ ◄─┘\n// └───────────────────────────────────────────────────────────────┘ >= MIN SIZE\n// F: FREE, L: LEFTFREE\n@unmanaged export class Block extends BLOCK {\n\n  /** Previous free block, if any. Only valid if free, otherwise part of payload. */\n  prev: Block | null;\n  /** Next free block, if any. Only valid if free, otherwise part of payload. */\n  next: Block | null;\n\n  // If the block is free, there is a 'back'reference at its end pointing at its start.\n}\n\n// Block constants. A block must have a minimum size of three pointers so it can hold `prev`,\n// `next` and `back` if free.\n\n// @ts-ignore: decorator\n@inline const BLOCK_MINSIZE: usize = ((3 * sizeof<usize>() + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD; // prev + next + back\n// @ts-ignore: decorator\n// @inline const BLOCK_MAXSIZE: usize = 1 << (FL_BITS + SB_BITS - 1); // exclusive, lives in common.ts\n\n/** Gets the left block of a block. Only valid if the left block is free. */\n// @ts-ignore: decorator\n@inline function GETFREELEFT(block: Block): Block {\n  return load<Block>(changetype<usize>(block) - sizeof<usize>());\n}\n\n/** Gets the right block of a block by advancing to the right by its size. */\n// @ts-ignore: decorator\n@inline function GETRIGHT(block: Block): Block {\n  return changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + (block.mmInfo & ~TAGS_MASK));\n}\n\n// ╒═════════════════════ Root layout (32-bit) ════════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤          ┐\n// │        0        |           flMap                            S│ ◄────┐\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                           slMap[0] S                          │ ◄─┐  │\n// ├───────────────────────────────────────────────────────────────┤   │  │\n// │                           slMap[1]                            │ ◄─┤  │\n// ├───────────────────────────────────────────────────────────────┤  u32 │\n// │                           slMap[22]                           │ ◄─┘  │\n// ╞═══════════════════════════════════════════════════════════════╡    usize\n// │                            head[0]                            │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                              ...                              │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                           head[367]                           │ ◄────┤\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                             tail                              │ ◄────┘\n// └───────────────────────────────────────────────────────────────┘   SIZE   ┘\n// S: Small blocks map\n@unmanaged class Root {\n  /** First level bitmap. */\n  flMap: usize;\n}\n\n// Root constants. Where stuff is stored inside of the root structure.\n\n// @ts-ignore: decorator\n@inline const SL_START: usize = sizeof<usize>();\n// @ts-ignore: decorator\n@inline const SL_END: usize = SL_START + (FL_BITS << alignof<u32>());\n// @ts-ignore: decorator\n@inline const HL_START: usize = (SL_END + AL_MASK) & ~AL_MASK;\n// @ts-ignore: decorator\n@inline const HL_END: usize = HL_START + FL_BITS * SL_SIZE * sizeof<usize>();\n// @ts-ignore: decorator\n@inline const ROOT_SIZE: usize = HL_END + sizeof<usize>();\n\n// @ts-ignore: decorator\n@lazy export var ROOT: Root;\n\n/** Gets the second level map of the specified first level. */\n// @ts-ignore: decorator\n@inline function GETSL(root: Root, fl: usize): u32 {\n  return load<u32>(\n    changetype<usize>(root) + (fl << alignof<u32>()),\n    SL_START\n  );\n}\n\n/** Sets the second level map of the specified first level. */\n// @ts-ignore: decorator\n@inline function SETSL(root: Root, fl: usize, slMap: u32): void {\n  store<u32>(\n    changetype<usize>(root) + (fl << alignof<u32>()),\n    slMap,\n    SL_START\n  );\n}\n\n/** Gets the head of the free list for the specified combination of first and second level. */\n// @ts-ignore: decorator\n@inline function GETHEAD(root: Root, fl: usize, sl: u32): Block | null {\n  return load<Block>(\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\n    HL_START\n  );\n}\n\n/** Sets the head of the free list for the specified combination of first and second level. */\n// @ts-ignore: decorator\n@inline function SETHEAD(root: Root, fl: usize, sl: u32, head: Block | null): void {\n  store<Block | null>(\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\n    head,\n    HL_START\n  );\n}\n\n/** Gets the tail block.. */\n// @ts-ignore: decorator\n@inline function GETTAIL(root: Root): Block {\n  return load<Block>(\n    changetype<usize>(root),\n    HL_END\n  );\n}\n\n/** Sets the tail block. */\n// @ts-ignore: decorator\n@inline function SETTAIL(root: Root, tail: Block): void {\n  store<Block>(\n    changetype<usize>(root),\n    tail,\n    HL_END\n  );\n}\n\n/** Inserts a previously used block back into the free list. */\nfunction insertBlock(root: Root, block: Block): void {\n  if (DEBUG) assert(block); // cannot be null\n  var blockInfo = block.mmInfo;\n  if (DEBUG) assert(blockInfo & FREE); // must be free\n\n  var right = GETRIGHT(block);\n  var rightInfo = right.mmInfo;\n\n  // merge with right block if also free\n  if (rightInfo & FREE) {\n    removeBlock(root, right);\n    block.mmInfo = blockInfo = blockInfo + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK); // keep block tags\n    right = GETRIGHT(block);\n    rightInfo = right.mmInfo;\n    // 'back' is set below\n  }\n\n  // merge with left block if also free\n  if (blockInfo & LEFTFREE) {\n    let left = GETFREELEFT(block);\n    let leftInfo = left.mmInfo;\n    if (DEBUG) assert(leftInfo & FREE); // must be free according to right tags\n    removeBlock(root, left);\n    block = left;\n    block.mmInfo = blockInfo = leftInfo + BLOCK_OVERHEAD + (blockInfo & ~TAGS_MASK); // keep left tags\n    // 'back' is set below\n  }\n\n  right.mmInfo = rightInfo | LEFTFREE;\n  // reference to right is no longer used now, hence rightInfo is not synced\n\n  // we now know the size of the block\n  var size = blockInfo & ~TAGS_MASK;\n  if (DEBUG) assert(size >= BLOCK_MINSIZE); // must be a valid size\n  if (DEBUG) assert(changetype<usize>(block) + BLOCK_OVERHEAD + size == changetype<usize>(right)); // must match\n\n  // set 'back' to itself at the end of block\n  store<Block>(changetype<usize>(right) - sizeof<usize>(), block);\n\n  // mapping_insert\n  var fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    let boundedSize = min(size, BLOCK_MAXSIZE);\n    fl = inv - clz<usize>(boundedSize);\n    sl = <u32>((boundedSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // perform insertion\n  var head = GETHEAD(root, fl, sl);\n  block.prev = null;\n  block.next = head;\n  if (head) head.prev = block;\n  SETHEAD(root, fl, sl, block);\n\n  // update first and second level maps\n  root.flMap |= (1 << fl);\n  SETSL(root, fl, GETSL(root, fl) | (1 << sl));\n}\n\n/** Removes a free block from internal lists. */\nfunction removeBlock(root: Root, block: Block): void {\n  var blockInfo = block.mmInfo;\n  if (DEBUG) assert(blockInfo & FREE); // must be free\n  var size = blockInfo & ~TAGS_MASK;\n  if (DEBUG) assert(size >= BLOCK_MINSIZE); // must be valid\n\n  // mapping_insert\n  var fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    let boundedSize = min(size, BLOCK_MAXSIZE);\n    fl = inv - clz<usize>(boundedSize);\n    sl = <u32>((boundedSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // link previous and next free block\n  var prev = block.prev;\n  var next = block.next;\n  if (prev) prev.next = next;\n  if (next) next.prev = prev;\n\n  // update head if we are removing it\n  if (block == GETHEAD(root, fl, sl)) {\n    SETHEAD(root, fl, sl, next);\n\n    // clear second level map if head is empty now\n    if (!next) {\n      let slMap = GETSL(root, fl);\n      SETSL(root, fl, slMap &= ~(1 << sl));\n\n      // clear first level map if second level is empty now\n      if (!slMap) root.flMap &= ~(1 << fl);\n    }\n  }\n  // note: does not alter left/back because it is likely that splitting\n  // is performed afterwards, invalidating those changes. so, the caller\n  // must perform those updates.\n}\n\n/** Searches for a free block of at least the specified size. */\nfunction searchBlock(root: Root, size: usize): Block | null {\n  // size was already asserted by caller\n\n  // mapping_search\n  var fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const halfMaxSize = BLOCK_MAXSIZE >> 1; // don't round last fl\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    const invRound = inv - SL_BITS;\n    let requestSize = size < halfMaxSize\n      ? size + (1 << (invRound - clz<usize>(size))) - 1\n      : size;\n    fl = inv - clz<usize>(requestSize);\n    sl = <u32>((requestSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // search second level\n  var slMap = GETSL(root, fl) & (~0 << sl);\n  var head: Block | null = null;\n  if (!slMap) {\n    // search next larger first level\n    let flMap = root.flMap & (~0 << (fl + 1));\n    if (!flMap) {\n      head = null;\n    } else {\n      fl = ctz<usize>(flMap);\n      slMap = GETSL(root, fl);\n      if (DEBUG) assert(slMap);  // can't be zero if fl points here\n      head = GETHEAD(root, fl, ctz<u32>(slMap));\n    }\n  } else {\n    head = GETHEAD(root, fl, ctz<u32>(slMap));\n  }\n  return head;\n}\n\n/** Prepares the specified block before (re-)use, possibly splitting it. */\nfunction prepareBlock(root: Root, block: Block, size: usize): void {\n  // size was already asserted by caller\n\n  var blockInfo = block.mmInfo;\n  if (DEBUG) assert(!((size + BLOCK_OVERHEAD) & AL_MASK)); // size must be aligned so the new block is\n\n  // split if the block can hold another MINSIZE block incl. overhead\n  var remaining = (blockInfo & ~TAGS_MASK) - size;\n  if (remaining >= BLOCK_OVERHEAD + BLOCK_MINSIZE) {\n    block.mmInfo = size | (blockInfo & LEFTFREE); // also discards FREE\n\n    let spare = changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + size);\n    spare.mmInfo = (remaining - BLOCK_OVERHEAD) | FREE; // not LEFTFREE\n    insertBlock(root, spare); // also sets 'back'\n\n  // otherwise tag block as no longer FREE and right as no longer LEFTFREE\n  } else {\n    block.mmInfo = blockInfo & ~FREE;\n    GETRIGHT(block).mmInfo &= ~LEFTFREE;\n  }\n}\n\n/** Adds more memory to the pool. */\nfunction addMemory(root: Root, start: usize, end: usize): bool {\n  if (DEBUG) assert(start <= end); // must be valid\n  start = ((start + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n  end &= ~AL_MASK;\n\n  var tail = GETTAIL(root);\n  var tailInfo: usize = 0;\n  if (tail) { // more memory\n    if (DEBUG) assert(start >= changetype<usize>(tail) + BLOCK_OVERHEAD);\n\n    // merge with current tail if adjacent\n    const offsetToTail = AL_SIZE;\n    if (start - offsetToTail == changetype<usize>(tail)) {\n      start -= offsetToTail;\n      tailInfo = tail.mmInfo;\n    } else {\n      // We don't do this, but a user might `memory.grow` manually\n      // leading to non-adjacent pages managed by TLSF.\n    }\n\n  } else if (DEBUG) { // first memory\n    assert(start >= changetype<usize>(root) + ROOT_SIZE); // starts after root\n  }\n\n  // check if size is large enough for a free block and the tail block\n  var size = end - start;\n  if (size < BLOCK_OVERHEAD + BLOCK_MINSIZE + BLOCK_OVERHEAD) {\n    return false;\n  }\n\n  // left size is total minus its own and the zero-length tail's header\n  var leftSize = size - 2 * BLOCK_OVERHEAD;\n  var left = changetype<Block>(start);\n  left.mmInfo = leftSize | FREE | (tailInfo & LEFTFREE);\n  left.prev = null;\n  left.next = null;\n\n  // tail is a zero-length used block\n  tail = changetype<Block>(start + BLOCK_OVERHEAD + leftSize);\n  tail.mmInfo = 0 | LEFTFREE;\n  SETTAIL(root, tail);\n\n  insertBlock(root, left); // also merges with free left before tail / sets 'back'\n\n  return true;\n}\n\n/** Grows memory to fit at least another block of the specified size. */\nfunction growMemory(root: Root, size: usize): void {\n  if (ASC_LOW_MEMORY_LIMIT) {\n    unreachable();\n    return;\n  }\n  // Here, both rounding performed in searchBlock ...\n  const halfMaxSize = BLOCK_MAXSIZE >> 1;\n  if (size < halfMaxSize) { // don't round last fl\n    const invRound = (sizeof<usize>() * 8 - 1) - SL_BITS;\n    size += (1 << (invRound - clz<usize>(size))) - 1;\n  }\n  // and additional BLOCK_OVERHEAD must be taken into account. If we are going\n  // to merge with the tail block, that's one time, otherwise it's two times.\n  var pagesBefore = memory.size();\n  size += BLOCK_OVERHEAD << usize((<usize>pagesBefore << 16) - BLOCK_OVERHEAD != changetype<usize>(GETTAIL(root)));\n  var pagesNeeded = <i32>(((size + 0xffff) & ~0xffff) >>> 16);\n  var pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n  if (memory.grow(pagesWanted) < 0) {\n    if (memory.grow(pagesNeeded) < 0) unreachable();\n  }\n  var pagesAfter = memory.size();\n  addMemory(root, <usize>pagesBefore << 16, <usize>pagesAfter << 16);\n}\n\n/** Computes the size (excl. header) of a block. */\nfunction computeSize(size: usize): usize {\n  // Size must be large enough and aligned minus preceeding overhead\n  return size <= BLOCK_MINSIZE\n    ? BLOCK_MINSIZE\n    : ((size + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n}\n\n/** Prepares and checks an allocation size. */\nfunction prepareSize(size: usize): usize {\n  if (size > BLOCK_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  return computeSize(size);\n}\n\n/** Initializes the root structure. */\nfunction initialize(): void {\n  if (isDefined(ASC_RTRACE)) oninit(__heap_base);\n  var rootOffset = (__heap_base + AL_MASK) & ~AL_MASK;\n  var pagesBefore = memory.size();\n  var pagesNeeded = <i32>((((rootOffset + ROOT_SIZE) + 0xffff) & ~0xffff) >>> 16);\n  if (pagesNeeded > pagesBefore && memory.grow(pagesNeeded - pagesBefore) < 0) unreachable();\n  var root = changetype<Root>(rootOffset);\n  root.flMap = 0;\n  SETTAIL(root, changetype<Block>(0));\n  for (let fl: usize = 0; fl < FL_BITS; ++fl) {\n    SETSL(root, fl, 0);\n    for (let sl: u32 = 0; sl < SL_SIZE; ++sl) {\n      SETHEAD(root, fl, sl, null);\n    }\n  }\n  var memStart = rootOffset + ROOT_SIZE;\n  if (ASC_LOW_MEMORY_LIMIT) {\n    const memEnd = <usize>ASC_LOW_MEMORY_LIMIT & ~AL_MASK;\n    if (memStart <= memEnd) addMemory(root, memStart, memEnd);\n    else unreachable(); // low memory limit already exceeded\n  } else {\n    addMemory(root, memStart, memory.size() << 16);\n  }\n  ROOT = root;\n}\n\n/** Allocates a block of the specified size. */\nexport function allocateBlock(root: Root, size: usize): Block {\n  var payloadSize = prepareSize(size);\n  var block = searchBlock(root, payloadSize);\n  if (!block) {\n    growMemory(root, payloadSize);\n    block = changetype<Block>(searchBlock(root, payloadSize));\n    if (DEBUG) assert(block); // must be found now\n  }\n  if (DEBUG) assert((block.mmInfo & ~TAGS_MASK) >= payloadSize); // must fit\n  removeBlock(root, <Block>block);\n  prepareBlock(root, <Block>block, payloadSize);\n  if (isDefined(ASC_RTRACE)) onalloc(block);\n  return <Block>block;\n}\n\n/** Reallocates a block to the specified size. */\nexport function reallocateBlock(root: Root, block: Block, size: usize): Block {\n  var payloadSize = prepareSize(size);\n  var blockInfo = block.mmInfo;\n  var blockSize = blockInfo & ~TAGS_MASK;\n\n  // possibly split and update runtime size if it still fits\n  if (payloadSize <= blockSize) {\n    prepareBlock(root, block, payloadSize);\n    if (isDefined(ASC_RTRACE)) {\n      if (payloadSize != blockSize) onresize(block, BLOCK_OVERHEAD + blockSize);\n    }\n    return block;\n  }\n\n  // merge with right free block if merger is large enough\n  var right = GETRIGHT(block);\n  var rightInfo = right.mmInfo;\n  if (rightInfo & FREE) {\n    let mergeSize = blockSize + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK);\n    if (mergeSize >= payloadSize) {\n      removeBlock(root, right);\n      block.mmInfo = (blockInfo & TAGS_MASK) | mergeSize;\n      prepareBlock(root, block, payloadSize);\n      if (isDefined(ASC_RTRACE)) onresize(block, BLOCK_OVERHEAD + blockSize);\n      return block;\n    }\n  }\n\n  // otherwise move the block\n  return moveBlock(root, block, size);\n}\n\n/** Moves a block to a new one of the specified size. */\nfunction moveBlock(root: Root, block: Block, newSize: usize): Block {\n  var newBlock = allocateBlock(root, newSize);\n  memory.copy(changetype<usize>(newBlock) + BLOCK_OVERHEAD, changetype<usize>(block) + BLOCK_OVERHEAD, block.mmInfo & ~TAGS_MASK);\n  if (changetype<usize>(block) >= __heap_base) {\n    if (isDefined(ASC_RTRACE)) onmove(block, newBlock);\n    freeBlock(root, block);\n  }\n  return newBlock;\n}\n\n/** Frees a block. */\nexport function freeBlock(root: Root, block: Block): void {\n  if (isDefined(ASC_RTRACE)) onfree(block);\n  block.mmInfo = block.mmInfo | FREE;\n  insertBlock(root, block);\n}\n\n/** Checks that a used block is valid to be freed or reallocated. */\nfunction checkUsedBlock(ptr: usize): Block {\n  var block = changetype<Block>(ptr - BLOCK_OVERHEAD);\n  assert(\n    ptr != 0 && !(ptr & AL_MASK) &&  // must exist and be aligned\n    !(block.mmInfo & FREE)           // must be used\n  );\n  return block;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __alloc(size: usize): usize {\n  if (!ROOT) initialize();\n  return changetype<usize>(allocateBlock(ROOT, size)) + BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __realloc(ptr: usize, size: usize): usize {\n  if (!ROOT) initialize();\n  return (ptr < __heap_base\n    ? changetype<usize>(moveBlock(ROOT, checkUsedBlock(ptr), size))\n    : changetype<usize>(reallocateBlock(ROOT, checkUsedBlock(ptr), size))\n  ) + BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __free(ptr: usize): void {\n  if (ptr < __heap_base) return;\n  if (!ROOT) initialize();\n  freeBlock(ROOT, checkUsedBlock(ptr));\n}\n","// This file is shared with the compiler and must remain portable\n\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\n// │                             count                             │\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\n// │                      Typeinfo#flags [id=0]                    │ id < count\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤\n// │                      Typeinfo#base  [id=0]                    │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              ...                              │\n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\n  /** Base class id or `0` if none. */\n  base: u32 = 0;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `StaticArray`. */\n  STATICARRAY = 1 << 2,\n  /** Type is a `Set`. */\n  SET = 1 << 3,\n  /** Type is a `Map`. */\n  MAP = 1 << 4,\n  /** Type has no outgoing pointers. */\n  POINTERFREE = 1 << 5,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 6,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 7,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 8,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 9,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 10,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 11,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 12,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 13,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 14,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 15,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 16,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 17,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 18,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 19,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 20,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 21,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 22,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 23\n}\n","import { BLOCK, BLOCK_OVERHEAD, OBJECT_OVERHEAD, OBJECT_MAXSIZE, TOTAL_OVERHEAD, DEBUG, TRACE, RTRACE, PROFILE } from \"./common\";\nimport { onvisit, oncollect, oninterrupt, onyield } from \"./rtrace\";\nimport { TypeinfoFlags } from \"../shared/typeinfo\";\nimport { E_ALLOCATION_TOO_LARGE, E_ALREADY_PINNED, E_NOT_PINNED } from \"../util/error\";\n\n// === ITCMS: An incremental Tri-Color Mark & Sweep garbage collector ===\n// Adapted from Bach Le's μgc, see: https://github.com/bullno1/ugc\n\n// ╒═════════════╤══════════════ Colors ═══════════════════════════╕\n// │ Color       │ Meaning                                         │\n// ├─────────────┼─────────────────────────────────────────────────┤\n// │ WHITE*      │ Unprocessed                                     │\n// │ BLACK*      │ Processed                                       │\n// │ GRAY        │ Processed with unprocessed children             │\n// │ TRANSPARENT │ Manually pinned (always reachable)              │\n// └─────────────┴─────────────────────────────────────────────────┘\n// * flipped between cycles\n\n// @ts-ignore: decorator\n@lazy var white = 0;\n// @ts-ignore: decorator\n@inline const gray = 2;\n// @ts-ignore: decorator\n@inline const transparent = 3;\n// @ts-ignore: decorator\n@inline const COLOR_MASK = 3;\n\n/** Size in memory of all objects currently managed by the GC. */\n// @ts-ignore: decorator\n@lazy var total: usize = 0;\n\n/** Currently transitioning from SWEEP to MARK state. */\n// @ts-ignore: decorator\n@inline const STATE_IDLE = 0;\n/** Currently marking reachable objects. */\n// @ts-ignore: decorator\n@inline const STATE_MARK = 1;\n/** Currently sweeping unreachable objects. */\n// @ts-ignore: decorator\n@inline const STATE_SWEEP = 2;\n/** Current collector state. */\n// @ts-ignore: decorator\n@lazy var state = STATE_IDLE;\n\n// @ts-ignore: decorator\n@lazy var fromSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy var toSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy var pinSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy var iter: Object; // null\n\nfunction initLazy(space: Object): Object {\n  space.nextWithColor = changetype<usize>(space);\n  space.prev = space;\n  return space;\n}\n\n/** Visit cookie indicating scanning of an object. */\n// @ts-ignore: decorator\n@inline const VISIT_SCAN = 0;\n\n// ╒═══════════════ Managed object layout (32-bit) ════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\n// │                      Memory manager block                     │\n// ╞═══════════════════════════════════════════════════════════╤═══╡\n// │                              next                         │ C │ = nextWithColor\n// ├───────────────────────────────────────────────────────────┴───┤\n// │                              prev                             │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              rtId                             │\n// ├───────────────────────────────────────────────────────────────┤\n// │                              rtSize                           │\n// ╞>ptr═══════════════════════════════════════════════════════════╡\n// │                               ...                             │\n// C: color\n\n/** Represents a managed object in memory, consisting of a header followed by the object's data. */\n@unmanaged class Object extends BLOCK {\n  /** Pointer to the next object with color flags stored in the alignment bits. */\n  nextWithColor: usize; // *u32\n  /** Pointer to the previous object. */\n  prev: Object; // *u32\n  /** Runtime id. */\n  rtId: u32;\n  /** Runtime size. */\n  rtSize: u32;\n\n  /** Gets the pointer to the next object. */\n  get next(): Object {\n    return changetype<Object>(this.nextWithColor & ~COLOR_MASK);\n  }\n\n  /** Sets the pointer to the next object. */\n  set next(obj: Object) {\n    this.nextWithColor = changetype<usize>(obj) | (this.nextWithColor & COLOR_MASK);\n  }\n\n  /** Gets this object's color. */\n  get color(): i32 {\n    return i32(this.nextWithColor & COLOR_MASK);\n  }\n\n  /** Sets this object's color. */\n  set color(color: i32) {\n    this.nextWithColor = (this.nextWithColor & ~COLOR_MASK) | color;\n  }\n\n  /** Gets the size of this object in memory. */\n  get size(): usize {\n    return BLOCK_OVERHEAD + (this.mmInfo & ~3);\n  }\n\n  /** Tests if this object is pointerfree. */\n  get isPointerfree(): bool {\n    var rtId = this.rtId;\n    return rtId <= idof<string>() || (__typeinfo(rtId) & TypeinfoFlags.POINTERFREE) != 0;\n  }\n\n  /** Unlinks this object from its list. */\n  unlink(): void {\n    var next = this.next;\n    if (next == null) {\n      if (DEBUG) assert(this.prev == null && changetype<usize>(this) < __heap_base);\n      return; // static data not yet linked\n    }\n    var prev = this.prev;\n    if (DEBUG) assert(prev);\n    next.prev = prev;\n    prev.next = next;\n  }\n\n  /** Links this object to the specified list, with the given color. */\n  linkTo(list: Object, withColor: i32): void {\n    let prev = list.prev;\n    this.nextWithColor = changetype<usize>(list) | withColor;\n    this.prev = prev;\n    prev.next = this;\n    list.prev = this;\n  }\n\n  /** Marks this object as gray, that is reachable with unscanned children. */\n  makeGray(): void {\n    if (this == iter) iter = assert(this.prev);\n    this.unlink();\n    this.linkTo(toSpace, this.isPointerfree ? i32(!white) : gray);\n  }\n}\n\n/** Visits all objects considered to be program roots. */\nfunction visitRoots(cookie: u32): void {\n  __visit_globals(cookie);\n  var pn = pinSpace;\n  var iter = pn.next;\n  while (iter != pn) {\n    if (DEBUG) assert(iter.color == transparent);\n    __visit_members(changetype<usize>(iter) + TOTAL_OVERHEAD, cookie);\n    iter = iter.next;\n  }\n}\n\n/** Visits all objects on the stack. */\nfunction visitStack(cookie: u32): void {\n  var ptr = __stack_pointer;\n  while (ptr < __heap_base) {\n    __visit(load<usize>(ptr), cookie);\n    ptr += sizeof<usize>();\n  }\n}\n\n/** Performs a single step according to the current state. */\nfunction step(): usize {\n  // Magic constants responsible for pause times. Obtained experimentally\n  // using the compiler compiling itself. 2048 budget pro run by default.\n  const MARKCOST = isDefined(ASC_GC_MARKCOST) ? ASC_GC_MARKCOST : 1;\n  const SWEEPCOST = isDefined(ASC_GC_SWEEPCOST) ? ASC_GC_SWEEPCOST : 10;\n  var obj: Object;\n  switch (state) {\n    case STATE_IDLE: {\n      state = STATE_MARK;\n      visitCount = 0;\n      visitRoots(VISIT_SCAN);\n      iter = toSpace;\n      return visitCount * MARKCOST;\n    }\n    case STATE_MARK: {\n      let black = i32(!white);\n      obj = iter.next;\n      while (obj != toSpace) {\n        iter = obj;\n        if (obj.color != black) { // skip already-blacks (pointerfree)\n          obj.color = black;\n          visitCount = 0;\n          __visit_members(changetype<usize>(obj) + TOTAL_OVERHEAD, VISIT_SCAN);\n          return visitCount * MARKCOST;\n        }\n        obj = obj.next;\n      }\n      visitCount = 0;\n      visitRoots(VISIT_SCAN);\n      obj = iter.next;\n      if (obj == toSpace) {\n        visitStack(VISIT_SCAN);\n        obj = iter.next;\n        while (obj != toSpace) {\n          if (obj.color != black) {\n            obj.color = black;\n            __visit_members(changetype<usize>(obj) + TOTAL_OVERHEAD, VISIT_SCAN);\n          }\n          obj = obj.next;\n        }\n        let from = fromSpace;\n        fromSpace = toSpace;\n        toSpace = from;\n        white = black;\n        iter = from.next;\n        state = STATE_SWEEP;\n      }\n      return visitCount * MARKCOST;\n    }\n    case STATE_SWEEP: {\n      obj = iter;\n      if (obj != toSpace) {\n        iter = obj.next;\n        if (DEBUG) assert(obj.color == i32(!white)); // old white\n        free(obj);\n        return SWEEPCOST;\n      }\n      toSpace.nextWithColor = changetype<usize>(toSpace);\n      toSpace.prev = toSpace;\n      state = STATE_IDLE;\n      break;\n    }\n  }\n  return 0;\n}\n\n/** Frees an object. */\nfunction free(obj: Object): void {\n  if (changetype<usize>(obj) < __heap_base) {\n    obj.nextWithColor = 0; // may become linked again\n    obj.prev = changetype<Object>(0);\n  } else {\n    total -= obj.size;\n    if (isDefined(__finalize)) {\n      __finalize(changetype<usize>(obj) + TOTAL_OVERHEAD);\n    }\n    __free(changetype<usize>(obj) + BLOCK_OVERHEAD);\n  }\n}\n\n// Garbage collector interface\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __new(size: usize, id: i32): usize {\n  if (size >= OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  if (total >= threshold) interrupt();\n  var obj = changetype<Object>(__alloc(OBJECT_OVERHEAD + size) - BLOCK_OVERHEAD);\n  obj.rtId = id;\n  obj.rtSize = <u32>size;\n  obj.linkTo(fromSpace, white); // inits next/prev\n  total += obj.size;\n  var ptr = changetype<usize>(obj) + TOTAL_OVERHEAD;\n  // may be visited before being fully initialized, so must fill\n  memory.fill(ptr, 0, size);\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __renew(oldPtr: usize, size: usize): usize {\n  var oldObj = changetype<Object>(oldPtr - TOTAL_OVERHEAD);\n  // Update object size if its block is large enough\n  if (size <= (oldObj.mmInfo & ~3) - OBJECT_OVERHEAD) {\n    oldObj.rtSize = <u32>size;\n    return oldPtr;\n  }\n  // If not the same object anymore, we have to move it move it due to the\n  // shadow stack potentially still referencing the old object\n  var newPtr = __new(size, oldObj.rtId);\n  memory.copy(newPtr, oldPtr, min(size, oldObj.rtSize));\n  return newPtr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void {\n  // Write barrier is unnecessary if non-incremental\n  if (!childPtr) return;\n  if (DEBUG) assert(parentPtr);\n  var child = changetype<Object>(childPtr - TOTAL_OVERHEAD);\n  if (child.color == white) {\n    let parent = changetype<Object>(parentPtr - TOTAL_OVERHEAD);\n    let parentColor = parent.color;\n    if (parentColor == i32(!white)) {\n      // Maintain the invariant that no black object may point to a white object.\n      if (expectMultiple) {\n        // Move the barrier \"backward\". Suitable for containers receiving multiple stores.\n        // Avoids a barrier for subsequent objects stored into the same container.\n        parent.makeGray();\n      } else {\n        // Move the barrier \"forward\". Suitable for objects receiving isolated stores.\n        child.makeGray();\n      }\n    } else if (parentColor == transparent && state == STATE_MARK) {\n      // Pinned objects are considered 'black' during the mark phase.\n      child.makeGray();\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@lazy var visitCount = 0;\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __visit(ptr: usize, cookie: i32): void {\n  if (!ptr) return;\n  let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n  if (RTRACE) if (!onvisit(obj)) return;\n  if (obj.color == white) {\n    obj.makeGray();\n    ++visitCount;\n  }\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __pin(ptr: usize): usize {\n  if (ptr) {\n    let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n    if (obj.color == transparent) {\n      throw new Error(E_ALREADY_PINNED);\n    }\n    obj.unlink(); // from fromSpace\n    obj.linkTo(pinSpace, transparent);\n  }\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __unpin(ptr: usize): void {\n  if (!ptr) return;\n  var obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n  if (obj.color != transparent) {\n    throw new Error(E_NOT_PINNED);\n  }\n  if (state == STATE_MARK) {\n    // We may be right at the point after marking roots for the second time and\n    // entering the sweep phase, in which case the object would be missed if it\n    // is not only pinned but also a root. Make sure it isn't missed.\n    obj.makeGray();\n  } else {\n    obj.unlink();\n    obj.linkTo(fromSpace, white);\n  }\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __collect(): void {\n  if (TRACE) trace(\"GC (full) at\", 1, total);\n  if (state > STATE_IDLE) {\n    // finish current cycle\n    while (state != STATE_IDLE) step();\n  }\n  // perform a full cycle\n  step();\n  while (state != STATE_IDLE) step();\n  threshold = <usize>(<u64>total * IDLEFACTOR / 100) + GRANULARITY;\n  if (TRACE) trace(\"GC (full) done at cur/max\", 2, total, memory.size() << 16);\n  if (RTRACE || PROFILE) oncollect(total);\n}\n\n// Garbage collector automation\n\n/** How often to interrupt. The default of 1024 means \"interrupt each 1024 bytes allocated\". */\n// @ts-ignore: decorator\n@inline const GRANULARITY: usize = isDefined(ASC_GC_GRANULARITY) ? ASC_GC_GRANULARITY : 1024;\n/** How long to interrupt. The default of 200% means \"run at double the speed of allocations\". */\n// @ts-ignore: decorator\n@inline const STEPFACTOR: usize = isDefined(ASC_GC_SWEEPFACTOR) ? ASC_GC_SWEEPFACTOR : 200;\n/** How long to idle. The default of 200% means \"wait for memory to double before kicking in again\". */\n// @ts-ignore: decorator\n@inline const IDLEFACTOR: usize = isDefined(ASC_GC_IDLEFACTOR) ? ASC_GC_IDLEFACTOR : 200;\n\n/** Threshold of memory used by objects to exceed before interrupting again. */\n// @ts-ignore: decorator\n@lazy var threshold: usize = ((<usize>memory.size() << 16) - __heap_base) >> 1;\n\n/** Performs a reasonable amount of incremental GC steps. */\nfunction interrupt(): void {\n  if (PROFILE) oninterrupt(total);\n  if (TRACE) trace(\"GC (auto) at\", 1, total);\n  var budget: isize = GRANULARITY * STEPFACTOR / 100;\n  do {\n    budget -= step();\n    if (state == STATE_IDLE) {\n      if (TRACE) trace(\"└ GC (auto) done at cur/max\", 2, total, memory.size() << 16);\n      threshold = <usize>(<u64>total * IDLEFACTOR / 100) + GRANULARITY;\n      if (PROFILE) onyield(total);\n      return;\n    }\n  } while (budget > 0);\n  if (TRACE) trace(\"└ GC (auto) ongoing at\", 1, total);\n  threshold = total + GRANULARITY * usize(total - threshold < GRANULARITY);\n  if (PROFILE) onyield(total);\n}\n","import { Calculator } from \"../Calculator\";\nimport { calculator } from \"../proto/calculator\";\n\ndescribe(\"calculator\", () => {\n  it(\"should add\", () => {\n    const calc = new Calculator();\n\n    const args = new calculator.add_arguments(1, 923);\n    const res = calc.add(args);\n\n    console.log(\"add: \" + res.value.toString());\n\n    expect(res.value).toBe(924);\n  });\n\n  it(\"should sub\", () => {\n    const calc = new Calculator();\n\n    const args = new calculator.sub_arguments(9, 1);\n    const res = calc.sub(args);\n\n    console.log(\"sub: \" + res.value.toString());\n\n    expect(res.value).toBe(8);\n  });\n\n  it(\"should mul\", () => {\n    const calc = new Calculator();\n\n    const args = new calculator.mul_arguments(9, 9);\n    const res = calc.mul(args);\n\n    console.log(\"mul: \" + res.value.toString());\n\n    expect(res.value).toBe(81);\n  });\n\n  it(\"should div\", () => {\n    const calc = new Calculator();\n\n    const args = new calculator.div_arguments(999, 9);\n    const res = calc.div(args);\n\n    console.log(\"div: \" + res.value.toString());\n\n    expect(res.value).toBe(111);\n  });\n});\n","import { SafeMath } from \"@koinos/sdk-as\";\nimport { calculator } from \"./proto/calculator\";\n\nexport class Calculator {\n  add(args: calculator.add_arguments): calculator.add_result {\n    const x = args.x;\n    const y = args.y;\n\n    const res = new calculator.add_result();\n    res.value = SafeMath.add(x, y);\n\n    return res;\n  }\n\n  sub(args: calculator.sub_arguments): calculator.sub_result {\n    const x = args.x;\n    const y = args.y;\n\n    const res = new calculator.sub_result();\n    res.value = SafeMath.sub(x, y);\n\n    return res;\n  }\n\n  mul(args: calculator.mul_arguments): calculator.mul_result {\n    const x = args.x;\n    const y = args.y;\n\n    const res = new calculator.mul_result();\n    res.value = SafeMath.mul(x, y);\n\n    return res;\n  }\n\n  div(args: calculator.div_arguments): calculator.div_result {\n    const x = args.x;\n    const y = args.y;\n\n    const res = new calculator.div_result();\n    res.value = SafeMath.div(x, y);\n\n    return res;\n  }\n}\n","// Phase: wasi_snapshot_preview1\n// See: https://github.com/WebAssembly/WASI/tree/main/phases/snapshot/witx\n\n// helper types to be more explicit\ntype char = u8;\ntype ptr<T> = usize; // all pointers are usize'd\ntype struct<T> = T;  // structs are references already in AS\n\n/** Read command-line argument data. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function args_get(\n  /** Input: Pointer to a buffer to write the argument pointers. */\n  argv: ptr<ptr<char>>,\n  /** Input: Pointer to a buffer to write the argument string data. */\n  argv_buf: ptr<char>\n): errno;\n\n/** Return command-line argument data sizes. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function args_sizes_get(\n  /** Output: Number of arguments. */\n  argc: ptr<usize>,\n  /** Output: Size of the argument string data. */\n  argv_buf_size: ptr<usize>\n): errno;\n\n/** Return the resolution of a clock. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function clock_res_get(\n  /** Input: The clock for which to return the resolution. */\n  clock: clockid,\n  /** Output: The resolution of the clock. */\n  resolution: ptr<timestamp>\n): errno;\n\n/** Return the time value of a clock. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function clock_time_get(\n  /** Input: Cock for which to return the time. */\n  clock: clockid,\n  /** Input: Maximum lag (exclusive) that the returned time value may have, compared to its actual value. */\n  precision: timestamp,\n  /** Output: Time value of the clock. */\n  time: ptr<timestamp>\n): errno;\n\n/** Read environment variable data. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function environ_get(\n  /** Input: Pointer to a buffer to write the environment variable pointers. */\n  environ: ptr<usize>,\n  /** Input: Pointer to a buffer to write the environment variable string data. */\n  environ_buf: usize\n): errno;\n\n/** Return command-line argument data sizes. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function environ_sizes_get(\n  /** Output: The number of environment variables. */\n  environ_count: ptr<usize>,\n  /** Output: The size of the environment variable string data. */\n  environ_buf_size: ptr<usize>\n): errno;\n\n/** Provide file advisory information on a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_advise(\n  /** Input: The file descriptor for the file for which to provide file advisory information. */\n  fd: fd,\n  /** Input: The offset within the file to which the advisory applies. */\n  offset: filesize,\n  /** Input: The length of the region to which the advisory applies. */\n  len: filesize,\n  /** Input: The advice. */\n  advice: advice\n): errno;\n\n/** Provide file advisory information on a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_allocate(\n  /** Input: The file descriptor for the file in which to allocate space. */\n  fd: fd,\n  /** Input: The offset at which to start the allocation. */\n  offset: filesize,\n  /** Input: The length of the area that is allocated. */\n  len: filesize\n): errno;\n\n/** Close a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_close(\n  /** Input: The file descriptor to close. */\n  fd: fd\n): errno;\n\n/** Synchronize the data of a file to disk. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_datasync(\n  /** Input: The file descriptor of the file to synchronize to disk. */\n  fd: fd\n): errno;\n\n/** Get the attributes of a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_fdstat_get(\n  /** Input: The file descriptor to inspect. */\n  fd: fd,\n  /** Input: The buffer where the file descriptor's attributes are stored. */\n  buf: struct<fdstat>\n): errno;\n\n/** Adjust the flags associated with a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_fdstat_set_flags(\n  /** Input: The file descriptor to operate on. */\n  fd: fd,\n  /** Input: The desired values of the file descriptor flags. */\n  flags: fdflags\n): errno;\n\n/** Adjust the rights associated with a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_fdstat_set_rights(\n  /** Input: The file descriptor to operate on. */\n  fd: fd,\n  /** Input: The desired rights of the file descriptor. */\n  fs_rights_base: rights,\n  /** Input: The desired rights of the file descriptor. */\n  fs_rights_inheriting: rights\n): errno;\n\n/** Return the attributes of an open file. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_filestat_get(\n  /** Input: The file descriptor to inspect. */\n  fd: fd,\n  /** Input: The buffer where the file's attributes are stored. */\n  buf: struct<filestat>\n): errno;\n\n/** Adjust the size of an open file. If this increases the file's size, the extra bytes are filled with zeros. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_filestat_set_size(\n  /** Input: A file descriptor for the file to adjust. */\n  fd: fd,\n  /** Input: The desired file size. */\n  size: filesize\n): errno;\n\n/** Adjust the timestamps of an open file or directory. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_filestat_set_times(\n  /** Input: The file descriptor to operate on. */\n  fd: fd,\n  /** Input: The desired values of the data access timestamp. */\n  st_atim: timestamp,\n  /** Input: The desired values of the data modification timestamp. */\n  st_mtim: timestamp,\n  /** Input: A bitmask indicating which timestamps to adjust. */\n  fstflags: fstflags\n): errno;\n\n/** Read from a file descriptor, without using and updating the file descriptor's offset. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_pread(\n  /** Input: The file descriptor from which to read data. */\n  fd: fd,\n  /** Input: List of scatter/gather vectors in which to store data. */\n  iovs: ptr<struct<iovec>>,\n  /** Input: Length of the list of scatter/gather vectors in which to store data. */\n  iovs_len: usize,\n  /** Input: The offset within the file at which to read. */\n  offset: filesize,\n  /** Output: The number of bytes read. */\n  nread: ptr<usize>\n): errno;\n\n/** Return a description of the given preopened file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_prestat_get(\n  /** Input: The file descriptor about which to retrieve information. */\n  fd: fd,\n  /** Input: The buffer where the description is stored. */\n  buf: struct<prestat>\n): errno;\n\n/** Return a description of the given preopened file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_prestat_dir_name(\n  /** Input: The file descriptor about which to retrieve information. */\n  fd: fd,\n  /** Input: Buffer into which to write the preopened directory name. */\n  path: ptr<char>,\n  /** Input: Length of the buffer into which to write the preopened directory name. */\n  path_len: usize\n): errno;\n\n/** Write to a file descriptor, without using and updating the file descriptor's offset. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_pwrite(\n  /** Input: The file descriptor to which to write data. */\n  fd: fd,\n  /** Input: List of scatter/gather vectors from which to retrieve data. */\n  iovs: ptr<struct<iovec>>,\n  /** Input: Length of the list of scatter/gather vectors from which to retrieve data. */\n  iovs_len: usize,\n  /** Input: The offset within the file at which to write. */\n  offset: filesize,\n  /** Output: The number of bytes written. */\n  nwritten: ptr<usize>\n): errno;\n\n/** Read from a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_read(\n  /** Input: The file descriptor from which to read data. */\n  fd: fd,\n  /** Input: List of scatter/gather vectors to which to store data. */\n  iovs: ptr<struct<iovec>>,\n  /** Input: Length of the list of scatter/gather vectors to which to store data. */\n  iovs_len: usize,\n  /** Output: The number of bytes read. */\n  nread: ptr<usize>\n): errno;\n\n/** Read directory entries from a directory. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_readdir(\n  /** Input: Directory from which to read the directory entries. */\n  fd: fd,\n  /** Input: Buffer where directory entries are stored. */\n  buf: ptr<struct<dirent>>,\n  /** Input: Length of the buffer where directory entries are stored. */\n  buf_len: usize,\n  /** Input: Location within the directory to start reading. */\n  cookie: dircookie,\n  /** Output: Number of bytes stored in the read buffer. If less than the size of the read buffer, the end of the directory has been reached. */\n  buf_used: ptr<usize>\n): errno;\n\n/** Atomically replace a file descriptor by renumbering another file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_renumber(\n  /** Input: The file descriptor to renumber. */\n  from: fd,\n  /** Input: The file descriptor to overwrite. */\n  to: fd\n): errno;\n\n/** Move the offset of a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_seek(\n  /** Input: The file descriptor to operate on. */\n  fd: fd,\n  /** Input: The number of bytes to move. */\n  offset: filedelta,\n  /** Input: The base from which the offset is relative. */\n  whence: whence,\n  /** Output: The new offset of the file descriptor, relative to the start of the file. */\n  newoffset: ptr<filesize>\n): errno;\n\n/** Synchronize the data and metadata of a file to disk. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_sync(\n  /** Input: The file descriptor of the file containing the data and metadata to synchronize to disk. */\n  fd: fd\n): errno;\n\n/** Return the current offset of a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_tell(\n  /** Input: The file descriptor to inspect. */\n  fd: fd,\n  /** Output: The current offset of the file descriptor, relative to the start of the file. */\n  newoffset: ptr<filesize>\n): errno;\n\n/** Write to a file descriptor. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function fd_write(\n  /** Input: The file descriptor to which to write data. */\n  fd: fd,\n  /** Input: List of scatter/gather vectors from which to retrieve data. */\n  iovs: ptr<struct<iovec>>,\n  /** Input: List of scatter/gather vectors from which to retrieve data. */\n  iovs_len: usize,\n  /** Output: The number of bytes written. */\n  nwritten: ptr<usize>\n): errno;\n\n/* Create a directory. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_create_directory(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: The path at which to create the directory. */\n  path: ptr<char>,\n  /** Input: The path at which to create the directory. */\n  path_len: usize\n): errno;\n\n/** Return the attributes of a file or directory. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_filestat_get(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: Flags determining the method of how the path is resolved. */\n  flags: lookupflags,\n  /** Input: The path of the file or directory to inspect. */\n  path: ptr<char>,\n  /** Input: The path of the file or directory to inspect. */\n  path_len: usize,\n  /** Input: The buffer where the file's attributes are stored. */\n  buf: struct<filestat>\n): errno;\n\n/** Adjust the timestamps of a file or directory. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_filestat_set_times(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: Flags determining the method of how the path is resolved. */\n  flags: lookupflags,\n  /** Input: The path of the file or directory to operate on. */\n  path: ptr<char>,\n  /** Input: The path of the file or directory to operate on. */\n  path_len: usize,\n  /** Input: The desired values of the data access timestamp. */\n  st_atim: timestamp,\n  /** Input: The desired values of the data modification timestamp. */\n  st_mtim: timestamp,\n  /** Input: A bitmask indicating which timestamps to adjust. */\n  fstflags: fstflags\n): errno;\n\n/** Create a hard link. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_link(\n  /** Input: The working directory at which the resolution of the old path starts. */\n  old_fd: fd,\n  /** Input: Flags determining the method of how the path is resolved. */\n  old_flags: lookupflags,\n  /** Input: The source path from which to link. */\n  old_path: ptr<char>,\n  /** Input: The source path from which to link. */\n  old_path_len: usize,\n  /** Input: The working directory at which the resolution of the new path starts. */\n  new_fd: fd,\n  /** Input: The destination path at which to create the hard link. */\n  new_path: ptr<char>,\n  /** Input: The length of the destination path at which to create the hard link. */\n  new_path_len: usize\n): errno;\n\n/** Open a file or directory. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_open(\n  /** Input: The working directory at which the resolution of the path starts. */\n  dirfd: fd,\n  /** Input: Flags determining the method of how the path is resolved. */\n  dirflags: lookupflags,\n  /** Input: The path of the file or directory to open. */\n  path: ptr<char>,\n  /** Input: The length of the path of the file or directory to open. */\n  path_len: usize,\n  /** Input: The method by which to open the file. */\n  oflags: oflags,\n  /** Input: The initial base rights that apply to operations using the file descriptor itself. */\n  fs_rights_base: rights,\n  /** Input: The initial inheriting rights that apply to file descriptors derived from it. */\n  fs_rights_inheriting: rights,\n  /** Input: The initial flags of the file descriptor. */\n  fs_flags: fdflags,\n  /** Output: The file descriptor of the file that has been opened. */\n  fd: ptr<fd>\n): errno;\n\n/** Read the contents of a symbolic link. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_readlink(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: The path of the symbolic link from which to read. */\n  path: ptr<char>,\n  /** Input: The length of the path of the symbolic link from which to read. */\n  path_len: usize,\n  /** Input: The buffer to which to write the contents of the symbolic link. */\n  buf: ptr<char>,\n  /** Input: The length of the buffer to which to write the contents of the symbolic link. */\n  buf_len: usize,\n  /** Output: The number of bytes placed in the buffer. */\n  buf_used: ptr<usize>\n): errno;\n\n/** Remove a directory. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_remove_directory(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: The path to a directory to remove. */\n  path: ptr<char>,\n  /** Input: The length of the path to a directory to remove. */\n  path_len: usize\n): errno;\n\n/** Rename a file or directory. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_rename(\n  /** Input: The working directory at which the resolution of the old path starts. */\n  old_fd: fd,\n  /** Input: The source path of the file or directory to rename. */\n  old_path: ptr<char>,\n  /** Input: The length of the source path of the file or directory to rename. */\n  old_path_len: usize,\n  /** Input: The working directory at which the resolution of the new path starts. */\n  new_fd: fd,\n  /** Input: The destination path to which to rename the file or directory. */\n  new_path: ptr<char>,\n  /** Input: The length of the destination path to which to rename the file or directory. */\n  new_path_len: usize\n): errno;\n\n/** Create a symbolic link. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_symlink(\n  /** Input: The contents of the symbolic link. */\n  old_path: ptr<char>,\n  /** Input: The length of the contents of the symbolic link. */\n  old_path_len: usize,\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: The destination path at which to create the symbolic link. */\n  new_path: ptr<char>,\n  /** Input: The length of the destination path at which to create the symbolic link. */\n  new_path_len: usize\n): errno;\n\n/** Unlink a file. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function path_unlink_file(\n  /** Input: The working directory at which the resolution of the path starts. */\n  fd: fd,\n  /** Input: The path to a file to unlink. */\n  path: ptr<char>,\n  /** Input: The length of the path to a file to unlink. */\n  path_len: usize\n): errno;\n\n/** Concurrently poll for the occurrence of a set of events. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function poll_oneoff(\n  /** Input: The events to which to subscribe. */\n  in_: ptr<struct<subscription>>,\n  /** Input: The events that have occurred. */\n  out: ptr<struct<event>>,\n  /** Input: Both the number of subscriptions and events. */\n  nsubscriptions: usize,\n  /** Output: The number of events stored. */\n  nevents: ptr<usize>\n): errno;\n\n/** Terminate the process normally. An exit code of 0 indicates successful termination of the program. The meanings of other values is dependent on the environment. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function proc_exit(\n  /** Input: The exit code returned by the process. */\n  rval: u32\n): void;\n\n/** Send a signal to the process of the calling thread. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function proc_raise(\n  /** Input: The signal condition to trigger. */\n  sig: signal\n): errno;\n\n/** Write high-quality random data into a buffer. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function random_get(\n  /** Input: The buffer to fill with random data. */\n  buf: usize,\n  /** Input: The length of the buffer to fill with random data. */\n  buf_len: usize\n): errno;\n\n/** Temporarily yield execution of the calling thread. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function sched_yield(): errno;\n\n/** Receive a message from a socket. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function sock_recv(\n  /** Input: The socket on which to receive data. */\n  sock: fd,\n  /** Input: List of scatter/gather vectors to which to store data. */\n  ri_data: ptr<struct<iovec>>,\n  /** Input: The length of the list of scatter/gather vectors to which to store data. */\n  ri_data_len: usize,\n  /** Input: Message flags. */\n  ri_flags: riflags,\n  /** Output: Number of bytes stored in `ri_data`. */\n  ro_datalen: ptr<usize>,\n  /** Output: Message flags. */\n  ro_flags: ptr<roflags>\n): errno;\n\n/** Send a message on a socket. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function sock_send(\n  /** Input: The socket on which to send data. */\n  sock: fd,\n  /** Input: List of scatter/gather vectors to which to retrieve data */\n  si_data: ptr<struct<iovec>>,\n  /** Input: The length of the list of scatter/gather vectors to which to retrieve data */\n  si_data_len: usize,\n  /** Input: Message flags. */\n  si_flags: siflags,\n  /** Output: Number of bytes transmitted. */\n  so_datalen: ptr<usize>\n): errno;\n\n/** Shut down socket send and receive channels. */\n// @ts-ignore: decorator\n@unsafe\nexport declare function sock_shutdown(\n  /** Input: The socket on which to shutdown channels. */\n  sock: fd,\n  /** Input: Which channels on the socket to shut down. */\n  how: sdflags\n): errno;\n\n// === Types ======================================================================================\n\n/** File or memory access pattern advisory information. */\nexport namespace advice {\n  /** The application has no advice to give on its behavior with respect to the specified data. */\n  // @ts-ignore: decorator\n  @inline\n  export const NORMAL: advice = 0;\n  /** The application expects to access the specified data sequentially from lower offsets to higher offsets. */\n  // @ts-ignore: decorator\n  @inline\n  export const SEQUENTIAL : advice = 1;\n  /** The application expects to access the specified data in a random order. */\n  // @ts-ignore: decorator\n  @inline\n  export const RANDOM: advice = 2;\n  /** The application expects to access the specified data in the near future. */\n  // @ts-ignore: decorator\n  @inline\n  export const WILLNEED: advice = 3;\n  /** The application expects that it will not access the specified data in the near future. */\n  // @ts-ignore: decorator\n  @inline\n  export const DONTNEED: advice = 4;\n  /** The application expects to access the specified data once and then not reuse it thereafter. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOREUSE: advice = 5;\n}\nexport type advice = u8;\n\n/** Identifiers for clocks. */\nexport namespace clockid {\n  /** The clock measuring real time. Time value zero corresponds with 1970-01-01T00:00:00Z. */\n  // @ts-ignore: decorator\n  @inline\n  export const REALTIME: clockid = 0;\n  /** The store-wide monotonic clock. Absolute value has no meaning. */\n  // @ts-ignore: decorator\n  @inline\n  export const MONOTONIC: clockid = 1;\n  /** The CPU-time clock associated with the current process. */\n  // @ts-ignore: decorator\n  @inline\n  export const PROCESS_CPUTIME_ID: clockid = 2;\n  /** The CPU-time clock associated with the current thread. */\n  // @ts-ignore: decorator\n  @inline\n  export const THREAD_CPUTIME_ID: clockid = 3;\n}\nexport type clockid = u32;\n\n/** Identifier for a device containing a file system. Can be used in combination with `inode` to uniquely identify a file or directory in the filesystem. */\nexport type device = u64;\n\n/** A reference to the offset of a directory entry. The value 0 signifies the start of the directory. */\nexport type dircookie = u64;\n\n/** A directory entry. */\n@unmanaged export class dirent {\n  /** The offset of the next directory entry stored in this directory. */\n  next: dircookie;\n  /** The serial number of the file referred to by this directory entry. */\n  ino: inode;\n  /** The length of the name of the directory entry. */\n  namlen: u32;\n  /** The type of the file referred to by this directory entry. */\n  type: filetype;\n  private __padding0: u16;\n}\n\n/** Error codes returned by functions. */\nexport namespace errno {\n  /** No error occurred. System call completed successfully. */\n  // @ts-ignore: decorator\n  @inline\n  export const SUCCESS: errno = 0;\n  /** Argument list too long. */\n  // @ts-ignore: decorator\n  @inline\n  export const TOOBIG: errno = 1;\n  /** Permission denied. */\n  // @ts-ignore: decorator\n  @inline\n  export const ACCES: errno = 2;\n  /** Address in use. */\n  // @ts-ignore: decorator\n  @inline\n  export const ADDRINUSE: errno = 3;\n  /** Address not available. */\n  // @ts-ignore: decorator\n  @inline\n  export const ADDRNOTAVAIL: errno = 4;\n  /** Address family not supported. */\n  // @ts-ignore: decorator\n  @inline\n  export const AFNOSUPPORT: errno = 5;\n  /** Resource unavailable, or operation would block. */\n  // @ts-ignore: decorator\n  @inline\n  export const AGAIN: errno = 6;\n  /** Connection already in progress. */\n  // @ts-ignore: decorator\n  @inline\n  export const ALREADY: errno = 7;\n  /** Bad file descriptor. */\n  // @ts-ignore: decorator\n  @inline\n  export const BADF: errno = 8;\n  /** Bad message. */\n  // @ts-ignore: decorator\n  @inline\n  export const BADMSG: errno = 9;\n  /** Device or resource busy. */\n  // @ts-ignore: decorator\n  @inline\n  export const BUSY: errno = 10;\n  /** Operation canceled. */\n  // @ts-ignore: decorator\n  @inline\n  export const CANCELED: errno = 11;\n  /** No child processes. */\n  // @ts-ignore: decorator\n  @inline\n  export const CHILD: errno = 12;\n  /** Connection aborted. */\n  // @ts-ignore: decorator\n  @inline\n  export const CONNABORTED: errno = 13;\n  /** Connection refused. */\n  // @ts-ignore: decorator\n  @inline\n  export const CONNREFUSED: errno = 14;\n  /** Connection reset. */\n  // @ts-ignore: decorator\n  @inline\n  export const CONNRESET: errno = 15;\n  /** Resource deadlock would occur. */\n  // @ts-ignore: decorator\n  @inline\n  export const DEADLK: errno = 16;\n  /** Destination address required. */\n  // @ts-ignore: decorator\n  @inline\n  export const DESTADDRREQ: errno = 17;\n  /** Mathematics argument out of domain of function. */\n  // @ts-ignore: decorator\n  @inline\n  export const DOM: errno = 18;\n  /** Reserved. */\n  // @ts-ignore: decorator\n  @inline\n  export const DQUOT: errno = 19;\n  /** File exists. */\n  // @ts-ignore: decorator\n  @inline\n  export const EXIST: errno = 20;\n  /** Bad address. */\n  // @ts-ignore: decorator\n  @inline\n  export const FAULT: errno = 21;\n  /** File too large. */\n  // @ts-ignore: decorator\n  @inline\n  export const FBIG: errno = 22;\n  /** Host is unreachable. */\n  // @ts-ignore: decorator\n  @inline\n  export const HOSTUNREACH: errno = 23;\n  /** Identifier removed. */\n  // @ts-ignore: decorator\n  @inline\n  export const IDRM: errno = 24;\n  /** Illegal byte sequence. */\n  // @ts-ignore: decorator\n  @inline\n  export const ILSEQ: errno = 25;\n  /** Operation in progress. */\n  // @ts-ignore: decorator\n  @inline\n  export const INPROGRESS: errno = 26;\n  /** Interrupted function. */\n  // @ts-ignore: decorator\n  @inline\n  export const INTR: errno = 27;\n  /** Invalid argument. */\n  // @ts-ignore: decorator\n  @inline\n  export const INVAL: errno = 28;\n  /** I/O error. */\n  // @ts-ignore: decorator\n  @inline\n  export const IO: errno = 29;\n  /** Socket is connected. */\n  // @ts-ignore: decorator\n  @inline\n  export const ISCONN: errno = 30;\n  /** Is a directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const ISDIR: errno = 31;\n  /** Too many levels of symbolic links. */\n  // @ts-ignore: decorator\n  @inline\n  export const LOOP: errno = 32;\n  /** File descriptor value too large. */\n  // @ts-ignore: decorator\n  @inline\n  export const MFILE: errno = 33;\n  /** Too many links. */\n  // @ts-ignore: decorator\n  @inline\n  export const MLINK: errno = 34;\n  /** Message too large. */\n  // @ts-ignore: decorator\n  @inline\n  export const MSGSIZE: errno = 35;\n  /** Reserved. */\n  // @ts-ignore: decorator\n  @inline\n  export const MULTIHOP: errno = 36;\n  /** Filename too long. */\n  // @ts-ignore: decorator\n  @inline\n  export const NAMETOOLONG: errno = 37;\n  /** Network is down. */\n  // @ts-ignore: decorator\n  @inline\n  export const NETDOWN: errno = 38;\n  /** Connection aborted by network. */\n  // @ts-ignore: decorator\n  @inline\n  export const NETRESET: errno = 39;\n  /** Network unreachable. */\n  // @ts-ignore: decorator\n  @inline\n  export const NETUNREACH: errno = 40;\n  /** Too many files open in system. */\n  // @ts-ignore: decorator\n  @inline\n  export const NFILE: errno = 41;\n  /** No buffer space available. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOBUFS: errno = 42;\n  /** No such device. */\n  // @ts-ignore: decorator\n  @inline\n  export const NODEV: errno = 43;\n  /** No such file or directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOENT: errno = 44;\n  /** Executable file format error. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOEXEC: errno = 45;\n  /** No locks available. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOLCK: errno = 46;\n  /** Reserved. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOLINK: errno = 47;\n  /** Not enough space. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOMEM: errno = 48;\n  /** No message of the desired type. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOMSG: errno = 49;\n  /** Protocol not available. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOPROTOOPT: errno = 50;\n  /** No space left on device. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOSPC: errno = 51;\n  /** Function not supported. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOSYS: errno = 52;\n  /** The socket is not connected. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTCONN: errno = 53;\n  /** Not a directory or a symbolic link to a directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTDIR: errno = 54;\n  /** Directory not empty. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTEMPTY: errno = 55;\n  /** State not recoverable. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTRECOVERABLE: errno = 56;\n  /** Not a socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTSOCK: errno = 57;\n  /** Not supported, or operation not supported on socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTSUP: errno = 58;\n  /** Inappropriate I/O control operation. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTTY: errno = 59;\n  /** No such device or address. */\n  // @ts-ignore: decorator\n  @inline\n  export const NXIO: errno = 60;\n  /** Value too large to be stored in data type. */\n  // @ts-ignore: decorator\n  @inline\n  export const OVERFLOW: errno = 61;\n  /** Previous owner died. */\n  // @ts-ignore: decorator\n  @inline\n  export const OWNERDEAD: errno = 62;\n  /** Operation not permitted. */\n  // @ts-ignore: decorator\n  @inline\n  export const PERM: errno = 63;\n  /** Broken pipe. */\n  // @ts-ignore: decorator\n  @inline\n  export const PIPE: errno = 64;\n  /** Protocol error. */\n  // @ts-ignore: decorator\n  @inline\n  export const PROTO: errno = 65;\n  /** Protocol not supported. */\n  // @ts-ignore: decorator\n  @inline\n  export const PROTONOSUPPORT: errno = 66;\n  /** Protocol wrong type for socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const PROTOTYPE: errno = 67;\n  /** Result too large. */\n  // @ts-ignore: decorator\n  @inline\n  export const RANGE: errno = 68;\n  /** Read-only file system. */\n  // @ts-ignore: decorator\n  @inline\n  export const ROFS: errno = 69;\n  /** Invalid seek. */\n  // @ts-ignore: decorator\n  @inline\n  export const SPIPE: errno = 70;\n  /** No such process. */\n  // @ts-ignore: decorator\n  @inline\n  export const SRCH: errno = 71;\n  /** Reserved. */\n  // @ts-ignore: decorator\n  @inline\n  export const STALE: errno = 72;\n  /** Connection timed out. */\n  // @ts-ignore: decorator\n  @inline\n  export const TIMEDOUT: errno = 73;\n  /** Text file busy. */\n  // @ts-ignore: decorator\n  @inline\n  export const TXTBSY: errno = 74;\n  /** Cross-device link. */\n  // @ts-ignore: decorator\n  @inline\n  export const XDEV: errno = 75;\n  /** Extension: Capabilities insufficient. */\n  // @ts-ignore: decorator\n  @inline\n  export const NOTCAPABLE: errno = 76;\n}\nexport type errno = u16;\n\n/** Translates an error code to a string. */\nexport function errnoToString(err: errno): string {\n  switch (err) {\n    case errno.SUCCESS: return \"SUCCESS\";\n    case errno.TOOBIG: return \"TOOBIG\";\n    case errno.ACCES: return \"ACCES\";\n    case errno.ADDRINUSE: return \"ADDRINUSE\";\n    case errno.ADDRNOTAVAIL: return \"ADDRNOTAVAIL\";\n    case errno.AFNOSUPPORT: return \"AFNOSUPPORT\";\n    case errno.AGAIN: return \"AGAIN\";\n    case errno.ALREADY: return \"ALREADY\";\n    case errno.BADF: return \"BADF\";\n    case errno.BADMSG: return \"BADMSG\";\n    case errno.BUSY: return \"BUSY\";\n    case errno.CANCELED: return \"CANCELED\";\n    case errno.CHILD: return \"CHILD\";\n    case errno.CONNABORTED: return \"CONNABORTED\";\n    case errno.CONNREFUSED: return \"CONNREFUSED\";\n    case errno.CONNRESET: return \"CONNRESET\";\n    case errno.DEADLK: return \"DEADLK\";\n    case errno.DESTADDRREQ: return \"DESTADDRREQ\";\n    case errno.DOM: return \"DOM\";\n    case errno.DQUOT: return \"DQUOT\";\n    case errno.EXIST: return \"EXIST\";\n    case errno.FAULT: return \"FAULT\";\n    case errno.FBIG: return \"FBIG\";\n    case errno.HOSTUNREACH: return \"HOSTUNREACH\";\n    case errno.IDRM: return \"IDRM\";\n    case errno.ILSEQ: return \"ILSEQ\";\n    case errno.INPROGRESS: return \"INPROGRESS\";\n    case errno.INTR: return \"INTR\";\n    case errno.INVAL: return \"INVAL\";\n    case errno.IO: return \"IO\";\n    case errno.ISCONN: return \"ISCONN\";\n    case errno.ISDIR: return \"ISDIR\";\n    case errno.LOOP: return \"LOOP\";\n    case errno.MFILE: return \"MFILE\";\n    case errno.MLINK: return \"MLINK\";\n    case errno.MSGSIZE: return \"MSGSIZE\";\n    case errno.MULTIHOP: return \"MULTIHOP\";\n    case errno.NAMETOOLONG: return \"NAMETOOLONG\";\n    case errno.NETDOWN: return \"NETDOWN\";\n    case errno.NETRESET: return \"NETRESET\";\n    case errno.NETUNREACH: return \"NETUNREACH\";\n    case errno.NFILE: return \"NFILE\";\n    case errno.NOBUFS: return \"NOBUFS\";\n    case errno.NODEV: return \"NODEV\";\n    case errno.NOENT: return \"NOENT\";\n    case errno.NOEXEC: return \"NOEXEC\";\n    case errno.NOLCK: return \"NOLCK\";\n    case errno.NOLINK: return \"NOLINK\";\n    case errno.NOMEM: return \"NOMEM\";\n    case errno.NOMSG: return \"NOMSG\";\n    case errno.NOPROTOOPT: return \"NOPROTOOPT\";\n    case errno.NOSPC: return \"NOSPC\";\n    case errno.NOSYS: return \"NOSYS\";\n    case errno.NOTCONN: return \"NOTCONN\";\n    case errno.NOTDIR: return \"NOTDIR\";\n    case errno.NOTEMPTY: return \"NOTEMPTY\";\n    case errno.NOTRECOVERABLE: return \"NOTRECOVERABLE\";\n    case errno.NOTSOCK: return \"NOTSOCK\";\n    case errno.NOTSUP: return \"NOTSUP\";\n    case errno.NOTTY: return \"NOTTY\";\n    case errno.NXIO: return \"NXIO\";\n    case errno.OVERFLOW: return \"OVERFLOW\";\n    case errno.OWNERDEAD: return \"OWNERDEAD\";\n    case errno.PERM: return \"PERM\";\n    case errno.PIPE: return \"PIPE\";\n    case errno.PROTO: return \"PROTO\";\n    case errno.PROTONOSUPPORT: return \"PROTONOSUPPORT\";\n    case errno.PROTOTYPE: return \"PROTOTYPE\";\n    case errno.RANGE: return \"RANGE\";\n    case errno.ROFS: return \"ROFS\";\n    case errno.SPIPE: return \"SPIPE\";\n    case errno.SRCH: return \"SRCH\";\n    case errno.STALE: return \"STALE\";\n    case errno.TIMEDOUT: return \"TIMEDOUT\";\n    case errno.TXTBSY: return \"TXTBSY\";\n    case errno.XDEV: return \"XDEV\";\n    case errno.NOTCAPABLE: return \"NOTCAPABLE\";\n  }\n  return \"UNKNOWN\";\n}\n\n@unmanaged abstract class $event { // size=16/32\n  /** User-provided value that got attached to `subscription#userdata`. */\n  userdata: userdata;\n  /** If non-zero, an error that occurred while processing the subscription request. */\n  error: errno;\n  /** The type of the event that occurred. */\n  type: eventtype;\n\n  private __padding0: u16;\n}\n\n/** An event that occurred. */\n@unmanaged export abstract class event extends $event {\n  private __padding1: u64;\n  private __padding2: u64;\n}\n\n/** An event that occurred when type is `eventtype.FD_READ` or `eventtype.FD_WRITE`. */\n@unmanaged export class event_fd_readwrite extends $event {\n  /* The number of bytes available for reading or writing. */\n  nbytes: filesize;\n  /* The state of the file descriptor. */\n  flags: eventrwflags;\n\n  private __padding1: u32;\n}\n\n/** The state of the file descriptor subscribed to with `eventtype.FD_READ` or `eventtype.FD_WRITE`. */\nexport namespace eventrwflags {\n  /** The peer of this socket has closed or disconnected. */\n  // @ts-ignore: decorator\n  @inline\n  export const HANGUP: eventrwflags = 1;\n}\nexport type eventrwflags = u16;\n\n/** Type of a subscription to an event or its occurrence. */\nexport namespace eventtype {\n  /** The time value of clock has reached the timestamp. */\n  // @ts-ignore: decorator\n  @inline\n  export const CLOCK: eventtype = 0;\n  /** File descriptor has data available for reading. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_READ: eventtype = 1;\n  /** File descriptor has capacity available for writing */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_WRITE: eventtype = 2;\n}\nexport type eventtype = u8;\n\n/** Exit code generated by a process when exiting. */\nexport type exitcode = u32;\n\n/** A file descriptor number. */\nexport type fd = u32;\n\n/** File descriptor flags. */\nexport namespace fdflags {\n  /** Append mode: Data written to the file is always appended to the file's end. */\n  // @ts-ignore: decorator\n  @inline\n  export const APPEND: fdflags = 1;\n  /** Write according to synchronized I/O data integrity completion. Only the data stored in the file is synchronized. */\n  // @ts-ignore: decorator\n  @inline\n  export const DSYNC: fdflags = 2;\n  /** Non-blocking mode. */\n  // @ts-ignore: decorator\n  @inline\n  export const NONBLOCK: fdflags = 4;\n  /** Synchronized read I/O operations. */\n  // @ts-ignore: decorator\n  @inline\n  export const RSYNC: fdflags = 8;\n  /** Write according to synchronized I/O file integrity completion. */\n  // @ts-ignore: decorator\n  @inline\n  export const SYNC: fdflags = 16;\n}\nexport type fdflags = u16;\n\n/** File descriptor attributes. */\n@unmanaged export class fdstat {\n  /** File type. */\n  filetype: filetype;\n  /** File descriptor flags. */\n  flags: fdflags;\n  /** Rights that apply to this file descriptor. */\n  rights_base: rights;\n  /** Maximum set of rights that may be installed on new file descriptors that are created through this file descriptor, e.g., through `path_open`. */\n  rights_inheriting: rights;\n}\n\n/** Relative offset within a file. */\nexport type filedelta = i64;\n\n/** Non-negative file size or length of a region within a file. */\nexport type filesize = u64;\n\n/** File attributes. */\n@unmanaged export class filestat {\n  /** Device ID of device containing the file. */\n  dev: device;\n  /** File serial number. */\n  ino: inode;\n  /** File type. */\n  filetype: filetype;\n  /** Number of hard links to the file. */\n  nlink: linkcount;\n  /** For regular files, the file size in bytes. For symbolic links, the length in bytes of the pathname contained in the symbolic link. */\n  size: filesize;\n  /** Last data access timestamp. */\n  atim: timestamp;\n  /** Last data modification timestamp. */\n  mtim: timestamp;\n  /** Last file status change timestamp. */\n  ctim: timestamp;\n}\n\n/** The type of a file descriptor or file. */\nexport namespace filetype {\n  /** The type of the file descriptor or file is unknown or is different from any of the other types specified. */\n  // @ts-ignore: decorator\n  @inline\n  export const UNKNOWN: filetype = 0;\n  /** The file descriptor or file refers to a block device inode. */\n  // @ts-ignore: decorator\n  @inline\n  export const BLOCK_DEVICE: filetype = 1;\n  /** The file descriptor or file refers to a character device inode. */\n  // @ts-ignore: decorator\n  @inline\n  export const CHARACTER_DEVICE: filetype = 2;\n  /** The file descriptor or file refers to a directory inode. */\n  // @ts-ignore: decorator\n  @inline\n  export const DIRECTORY: filetype = 3;\n  /** The file descriptor or file refers to a regular file inode. */\n  // @ts-ignore: decorator\n  @inline\n  export const REGULAR_FILE: filetype = 4;\n  /** The file descriptor or file refers to a datagram socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const SOCKET_DGRAM: filetype = 5;\n  /** The file descriptor or file refers to a byte-stream socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const SOCKET_STREAM: filetype = 6;\n  /** The file refers to a symbolic link inode. */\n  // @ts-ignore: decorator\n  @inline\n  export const SYMBOLIC_LINK: filetype = 7;\n}\nexport type filetype = u8;\n\n/** Which file time attributes to adjust. */\nexport namespace fstflags {\n  /** Adjust the last data access timestamp to the value stored in `filestat#st_atim`. */\n  // @ts-ignore: decorator\n  @inline\n  export const SET_ATIM: fstflags = 1;\n  /** Adjust the last data access timestamp to the time of clock `clockid.REALTIME`. */\n  // @ts-ignore: decorator\n  @inline\n  export const SET_ATIM_NOW: fstflags = 2;\n  /** Adjust the last data modification timestamp to the value stored in `filestat#st_mtim`. */\n  // @ts-ignore: decorator\n  @inline\n  export const SET_MTIM: fstflags = 4;\n  /** Adjust the last data modification timestamp to the time of clock `clockid.REALTIME`. */\n  // @ts-ignore: decorator\n  @inline\n  export const SET_MTIM_NOW: fstflags = 8;\n}\nexport type fstflags = u16;\n\n/** File serial number that is unique within its file system. */\nexport type inode = u64;\n\n/** A region of memory for scatter/gather reads. */\n@unmanaged export class iovec {\n  /** The address of the buffer to be filled. */\n  buf: usize;\n  /** The length of the buffer to be filled. */\n  buf_len: usize;\n}\n\n/** Number of hard links to an inode. */\nexport type linkcount = u64;\n\n/** Flags determining the method of how paths are resolved. */\nexport namespace lookupflags {\n  /** As long as the resolved path corresponds to a symbolic link, it is expanded. */\n  // @ts-ignore: decorator\n  @inline\n  export const SYMLINK_FOLLOW: lookupflags = 1;\n}\nexport type lookupflags = u32;\n\n/** Open flags. */\nexport namespace oflags {\n  /** Create file if it does not exist. */\n  // @ts-ignore: decorator\n  @inline\n  export const CREAT: oflags = 1;\n  /** Fail if not a directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const DIRECTORY: oflags = 2;\n  /** Fail if file already exists. */\n  // @ts-ignore: decorator\n  @inline\n  export const EXCL: oflags = 4;\n  /** Truncate file to size 0. */\n  // @ts-ignore: decorator\n  @inline\n  export const TRUNC: oflags = 8;\n}\nexport type oflags = u16;\n\n/** Identifiers for preopened capabilities. */\nexport namespace preopentype {\n  /** A pre-opened directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const DIR: preopentype = 0;\n}\nexport type preopentype = u8;\n\n@unmanaged abstract class $prestat { // WASM32: size=1/8, WASM64: size=1/16\n  /* The type of the pre-opened capability. */\n  type: preopentype;\n}\n\n/* Information about a pre-opened capability. */\n@unmanaged export abstract class prestat extends $prestat {\n  private __padding0: usize;\n}\n\n/** The contents of a $prestat when type is `preopentype.DIR`. */\n@unmanaged export class prestat_dir extends $prestat {\n  /** The length of the directory name for use with `fd_prestat_dir_name`. */\n  name_len: usize;\n}\n\n/** Flags provided to `sock_recv`. */\nexport namespace riflags {\n  /** Returns the message without removing it from the socket's receive queue. */\n  // @ts-ignore: decorator\n  @inline\n  export const PEEK: riflags = 1;\n  /** On byte-stream sockets, block until the full amount of data can be returned. */\n  // @ts-ignore: decorator\n  @inline\n  export const WAITALL: riflags = 2;\n}\nexport type riflags = u16;\n\n/** File descriptor rights, determining which actions may be performed. */\nexport namespace rights {\n  /** The right to invoke `fd_datasync`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_DATASYNC: rights = 1;\n  /** The right to invoke `fd_read` and `sock_recv`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_READ: rights = 2;\n  /** The right to invoke `fd_seek`. This flag implies `rights.FD_TELL`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_SEEK: rights = 4;\n  /** The right to invoke `fd_fdstat_set_flags`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_FDSTAT_SET_FLAGS: rights = 8;\n  /** The right to invoke `fd_sync`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_SYNC: rights = 16;\n  /** The right to invoke `fd_seek` in such a way that the file offset remains unaltered (i.e., `whence.CUR` with offset zero), or to invoke `fd_tell`). */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_TELL: rights = 32;\n  /** The right to invoke `fd_write` and `sock_send`. If `rights.FD_SEEK` is set, includes the right to invoke `fd_pwrite`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_WRITE: rights = 64;\n  /** The right to invoke `fd_advise`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_ADVISE: rights = 128;\n  /** The right to invoke `fd_allocate`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_ALLOCATE: rights = 256;\n  /** The right to invoke `path_create_directory`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_CREATE_DIRECTORY: rights = 512;\n  /** If `rights.PATH_OPEN` is set, the right to invoke `path_open` with `oflags.CREAT`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_CREATE_FILE: rights = 1024;\n  /** The right to invoke `path_link` with the file descriptor as the source directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_LINK_SOURCE: rights = 2048;\n  /** The right to invoke `path_link` with the file descriptor as the target directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_LINK_TARGET: rights = 4096;\n  /** The right to invoke `path_open`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_OPEN: rights = 8192;\n  /** The right to invoke `fd_readdir`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_READDIR: rights = 16384;\n  /** The right to invoke `path_readlink`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_READLINK: rights = 32768;\n  /** The right to invoke `path_rename` with the file descriptor as the source directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_RENAME_SOURCE: rights = 65536;\n  /** The right to invoke `path_rename` with the file descriptor as the target directory. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_RENAME_TARGET: rights = 131072;\n  /** The right to invoke `path_filestat_get`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_FILESTAT_GET: rights = 262144;\n  /** The right to change a file's size (there is no `path_filestat_set_size`). If `rights.PATH_OPEN` is set, includes the right to invoke `path_open` with `oflags.TRUNC`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_FILESTAT_SET_SIZE: rights = 524288;\n  /** The right to invoke `path_filestat_set_times`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_FILESTAT_SET_TIMES: rights = 1048576;\n  /** The right to invoke `fd_filestat_get`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_FILESTAT_GET: rights = 2097152;\n  /** The right to invoke `fd_filestat_set_size`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_FILESTAT_SET_SIZE: rights = 4194304;\n  /** The right to invoke `fd_filestat_set_times`. */\n  // @ts-ignore: decorator\n  @inline\n  export const FD_FILESTAT_SET_TIMES: rights = 8388608;\n  /** The right to invoke `path_symlink`. */\n  // @ts-ignore: decorator\n  @inline\n  export const RIGHT_PATH_SYMLINK: rights = 16777216;\n  /** The right to invoke `path_remove_directory`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_REMOVE_DIRECTORY: rights = 33554432;\n  /** The right to invoke `path_unlink_file`. */\n  // @ts-ignore: decorator\n  @inline\n  export const PATH_UNLINK_FILE: rights = 67108864;\n  /** If `rights.FD_READ` is set, includes the right to invoke `poll_oneoff` to subscribe to `eventtype.FD_READ`. If `rights.FD_WRITE` is set, includes the right to invoke `poll_oneoff` to subscribe to `eventtype.FD_WRITE`. */\n  // @ts-ignore: decorator\n  @inline\n  export const POLL_FD_READWRITE: rights = 134217728;\n  /** The right to invoke `sock_shutdown`. */\n  // @ts-ignore: decorator\n  @inline\n  export const SOCK_SHUTDOWN: rights = 268435456;\n}\nexport type rights = u64;\n\n/** Flags returned by `sock_recv`. */\nexport namespace roflags {\n  /** Message data has been truncated. */\n  // @ts-ignore: decorator\n  @inline\n  export const DATA_TRUNCATED: roflags = 1;\n}\nexport type roflags = u16;\n\n/** Which channels on a socket to shut down. */\nexport namespace sdflags {\n  /** Disables further receive operations. */\n  // @ts-ignore: decorator\n  @inline\n  export const RD: sdflags = 1;\n  /** Disables further send operations. */\n  // @ts-ignore: decorator\n  @inline\n  export const WR: sdflags = 2;\n}\nexport type sdflags = u8;\n\n/** Flags provided to `sock_send`. */\nexport namespace siflags {\n  // As there are currently no flags defined, it must be set to zero.\n}\nexport type siflags = u16;\n\n/** Signal condition. */\nexport namespace signal {\n  /** Hangup. */\n  // @ts-ignore: decorator\n  @inline\n  export const HUP: signal = 1;\n  /** Terminate interrupt signal. */\n  // @ts-ignore: decorator\n  @inline\n  export const INT: signal = 2;\n  /** Terminal quit signal. */\n  // @ts-ignore: decorator\n  @inline\n  export const QUIT: signal = 3;\n  /** Illegal instruction. */\n  // @ts-ignore: decorator\n  @inline\n  export const ILL: signal = 4;\n  /** Trace/breakpoint trap. */\n  // @ts-ignore: decorator\n  @inline\n  export const TRAP: signal = 5;\n  /** Process abort signal. */\n  // @ts-ignore: decorator\n  @inline\n  export const ABRT: signal = 6;\n  /** Access to an undefined portion of a memory object. */\n  // @ts-ignore: decorator\n  @inline\n  export const BUS: signal = 7;\n  /** Erroneous arithmetic operation. */\n  // @ts-ignore: decorator\n  @inline\n  export const FPE: signal = 8;\n  /** Kill. */\n  // @ts-ignore: decorator\n  @inline\n  export const KILL: signal = 9;\n  /** User-defined signal 1. */\n  // @ts-ignore: decorator\n  @inline\n  export const USR1: signal = 10;\n  /** Invalid memory reference. */\n  // @ts-ignore: decorator\n  @inline\n  export const SEGV: signal = 11;\n  /** User-defined signal 2. */\n  // @ts-ignore: decorator\n  @inline\n  export const USR2: signal = 12;\n  /** Write on a pipe with no one to read it. */\n  // @ts-ignore: decorator\n  @inline\n  export const PIPE: signal = 13;\n  /** Alarm clock. */\n  // @ts-ignore: decorator\n  @inline\n  export const ALRM: signal = 14;\n  /** Termination signal. */\n  // @ts-ignore: decorator\n  @inline\n  export const TERM: signal = 15;\n  /** Child process terminated, stopped, or continued. */\n  // @ts-ignore: decorator\n  @inline\n  export const CHLD: signal = 16;\n  /** Continue executing, if stopped. */\n  // @ts-ignore: decorator\n  @inline\n  export const CONT: signal = 17;\n  /** Stop executing. */\n  // @ts-ignore: decorator\n  @inline\n  export const STOP: signal = 18;\n  /** Terminal stop signal. */\n  // @ts-ignore: decorator\n  @inline\n  export const TSTP: signal = 19;\n  /** Background process attempting read. */\n  // @ts-ignore: decorator\n  @inline\n  export const TTIN: signal = 20;\n  /** Background process attempting write. */\n  // @ts-ignore: decorator\n  @inline\n  export const TTOU: signal = 21;\n  /** High bandwidth data is available at a socket. */\n  // @ts-ignore: decorator\n  @inline\n  export const URG: signal = 22;\n  /** CPU time limit exceeded. */\n  // @ts-ignore: decorator\n  @inline\n  export const XCPU: signal = 23;\n  /** File size limit exceeded. */\n  // @ts-ignore: decorator\n  @inline\n  export const XFSZ: signal = 24;\n  /** Virtual timer expired. */\n  // @ts-ignore: decorator\n  @inline\n  export const VTALRM: signal = 25;\n  // @ts-ignore: decorator\n  @inline\n  export const PROF: signal = 26;\n  // @ts-ignore: decorator\n  @inline\n  export const WINCH: signal = 27;\n  // @ts-ignore: decorator\n  @inline\n  export const POLL: signal = 28;\n  // @ts-ignore: decorator\n  @inline\n  export const PWR: signal = 29;\n  /** Bad system call. */\n  // @ts-ignore: decorator\n  @inline\n  export const SYS: signal = 30;\n}\nexport type signal = u8;\n\n/** Flags determining how to interpret the timestamp provided in `subscription_t::u.clock.timeout. */\nexport namespace subclockflags {\n  /** If set, treat the timestamp provided in `clocksubscription` as an absolute timestamp. */\n  // @ts-ignore: decorator\n  @inline\n  export const ABSTIME: subclockflags = 1;\n}\nexport type subclockflags = u16;\n\n@unmanaged abstract class $subscription { // size=16/48\n  /** User-provided value that is attached to the subscription. */\n  userdata: userdata;\n  /** The type of the event to which to subscribe. */\n  type: eventtype;\n\n  private __padding0: u32;\n}\n\n/** Subscription to an event. */\n@unmanaged export abstract class subscription extends $subscription {\n  private __padding1: u64;\n  private __padding2: u64;\n  private __padding3: u64;\n  private __padding4: u64;\n}\n\n/* Subscription to an event of type `eventtype.CLOCK`.**/\n@unmanaged export class subscription_clock extends $subscription {\n  /** The clock against which to compare the timestamp. */\n  clock_id: clockid;\n  /** The absolute or relative timestamp. */\n  timeout: timestamp;\n  /** The amount of time that the implementation may wait additionally to coalesce with other events. */\n  precision: timestamp;\n  /** Flags specifying whether the timeout is absolute or relative. */\n  flags: subclockflags;\n\n  private __padding1: u32;\n}\n\n/* Subscription to an event of type `eventtype.FD_READ` or `eventtype.FD_WRITE`.**/\n@unmanaged export class subscription_fd_readwrite extends $subscription {\n  /** The file descriptor on which to wait for it to become ready for reading or writing. */\n  file_descriptor: fd;\n\n  private __padding1: u64;\n  private __padding2: u64;\n  private __padding3: u64;\n}\n\n/** Timestamp in nanoseconds. */\nexport type timestamp = u64;\n\n/** User-provided value that may be attached to objects that is retained when extracted from the implementation. */\nexport type userdata = u64;\n\n/** The position relative to which to set the offset of the file descriptor. */\nexport namespace whence {\n  /** Seek relative to start-of-file. */\n  // @ts-ignore: decorator\n  @inline\n  export const SET: whence = 0;\n  /** Seek relative to current position. */\n  // @ts-ignore: decorator\n  @inline\n  export const CUR: whence = 1;\n  /** Seek relative to end-of-file. */\n  // @ts-ignore: decorator\n  @inline\n  export const END: whence = 2;\n}\n\nexport type whence = u8;\n","//\n// Lookup data for exp2f\n//\n\n// @ts-ignore: decorator\n@inline const EXP2F_TABLE_BITS = 5;\n\n// @ts-ignore: decorator\n@lazy @inline const EXP2F_DATA_TAB = memory.data<u64>([\n  // exp2f_data_tab[i] = uint(2^(i/N)) - (i << 52-BITS)\n  // used for computing 2^(k/N) for an int |k| < 150 N as\n  // double(tab[k%N] + (k << 52-BITS))\n  0x3FF0000000000000, 0x3FEFD9B0D3158574, 0x3FEFB5586CF9890F, 0x3FEF9301D0125B51,\n  0x3FEF72B83C7D517B, 0x3FEF54873168B9AA, 0x3FEF387A6E756238, 0x3FEF1E9DF51FDEE1,\n  0x3FEF06FE0A31B715, 0x3FEEF1A7373AA9CB, 0x3FEEDEA64C123422, 0x3FEECE086061892D,\n  0x3FEEBFDAD5362A27, 0x3FEEB42B569D4F82, 0x3FEEAB07DD485429, 0x3FEEA47EB03A5585,\n  0x3FEEA09E667F3BCD, 0x3FEE9F75E8EC5F74, 0x3FEEA11473EB0187, 0x3FEEA589994CCE13,\n  0x3FEEACE5422AA0DB, 0x3FEEB737B0CDC5E5, 0x3FEEC49182A3F090, 0x3FEED503B23E255D,\n  0x3FEEE89F995AD3AD, 0x3FEEFF76F2FB5E47, 0x3FEF199BDD85529C, 0x3FEF3720DCEF9069,\n  0x3FEF5818DCFBA487, 0x3FEF7C97337B9B5F, 0x3FEFA4AFA2A490DA, 0x3FEFD0765B6E4540\n]);\n\n// ULP error: 0.502 (nearest rounding.)\n// Relative error: 1.69 * 2^-34 in [-1/64, 1/64] (before rounding.)\n// Wrong count: 168353 (all nearest rounding wrong results with fma.)\n// @ts-ignore: decorator\n@inline\nexport function exp2f_lut(x: f32): f32 {\n  const\n    N      = 1 << EXP2F_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N, // 0x1.8p+52\n    Ox127f = reinterpret<f32>(0x7F000000);\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\n\n  var xd = <f64>x;\n  var ix = reinterpret<u32>(x);\n  var ux = ix >> 20 & 0x7FF;\n  if (ux >= 0x430) {\n    // |x| >= 128 or x is nan.\n    if (ix == 0xFF800000) return 0; // x == -Inf    -> 0\n    if (ux >= 0x7F8) return x + x;  // x == Inf/NaN -> Inf/NaN\n    if (x > 0) return x * Ox127f;   // x >     0    -> HugeVal (Owerflow)\n    if (x <= -150) return 0;        // x <= -150    -> 0 (Underflow)\n  }\n\n  // x = k/N + r with r in [-1/(2N), 1/(2N)] and int k.\n  var kd = xd + shift;\n  var ki = reinterpret<u64>(kd);\n  var r  = xd - (kd - shift);\n  var t: u64, y: f64, s: f64;\n\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += ki << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  y  = C2 * r + 1;\n  y += (C0 * r + C1) * (r  * r);\n  y *= s;\n\n  return <f32>y;\n}\n\n// ULP error: 0.502 (nearest rounding.)\n// Relative error: 1.69 * 2^-34 in [-ln2/64, ln2/64] (before rounding.)\n// Wrong count: 170635 (all nearest rounding wrong results with fma.)\n// @ts-ignore: decorator\n@inline\nexport function expf_lut(x: f32): f32 {\n  const\n    N        = 1 << EXP2F_TABLE_BITS,\n    N_MASK   = N - 1,\n    shift    = reinterpret<f64>(0x4338000000000000),        // 0x1.8p+52\n    InvLn2N  = reinterpret<f64>(0x3FF71547652B82FE) * N,    // 0x1.71547652b82fep+0\n    Ox1p127f = reinterpret<f32>(0x7F000000);\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394) / N / N / N, // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3) / N / N,     // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6) / N;         // 0x1.62e42ff0c52d6p-1\n\n  var xd = <f64>x;\n  var ix = reinterpret<u32>(x);\n  var ux = ix >> 20 & 0x7FF;\n  if (ux >= 0x42B) {\n    // |x| >= 88 or x is nan.\n    if (ix == 0xFF800000) return 0;                            // x == -Inf    -> 0\n    if (ux >= 0x7F8) return x + x;                             // x == Inf/NaN -> Inf/NaN\n    if (x > reinterpret<f32>(0x42B17217)) return x * Ox1p127f; // x > log(0x1p128)  ~=  88.72 -> HugeVal (Owerflow)\n    if (x < reinterpret<f32>(0xC2CFF1B4)) return 0;            // x < log(0x1p-150) ~= -103.97 -> 0 (Underflow)\n  }\n\n  // x*N/Ln2 = k + r with r in [-1/2, 1/2] and int k.\n  var z = InvLn2N * xd;\n\n  // Round and convert z to int, the result is in [-150*N, 128*N] and\n  // ideally ties-to-even rule is used, otherwise the magnitude of r\n  // can be bigger which gives larger approximation error.\n  var kd = <f64>(z + shift);\n  var ki = reinterpret<u64>(kd);\n  var r  = z - (kd - shift);\n  var s: f64, y: f64, t: u64;\n\n  // exp(x) = 2^(k/N) * 2^(r/N) ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += ki << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  z  = C0 * r + C1;\n  y  = C2 * r + 1;\n  y += z * (r * r);\n  y *= s;\n\n  return <f32>y;\n}\n\n//\n// Lookup data for log2f\n//\n\n// @ts-ignore: decorator\n@inline const LOG2F_TABLE_BITS = 4;\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2F_DATA_TAB = memory.data<f64>([\n  reinterpret<f64>(0x3FF661EC79F8F3BE), reinterpret<f64>(0xBFDEFEC65B963019), // 0x1.661ec79f8f3bep+0, -0x1.efec65b963019p-2,\n  reinterpret<f64>(0x3FF571ED4AAF883D), reinterpret<f64>(0xBFDB0B6832D4FCA4), // 0x1.571ed4aaf883dp+0, -0x1.b0b6832d4fca4p-2,\n  reinterpret<f64>(0x3FF49539F0F010B0), reinterpret<f64>(0xBFD7418B0A1FB77B), // 0x1.49539f0f010bp+0 , -0x1.7418b0a1fb77bp-2,\n  reinterpret<f64>(0x3FF3C995B0B80385), reinterpret<f64>(0xBFD39DE91A6DCF7B), // 0x1.3c995b0b80385p+0, -0x1.39de91a6dcf7bp-2,\n  reinterpret<f64>(0x3FF30D190C8864A5), reinterpret<f64>(0xBFD01D9BF3F2B631), // 0x1.30d190c8864a5p+0, -0x1.01d9bf3f2b631p-2,\n  reinterpret<f64>(0x3FF25E227B0B8EA0), reinterpret<f64>(0xBFC97C1D1B3B7AF0), // 0x1.25e227b0b8eap+0 , -0x1.97c1d1b3b7afp-3 ,\n  reinterpret<f64>(0x3FF1BB4A4A1A343F), reinterpret<f64>(0xBFC2F9E393AF3C9F), // 0x1.1bb4a4a1a343fp+0, -0x1.2f9e393af3c9fp-3,\n  reinterpret<f64>(0x3FF12358F08AE5BA), reinterpret<f64>(0xBFB960CBBF788D5C), // 0x1.12358f08ae5bap+0, -0x1.960cbbf788d5cp-4,\n  reinterpret<f64>(0x3FF0953F419900A7), reinterpret<f64>(0xBFAA6F9DB6475FCE), // 0x1.0953f419900a7p+0, -0x1.a6f9db6475fcep-5,\n  reinterpret<f64>(0x3FF0000000000000), 0,                                    // 0x1p+0,                0x0,\n  reinterpret<f64>(0x3FEE608CFD9A47AC), reinterpret<f64>(0x3FB338CA9F24F53D), // 0x1.e608cfd9a47acp-1,  0x1.338ca9f24f53dp-4,\n  reinterpret<f64>(0x3FECA4B31F026AA0), reinterpret<f64>(0x3FC476A9543891BA), // 0x1.ca4b31f026aap-1 ,  0x1.476a9543891bap-3,\n  reinterpret<f64>(0x3FEB2036576AFCE6), reinterpret<f64>(0x3FCE840B4AC4E4D2), // 0x1.b2036576afce6p-1,  0x1.e840b4ac4e4d2p-3,\n  reinterpret<f64>(0x3FE9C2D163A1AA2D), reinterpret<f64>(0x3FD40645F0C6651C), // 0x1.9c2d163a1aa2dp-1,  0x1.40645f0c6651cp-2,\n  reinterpret<f64>(0x3FE886E6037841ED), reinterpret<f64>(0x3FD88E9C2C1B9FF8), // 0x1.886e6037841edp-1,  0x1.88e9c2c1b9ff8p-2,\n  reinterpret<f64>(0x3FE767DCF5534862), reinterpret<f64>(0x3FDCE0A44EB17BCC)  // 0x1.767dcf5534862p-1,  0x1.ce0a44eb17bccp-2\n]);\n\n// ULP error: 0.752 (nearest rounding.)\n// Relative error: 1.9 * 2^-26 (before rounding.)\n// @ts-ignore: decorator\n@inline\nexport function log2f_lut(x: f32): f32 {\n  const\n    N_MASK  = (1 << LOG2F_TABLE_BITS) - 1,\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\n\n  const\n    A0 = reinterpret<f64>(0xBFD712B6F70A7E4D), // -0x1.712b6f70a7e4dp-2\n    A1 = reinterpret<f64>(0x3FDECABF496832E0), //  0x1.ecabf496832ep-2\n    A2 = reinterpret<f64>(0xBFE715479FFAE3DE), // -0x1.715479ffae3dep-1\n    A3 = reinterpret<f64>(0x3FF715475F35C8B8); //  0x1.715475f35c8b8p0\n\n  var ux = reinterpret<u32>(x);\n  // Fix sign of zero with downward rounding when x==1.\n  // if (WANT_ROUNDING && predict_false(ix == 0x3f800000)) return 0;\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\n    // x < 0x1p-126 or inf or nan.\n    if (ux * 2 == 0) return -Infinity;\n    if (ux == 0x7F800000) return x; // log2(inf) == inf.\n    if ((ux >> 31) || ux * 2 >= 0xFF000000) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ux = reinterpret<u32>(x * Ox1p23f);\n    ux -= 23 << 23;\n  }\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp  = ux - 0x3F330000;\n  var i    = (tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK;\n  var top  = tmp & 0xFF800000;\n  var iz   = ux - top;\n  var k    = <i32>tmp >> 23;\n\n  var invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  var logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n  var z    = <f64>reinterpret<f32>(iz);\n\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\n  var r  = z * invc - 1;\n  var y0 = logc + <f64>k;\n\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\n  var y  = A1 * r + A2;\n  var p  = A3 * r + y0;\n  var r2 = r * r;\n  y += A0 * r2;\n  y  = y * r2 + p;\n\n  return <f32>y;\n}\n\n//\n// Lookup data for logf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/logf.c\n//\n\n// @ts-ignore: decorator\n@inline const LOGF_TABLE_BITS = 4;\n\n// @ts-ignore: decorator\n@lazy @inline const LOGF_DATA_TAB = memory.data<f64>([\n  reinterpret<f64>(0x3FF661EC79F8F3BE), reinterpret<f64>(0xBFD57BF7808CAADE), // 0x1.661ec79f8f3bep+0, -0x1.57bf7808caadep-2,\n  reinterpret<f64>(0x3FF571ED4AAF883D), reinterpret<f64>(0xBFD2BEF0A7C06DDB), // 0x1.571ed4aaf883dp+0, -0x1.2bef0a7c06ddbp-2,\n  reinterpret<f64>(0x3FF49539F0F010B0), reinterpret<f64>(0xBFD01EAE7F513A67), // 0x1.49539f0f010bp+0 , -0x1.01eae7f513a67p-2,\n  reinterpret<f64>(0x3FF3C995B0B80385), reinterpret<f64>(0xBFCB31D8A68224E9), // 0x1.3c995b0b80385p+0, -0x1.b31d8a68224e9p-3,\n  reinterpret<f64>(0x3FF30D190C8864A5), reinterpret<f64>(0xBFC6574F0AC07758), // 0x1.30d190c8864a5p+0, -0x1.6574f0ac07758p-3,\n  reinterpret<f64>(0x3FF25E227B0B8EA0), reinterpret<f64>(0xBFC1AA2BC79C8100), // 0x1.25e227b0b8eap+0 , -0x1.1aa2bc79c81p-3  ,\n  reinterpret<f64>(0x3FF1BB4A4A1A343F), reinterpret<f64>(0xBFBA4E76CE8C0E5E), // 0x1.1bb4a4a1a343fp+0, -0x1.a4e76ce8c0e5ep-4,\n  reinterpret<f64>(0x3FF12358F08AE5BA), reinterpret<f64>(0xBFB1973C5A611CCC), // 0x1.12358f08ae5bap+0, -0x1.1973c5a611cccp-4,\n  reinterpret<f64>(0x3FF0953F419900A7), reinterpret<f64>(0xBFA252F438E10C1E), // 0x1.0953f419900a7p+0, -0x1.252f438e10c1ep-5,\n  reinterpret<f64>(0x3FF0000000000000), 0,                                    // 0x1p+0,                0,\n  reinterpret<f64>(0x3FEE608CFD9A47AC), reinterpret<f64>(0x3FAAA5AA5DF25984), // 0x1.e608cfd9a47acp-1,  0x1.aa5aa5df25984p-5,\n  reinterpret<f64>(0x3FECA4B31F026AA0), reinterpret<f64>(0x3FBC5E53AA362EB4), // 0x1.ca4b31f026aap-1 ,  0x1.c5e53aa362eb4p-4,\n  reinterpret<f64>(0x3FEB2036576AFCE6), reinterpret<f64>(0x3FC526E57720DB08), // 0x1.b2036576afce6p-1,  0x1.526e57720db08p-3,\n  reinterpret<f64>(0x3FE9C2D163A1AA2D), reinterpret<f64>(0x3FCBC2860D224770), // 0x1.9c2d163a1aa2dp-1,  0x1.bc2860d22477p-3 ,\n  reinterpret<f64>(0x3FE886E6037841ED), reinterpret<f64>(0x3FD1058BC8A07EE1), // 0x1.886e6037841edp-1,  0x1.1058bc8a07ee1p-2,\n  reinterpret<f64>(0x3FE767DCF5534862), reinterpret<f64>(0x3FD4043057B6EE09)  // 0x1.767dcf5534862p-1,  0x1.4043057b6ee09p-2\n]);\n\n// ULP error: 0.818 (nearest rounding.)\n// Relative error: 1.957 * 2^-26 (before rounding.)\n// @ts-ignore: decorator\n@inline\nexport function logf_lut(x: f32): f32 {\n  const\n    N_MASK  = (1 << LOGF_TABLE_BITS) - 1,\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\n\n  const\n    Ln2 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1;\n    A0  = reinterpret<f64>(0xBFD00EA348B88334), // -0x1.00ea348b88334p-2\n    A1  = reinterpret<f64>(0x3FD5575B0BE00B6A), //  0x1.5575b0be00b6ap-2\n    A2  = reinterpret<f64>(0xBFDFFFFEF20A4123); // -0x1.ffffef20a4123p-2\n\n  var ux = reinterpret<u32>(x);\n  // Fix sign of zero with downward rounding when x==1.\n  // if (WANT_ROUNDING && ux == 0x3f800000) return 0;\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\n    // x < 0x1p-126 or inf or nan.\n    if ((ux << 1) == 0) return -Infinity;\n    if (ux == 0x7F800000) return x; // log(inf) == inf.\n    if ((ux >> 31) || (ux << 1) >= 0xFF000000) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ux = reinterpret<u32>(x * Ox1p23f);\n    ux -= 23 << 23;\n  }\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp = ux - 0x3F330000;\n  var i   = (tmp >> (23 - LOGF_TABLE_BITS)) & N_MASK;\n  var k   = <i32>tmp >> 23;\n  var iz  = ux - (tmp & 0x1FF << 23);\n\n  var invc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  var logc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n\n  var z = <f64>reinterpret<f32>(iz);\n\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2\n  var r = z * invc - 1;\n  var y0 = logc + <f64>k * Ln2;\n\n  // Pipelined polynomial evaluation to approximate log1p(r).\n  var r2 = r * r;\n  var y  = A1 * r + A2;\n  y += A0 * r2;\n  y = y * r2 + (y0 + r);\n\n  return <f32>y;\n}\n\n//\n// Lookup data for powf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/powf.c\n//\n\n// @ts-ignore: decorator\n@inline\nfunction zeroinfnanf(ux: u32): bool {\n  return (ux << 1) - 1 >= (<u32>0x7f800000 << 1) - 1;\n}\n\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\n// the bit representation of a non-zero finite floating-point value.\n// @ts-ignore: decorator\n@inline\nfunction checkintf(iy: u32): i32 {\n  var e = iy >> 23 & 0xFF;\n  if (e < 0x7F     ) return 0;\n  if (e > 0x7F + 23) return 2;\n  e = 1 << (0x7F + 23 - e);\n  if (iy & (e - 1)) return 0;\n  if (iy &  e     ) return 1;\n  return 2;\n}\n\n// Subnormal input is normalized so ix has negative biased exponent.\n// Output is multiplied by N (POWF_SCALE) if TOINT_INTRINICS is set.\n// @ts-ignore: decorator\n@inline\nfunction log2f_inline(ux: u32): f64 {\n  const N_MASK = (1 << LOG2F_TABLE_BITS) - 1;\n\n  const\n    A0 = reinterpret<f64>(0x3FD27616C9496E0B), //  0x1.27616c9496e0bp-2\n    A1 = reinterpret<f64>(0xBFD71969A075C67A), // -0x1.71969a075c67ap-2\n    A2 = reinterpret<f64>(0x3FDEC70A6CA7BADD), //  0x1.ec70a6ca7baddp-2\n    A3 = reinterpret<f64>(0xBFE7154748BEF6C8), // -0x1.7154748bef6c8p-1\n    A4 = reinterpret<f64>(0x3FF71547652AB82B); //  0x1.71547652ab82bp+0\n\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp  = ux - 0x3F330000;\n  var i    = <usize>((tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK);\n  var top  = tmp & 0xFF800000;\n  var uz   = ux - top;\n  var k    = <i32>(<i32>top >> 23);\n\n  var invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  var logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n  var z    = <f64>reinterpret<f32>(uz);\n\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\n  var r  = z * invc - 1;\n  var y0 = logc + <f64>k;\n\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\n  var y = A0 * r + A1;\n  var p = A2 * r + A3;\n  var q = A4 * r + y0;\n\n  r *= r;\n  q += p * r;\n  y  = y * (r * r) + q;\n\n  return y;\n}\n\n// The output of log2 and thus the input of exp2 is either scaled by N\n// (in case of fast toint intrinsics) or not.  The unscaled xd must be\n// in [-1021,1023], sign_bias sets the sign of the result.\n// @ts-ignore: decorator\n@inline\nfunction exp2f_inline(xd: f64, signBias: u32): f32 {\n  const\n    N      = 1 << EXP2F_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p+52\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\n\n  // x = k/N + r with r in [-1/(2N), 1/(2N)]\n  var kd = <f64>(xd + shift);\n  var ki = reinterpret<u64>(kd);\n  var r  = xd - (kd - shift);\n  var t: u64, z: f64, y: f64, s: f64;\n\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += (ki + signBias) << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  z  = C0 * r + C1;\n  y  = C2 * r + 1;\n  y += z * (r * r);\n  y *= s;\n  return <f32>y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction xflowf(sign: u32, y: f32): f32 {\n  return select<f32>(-y, y, sign) * y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction oflowf(sign: u32): f32 {\n  return xflowf(sign, reinterpret<f32>(0x70000000)); // 0x1p97f\n}\n\n// @ts-ignore: decorator\n@inline\nfunction uflowf(sign: u32): f32 {\n  return xflowf(sign, reinterpret<f32>(0x10000000)); // 0x1p-95f\n}\n\n// @ts-ignore: decorator\n@inline\nexport function powf_lut(x: f32, y: f32): f32 {\n  const\n    Ox1p23f     = reinterpret<f32>(0x4B000000), // 0x1p23f\n    UPPER_LIMIT = reinterpret<f64>(0x405FFFFFFFD1D571), // 0x1.fffffffd1d571p+6\n    LOWER_LIMIT = -150.0,\n    SIGN_BIAS   = 1 << (EXP2F_TABLE_BITS + 11);\n\n  var signBias: u32 = 0;\n  var ix = reinterpret<u32>(x);\n  var iy = reinterpret<u32>(y);\n  var ny = 0;\n\n  if (i32(ix - 0x00800000 >= 0x7f800000 - 0x00800000) | (ny = i32(zeroinfnanf(iy)))) {\n    // Either (x < 0x1p-126 or inf or nan) or (y is 0 or inf or nan).\n    if (ny) {\n      if ((iy << 1) == 0) return 1.0;\n      if (ix == 0x3F800000) return NaN; // original: 1.0\n      if ((ix << 1) > (<u32>0x7F800000 << 1) || (iy << 1) > (<u32>0x7F800000 << 1)) return x + y;\n      if ((ix << 1) == (0x3F800000 << 1)) return NaN; // original: 1.0\n      if (((ix << 1) < (0x3F800000 << 1)) == !(iy >> 31)) return 0; // |x| < 1 && y==inf or |x| > 1 && y==-inf.\n      return y * y;\n    }\n    if (zeroinfnanf(ix)) {\n      let x2 = x * x;\n      if ((ix >> 31) && checkintf(iy) == 1) x2 = -x2;\n      return iy >> 31 ? 1 / x2 : x2;\n    }\n    // x and y are non-zero finite.\n    if (ix >> 31) {\n      // Finite x < 0.\n      let yint = checkintf(iy);\n      if (yint == 0) return (x - x) / (x - x);\n      if (yint == 1) signBias = SIGN_BIAS;\n      ix &= 0x7FFFFFFF;\n    }\n    if (ix < 0x00800000) {\n      // Normalize subnormal x so exponent becomes negative.\n      ix = reinterpret<u32>(x * Ox1p23f);\n      ix &= 0x7FFFFFFF;\n      ix -= 23 << 23;\n    }\n  }\n  var logx = log2f_inline(ix);\n  var ylogx = y * logx; // cannot overflow, y is single prec.\n  if ((reinterpret<u64>(ylogx) >> 47 & 0xFFFF) >= 0x80BF) { // reinterpret<u64>(126.0) >> 47\n    // |y * log(x)| >= 126\n    if (ylogx  > UPPER_LIMIT) return oflowf(signBias); // overflow\n    if (ylogx <= LOWER_LIMIT) return uflowf(signBias); // underflow\n  }\n  return exp2f_inline(ylogx, signBias);\n}\n\n//\n// Lookup data for exp. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp.c\n//\n\n// @ts-ignore: decorator\n@inline const EXP_TABLE_BITS = 7;\n\n// @ts-ignore: decorator\n@lazy @inline const EXP_DATA_TAB = memory.data<u64>([\n  0x0000000000000000, 0x3FF0000000000000,\n  0x3C9B3B4F1A88BF6E, 0x3FEFF63DA9FB3335,\n  0xBC7160139CD8DC5D, 0x3FEFEC9A3E778061,\n  0xBC905E7A108766D1, 0x3FEFE315E86E7F85,\n  0x3C8CD2523567F613, 0x3FEFD9B0D3158574,\n  0xBC8BCE8023F98EFA, 0x3FEFD06B29DDF6DE,\n  0x3C60F74E61E6C861, 0x3FEFC74518759BC8,\n  0x3C90A3E45B33D399, 0x3FEFBE3ECAC6F383,\n  0x3C979AA65D837B6D, 0x3FEFB5586CF9890F,\n  0x3C8EB51A92FDEFFC, 0x3FEFAC922B7247F7,\n  0x3C3EBE3D702F9CD1, 0x3FEFA3EC32D3D1A2,\n  0xBC6A033489906E0B, 0x3FEF9B66AFFED31B,\n  0xBC9556522A2FBD0E, 0x3FEF9301D0125B51,\n  0xBC5080EF8C4EEA55, 0x3FEF8ABDC06C31CC,\n  0xBC91C923B9D5F416, 0x3FEF829AAEA92DE0,\n  0x3C80D3E3E95C55AF, 0x3FEF7A98C8A58E51,\n  0xBC801B15EAA59348, 0x3FEF72B83C7D517B,\n  0xBC8F1FF055DE323D, 0x3FEF6AF9388C8DEA,\n  0x3C8B898C3F1353BF, 0x3FEF635BEB6FCB75,\n  0xBC96D99C7611EB26, 0x3FEF5BE084045CD4,\n  0x3C9AECF73E3A2F60, 0x3FEF54873168B9AA,\n  0xBC8FE782CB86389D, 0x3FEF4D5022FCD91D,\n  0x3C8A6F4144A6C38D, 0x3FEF463B88628CD6,\n  0x3C807A05B0E4047D, 0x3FEF3F49917DDC96,\n  0x3C968EFDE3A8A894, 0x3FEF387A6E756238,\n  0x3C875E18F274487D, 0x3FEF31CE4FB2A63F,\n  0x3C80472B981FE7F2, 0x3FEF2B4565E27CDD,\n  0xBC96B87B3F71085E, 0x3FEF24DFE1F56381,\n  0x3C82F7E16D09AB31, 0x3FEF1E9DF51FDEE1,\n  0xBC3D219B1A6FBFFA, 0x3FEF187FD0DAD990,\n  0x3C8B3782720C0AB4, 0x3FEF1285A6E4030B,\n  0x3C6E149289CECB8F, 0x3FEF0CAFA93E2F56,\n  0x3C834D754DB0ABB6, 0x3FEF06FE0A31B715,\n  0x3C864201E2AC744C, 0x3FEF0170FC4CD831,\n  0x3C8FDD395DD3F84A, 0x3FEEFC08B26416FF,\n  0xBC86A3803B8E5B04, 0x3FEEF6C55F929FF1,\n  0xBC924AEDCC4B5068, 0x3FEEF1A7373AA9CB,\n  0xBC9907F81B512D8E, 0x3FEEECAE6D05D866,\n  0xBC71D1E83E9436D2, 0x3FEEE7DB34E59FF7,\n  0xBC991919B3CE1B15, 0x3FEEE32DC313A8E5,\n  0x3C859F48A72A4C6D, 0x3FEEDEA64C123422,\n  0xBC9312607A28698A, 0x3FEEDA4504AC801C,\n  0xBC58A78F4817895B, 0x3FEED60A21F72E2A,\n  0xBC7C2C9B67499A1B, 0x3FEED1F5D950A897,\n  0x3C4363ED60C2AC11, 0x3FEECE086061892D,\n  0x3C9666093B0664EF, 0x3FEECA41ED1D0057,\n  0x3C6ECCE1DAA10379, 0x3FEEC6A2B5C13CD0,\n  0x3C93FF8E3F0F1230, 0x3FEEC32AF0D7D3DE,\n  0x3C7690CEBB7AAFB0, 0x3FEEBFDAD5362A27,\n  0x3C931DBDEB54E077, 0x3FEEBCB299FDDD0D,\n  0xBC8F94340071A38E, 0x3FEEB9B2769D2CA7,\n  0xBC87DECCDC93A349, 0x3FEEB6DAA2CF6642,\n  0xBC78DEC6BD0F385F, 0x3FEEB42B569D4F82,\n  0xBC861246EC7B5CF6, 0x3FEEB1A4CA5D920F,\n  0x3C93350518FDD78E, 0x3FEEAF4736B527DA,\n  0x3C7B98B72F8A9B05, 0x3FEEAD12D497C7FD,\n  0x3C9063E1E21C5409, 0x3FEEAB07DD485429,\n  0x3C34C7855019C6EA, 0x3FEEA9268A5946B7,\n  0x3C9432E62B64C035, 0x3FEEA76F15AD2148,\n  0xBC8CE44A6199769F, 0x3FEEA5E1B976DC09,\n  0xBC8C33C53BEF4DA8, 0x3FEEA47EB03A5585,\n  0xBC845378892BE9AE, 0x3FEEA34634CCC320,\n  0xBC93CEDD78565858, 0x3FEEA23882552225,\n  0x3C5710AA807E1964, 0x3FEEA155D44CA973,\n  0xBC93B3EFBF5E2228, 0x3FEEA09E667F3BCD,\n  0xBC6A12AD8734B982, 0x3FEEA012750BDABF,\n  0xBC6367EFB86DA9EE, 0x3FEE9FB23C651A2F,\n  0xBC80DC3D54E08851, 0x3FEE9F7DF9519484,\n  0xBC781F647E5A3ECF, 0x3FEE9F75E8EC5F74,\n  0xBC86EE4AC08B7DB0, 0x3FEE9F9A48A58174,\n  0xBC8619321E55E68A, 0x3FEE9FEB564267C9,\n  0x3C909CCB5E09D4D3, 0x3FEEA0694FDE5D3F,\n  0xBC7B32DCB94DA51D, 0x3FEEA11473EB0187,\n  0x3C94ECFD5467C06B, 0x3FEEA1ED0130C132,\n  0x3C65EBE1ABD66C55, 0x3FEEA2F336CF4E62,\n  0xBC88A1C52FB3CF42, 0x3FEEA427543E1A12,\n  0xBC9369B6F13B3734, 0x3FEEA589994CCE13,\n  0xBC805E843A19FF1E, 0x3FEEA71A4623C7AD,\n  0xBC94D450D872576E, 0x3FEEA8D99B4492ED,\n  0x3C90AD675B0E8A00, 0x3FEEAAC7D98A6699,\n  0x3C8DB72FC1F0EAB4, 0x3FEEACE5422AA0DB,\n  0xBC65B6609CC5E7FF, 0x3FEEAF3216B5448C,\n  0x3C7BF68359F35F44, 0x3FEEB1AE99157736,\n  0xBC93091FA71E3D83, 0x3FEEB45B0B91FFC6,\n  0xBC5DA9B88B6C1E29, 0x3FEEB737B0CDC5E5,\n  0xBC6C23F97C90B959, 0x3FEEBA44CBC8520F,\n  0xBC92434322F4F9AA, 0x3FEEBD829FDE4E50,\n  0xBC85CA6CD7668E4B, 0x3FEEC0F170CA07BA,\n  0x3C71AFFC2B91CE27, 0x3FEEC49182A3F090,\n  0x3C6DD235E10A73BB, 0x3FEEC86319E32323,\n  0xBC87C50422622263, 0x3FEECC667B5DE565,\n  0x3C8B1C86E3E231D5, 0x3FEED09BEC4A2D33,\n  0xBC91BBD1D3BCBB15, 0x3FEED503B23E255D,\n  0x3C90CC319CEE31D2, 0x3FEED99E1330B358,\n  0x3C8469846E735AB3, 0x3FEEDE6B5579FDBF,\n  0xBC82DFCD978E9DB4, 0x3FEEE36BBFD3F37A,\n  0x3C8C1A7792CB3387, 0x3FEEE89F995AD3AD,\n  0xBC907B8F4AD1D9FA, 0x3FEEEE07298DB666,\n  0xBC55C3D956DCAEBA, 0x3FEEF3A2B84F15FB,\n  0xBC90A40E3DA6F640, 0x3FEEF9728DE5593A,\n  0xBC68D6F438AD9334, 0x3FEEFF76F2FB5E47,\n  0xBC91EEE26B588A35, 0x3FEF05B030A1064A,\n  0x3C74FFD70A5FDDCD, 0x3FEF0C1E904BC1D2,\n  0xBC91BDFBFA9298AC, 0x3FEF12C25BD71E09,\n  0x3C736EAE30AF0CB3, 0x3FEF199BDD85529C,\n  0x3C8EE3325C9FFD94, 0x3FEF20AB5FFFD07A,\n  0x3C84E08FD10959AC, 0x3FEF27F12E57D14B,\n  0x3C63CDAF384E1A67, 0x3FEF2F6D9406E7B5,\n  0x3C676B2C6C921968, 0x3FEF3720DCEF9069,\n  0xBC808A1883CCB5D2, 0x3FEF3F0B555DC3FA,\n  0xBC8FAD5D3FFFFA6F, 0x3FEF472D4A07897C,\n  0xBC900DAE3875A949, 0x3FEF4F87080D89F2,\n  0x3C74A385A63D07A7, 0x3FEF5818DCFBA487,\n  0xBC82919E2040220F, 0x3FEF60E316C98398,\n  0x3C8E5A50D5C192AC, 0x3FEF69E603DB3285,\n  0x3C843A59AC016B4B, 0x3FEF7321F301B460,\n  0xBC82D52107B43E1F, 0x3FEF7C97337B9B5F,\n  0xBC892AB93B470DC9, 0x3FEF864614F5A129,\n  0x3C74B604603A88D3, 0x3FEF902EE78B3FF6,\n  0x3C83C5EC519D7271, 0x3FEF9A51FBC74C83,\n  0xBC8FF7128FD391F0, 0x3FEFA4AFA2A490DA,\n  0xBC8DAE98E223747D, 0x3FEFAF482D8E67F1,\n  0x3C8EC3BC41AA2008, 0x3FEFBA1BEE615A27,\n  0x3C842B94C3A9EB32, 0x3FEFC52B376BBA97,\n  0x3C8A64A931D185EE, 0x3FEFD0765B6E4540,\n  0xBC8E37BAE43BE3ED, 0x3FEFDBFDAD9CBE14,\n  0x3C77893B4D91CD9D, 0x3FEFE7C1819E90D8,\n  0x3C5305C14160CC89, 0x3FEFF3C22B8F71F1\n]);\n\n// Handle cases that may overflow or underflow when computing the result that\n// is scale*(1+TMP) without intermediate rounding. The bit representation of\n// scale is in SBITS, however it has a computed exponent that may have\n// overflown into the sign bit so that needs to be adjusted before using it as\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\n// adjustment of scale, positive k here means the result may overflow and\n// negative k means the result may underflow.\n// @ts-ignore: decorator\n@inline\nfunction specialcase(tmp: f64, sbits: u64, ki: u64): f64 {\n  const\n    Ox1p_1022 = reinterpret<f64>(0x0010000000000000), // 0x1p-1022\n    Ox1p1009  = reinterpret<f64>(0x7F00000000000000); // 0x1p1009\n\n  var scale: f64;\n  if (!(ki & 0x80000000)) {\n    // k > 0, the exponent of scale might have overflowed by <= 460.\n    sbits -= u64(1009) << 52;\n    scale = reinterpret<f64>(sbits);\n    return Ox1p1009 * (scale + scale * tmp); // 0x1p1009\n  }\n  // k < 0, need special care in the subnormal range.\n  sbits += u64(1022) << 52;\n  // Note: sbits is signed scale.\n  scale = reinterpret<f64>(sbits);\n  var y = scale + scale * tmp;\n  if (abs(y) < 1.0) {\n    // Round y to the right precision before scaling it into the subnormal\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\n    // E is the worst-case ulp error outside the subnormal range.  So this\n    // is only useful if the goal is better than 1 ulp worst-case error.\n    let one = copysign(1.0, y);\n    let lo = scale - y + scale * tmp;\n    let hi = one + y;\n    lo = one - hi + y + lo;\n    y  = (hi + lo) - one;\n    // Fix the sign of 0.\n    if (y == 0.0) y = reinterpret<f64>(sbits & 0x8000000000000000);\n  }\n  return y * Ox1p_1022;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function exp_lut(x: f64): f64 {\n  const\n    N      = 1 << EXP_TABLE_BITS,\n    N_MASK = N - 1;\n\n  const\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52;\n\n  const\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\n\n  var ux = reinterpret<u64>(x);\n  var abstop = <u32>(ux >> 52 & 0x7FF);\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) return 1;\n    if (abstop >= 0x409) {\n      if (ux == 0xFFF0000000000000) return 0;\n      if (abstop >= 0x7FF) return 1.0 + x;\n      return select<f64>(0, Infinity, ux >> 63);\n    }\n    // Large x is special cased below.\n    abstop = 0;\n  }\n\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)]\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N]\n  var z = InvLn2N * x;\n  // #if TOINT_INTRINSICS\n  // \tkd = roundtoint(z);\n  // \tki = converttoint(z);\n  // #elif EXP_USE_TOINT_NARROW\n  // \t// z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\n  // var kd = z + shift;\n  // var ki = reinterpret<u64>(kd) >> 16;\n  // var kd = <f64><i32>ki;\n  // #else\n  // z - kd is in [-1, 1] in non-nearest rounding modes.\n  var kd = z + shift;\n  var ki = reinterpret<u64>(kd);\n  kd -= shift;\n  // #endif\n  var r = x + kd * NegLn2hiN + kd * NegLn2loN;\n  // 2^(k/N) ~= scale * (1 + tail).\n  var idx = <usize>((ki & N_MASK) << 1);\n  var top = ki << (52 - EXP_TABLE_BITS);\n\n  var tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()))); // T[idx]\n  // This is only a valid scale when -1023*N < k < 1024*N\n  var sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  var r2 = r * r;\n  // Without fma the worst case error is 0.25/N ulp larger.\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp.\n  var tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\n  var scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\n  // is no spurious underflow here even without fma.\n  return scale + scale * tmp;\n}\n\n//\n// Lookup data for exp2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp2.c\n//\n\n// Handle cases that may overflow or underflow when computing the result that\n// is scale*(1+TMP) without intermediate rounding.  The bit representation of\n// scale is in SBITS, however it has a computed exponent that may have\n// overflown into the sign bit so that needs to be adjusted before using it as\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\n// adjustment of scale, positive k here means the result may overflow and\n// negative k means the result may underflow.\n// @ts-ignore: decorator\n@inline\nfunction specialcase2(tmp: f64, sbits: u64, ki: u64): f64 {\n  const Ox1p_1022 = reinterpret<f64>(0x10000000000000); // 0x1p-1022\n  var scale: f64;\n  if ((ki & 0x80000000) == 0) {\n    // k > 0, the exponent of scale might have overflowed by 1\n    sbits -= u64(1) << 52;\n    scale = reinterpret<f64>(sbits);\n    return 2 * (scale * tmp + scale);\n  }\n  // k < 0, need special care in the subnormal range\n  sbits += u64(1022) << 52;\n  scale = reinterpret<f64>(sbits);\n  var y = scale * tmp + scale;\n  if (y < 1.0) {\n    // Round y to the right precision before scaling it into the subnormal\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\n    // E is the worst-case ulp error outside the subnormal range. So this\n    // is only useful if the goal is better than 1 ulp worst-case error.\n    let hi: f64, lo: f64;\n    lo = scale - y + scale * tmp;\n    hi = 1.0 + y;\n    lo = 1.0 - hi + y + lo;\n    y = (hi + lo) - 1.0;\n  }\n  return y * Ox1p_1022;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function exp2_lut(x: f64): f64 {\n  const\n    N      = 1 << EXP_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p52\n\n  const\n    C1 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1\n    C2 = reinterpret<f64>(0x3FCEBFBDFF82C424), // 0x1.ebfbdff82c424p-3\n    C3 = reinterpret<f64>(0x3FAC6B08D70CF4B5), // 0x1.c6b08d70cf4b5p-5\n    C4 = reinterpret<f64>(0x3F83B2ABD24650CC), // 0x1.3b2abd24650ccp-7\n    C5 = reinterpret<f64>(0x3F55D7E09B4E3A84); // 0x1.5d7e09b4e3a84p-10\n\n  var ux = reinterpret<u64>(x);\n  var abstop = <u32>(ux >> 52 & 0x7ff);\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) return 1.0;\n    if (abstop >= 0x409) {\n      if (ux == 0xFFF0000000000000) return 0;\n      if (abstop >= 0x7FF) return 1.0 + x;\n      if (!(ux >> 63)) return Infinity;\n      else if (ux >= 0xC090CC0000000000) return 0;\n    }\n    if ((ux << 1) > 0x811A000000000000) abstop = 0; // Large x is special cased below.\n  }\n\n  // exp2(x) = 2^(k/N) * 2^r, with 2^r in [2^(-1/2N),2^(1/2N)].\n  // x = k/N + r, with int k and r in [-1/2N, 1/2N]\n  var kd = x + shift;\n  var ki = reinterpret<u64>(kd);\n  kd -= shift; // k/N for int k\n  var r = x - kd;\n  // 2^(k/N) ~= scale * (1 + tail)\n  var idx = <usize>((ki & N_MASK) << 1);\n  var top = ki << (52 - EXP_TABLE_BITS);\n\n  var tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 0 << alignof<u64>())); // T[idx])\n  // This is only a valid scale when -1023*N < k < 1024*N\n  var sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\n  // exp2(x) = 2^(k/N) * 2^r ~= scale + scale * (tail + 2^r - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution\n  var r2 = r * r;\n  // Without fma the worst case error is 0.5/N ulp larger.\n  // Worst case error is less than 0.5+0.86/N+(abs poly error * 2^53) ulp.\n  var tmp = tail + r * C1 + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase2(tmp, sbits, ki);\n  var scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-65 and scale > 2^-928, so there\n  // is no spurious underflow here even without fma.\n  return scale * tmp + scale;\n}\n\n//\n// Lookup data for log2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log2.c\n//\n\n// @ts-ignore: decorator\n@inline const LOG2_TABLE_BITS = 6;\n\n/* Algorithm:\n\n  x = 2^k z\n  log2(x) = k + log2(c) + log2(z/c)\n  log2(z/c) = poly(z/c - 1)\n\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\ninto the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = (double)log2(c)\n  tab2[i].chi = (double)c\n  tab2[i].clo = (double)(c - (double)c)\n\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\nfloating point invc candidates around 1/center and selecting one for which\n\n  1) the rounding error in 0x1.8p10 + logc is 0,\n  2) the rounding error in z - chi - clo is < 0x1p-64 and\n  3) the rounding error in (double)log2(c) is minimized (< 0x1p-68).\n\nNote: 1) ensures that k + logc can be computed without rounding error, 2)\nensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to a\nsingle rounding error when there is no fast fma for z*invc - 1, 3) ensures\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\n|log2(x)| < 0x1p-4, this is not enough so that is special cased. */\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2_DATA_TAB1 = memory.data<f64>([\n  //            invc                  ,                logc\n  reinterpret<f64>(0x3FF724286BB1ACF8), reinterpret<f64>(0xBFE1095FEECDB000),\n  reinterpret<f64>(0x3FF6E1F766D2CCA1), reinterpret<f64>(0xBFE08494BD76D000),\n  reinterpret<f64>(0x3FF6A13D0E30D48A), reinterpret<f64>(0xBFE00143AEE8F800),\n  reinterpret<f64>(0x3FF661EC32D06C85), reinterpret<f64>(0xBFDEFEC5360B4000),\n  reinterpret<f64>(0x3FF623FA951198F8), reinterpret<f64>(0xBFDDFDD91AB7E000),\n  reinterpret<f64>(0x3FF5E75BA4CF026C), reinterpret<f64>(0xBFDCFFAE0CC79000),\n  reinterpret<f64>(0x3FF5AC055A214FB8), reinterpret<f64>(0xBFDC043811FDA000),\n  reinterpret<f64>(0x3FF571ED0F166E1E), reinterpret<f64>(0xBFDB0B67323AE000),\n  reinterpret<f64>(0x3FF53909590BF835), reinterpret<f64>(0xBFDA152F5A2DB000),\n  reinterpret<f64>(0x3FF5014FED61ADDD), reinterpret<f64>(0xBFD9217F5AF86000),\n  reinterpret<f64>(0x3FF4CAB88E487BD0), reinterpret<f64>(0xBFD8304DB0719000),\n  reinterpret<f64>(0x3FF49539B4334FEE), reinterpret<f64>(0xBFD74189F9A9E000),\n  reinterpret<f64>(0x3FF460CBDFAFD569), reinterpret<f64>(0xBFD6552BB5199000),\n  reinterpret<f64>(0x3FF42D664EE4B953), reinterpret<f64>(0xBFD56B23A29B1000),\n  reinterpret<f64>(0x3FF3FB01111DD8A6), reinterpret<f64>(0xBFD483650F5FA000),\n  reinterpret<f64>(0x3FF3C995B70C5836), reinterpret<f64>(0xBFD39DE937F6A000),\n  reinterpret<f64>(0x3FF3991C4AB6FD4A), reinterpret<f64>(0xBFD2BAA1538D6000),\n  reinterpret<f64>(0x3FF3698E0CE099B5), reinterpret<f64>(0xBFD1D98340CA4000),\n  reinterpret<f64>(0x3FF33AE48213E7B2), reinterpret<f64>(0xBFD0FA853A40E000),\n  reinterpret<f64>(0x3FF30D191985BDB1), reinterpret<f64>(0xBFD01D9C32E73000),\n  reinterpret<f64>(0x3FF2E025CAB271D7), reinterpret<f64>(0xBFCE857DA2FA6000),\n  reinterpret<f64>(0x3FF2B404CF13CD82), reinterpret<f64>(0xBFCCD3C8633D8000),\n  reinterpret<f64>(0x3FF288B02C7CCB50), reinterpret<f64>(0xBFCB26034C14A000),\n  reinterpret<f64>(0x3FF25E2263944DE5), reinterpret<f64>(0xBFC97C1C2F4FE000),\n  reinterpret<f64>(0x3FF234563D8615B1), reinterpret<f64>(0xBFC7D6023F800000),\n  reinterpret<f64>(0x3FF20B46E33EAF38), reinterpret<f64>(0xBFC633A71A05E000),\n  reinterpret<f64>(0x3FF1E2EEFDCDA3DD), reinterpret<f64>(0xBFC494F5E9570000),\n  reinterpret<f64>(0x3FF1BB4A580B3930), reinterpret<f64>(0xBFC2F9E424E0A000),\n  reinterpret<f64>(0x3FF19453847F2200), reinterpret<f64>(0xBFC162595AFDC000),\n  reinterpret<f64>(0x3FF16E06C0D5D73C), reinterpret<f64>(0xBFBF9C9A75BD8000),\n  reinterpret<f64>(0x3FF1485F47B7E4C2), reinterpret<f64>(0xBFBC7B575BF9C000),\n  reinterpret<f64>(0x3FF12358AD0085D1), reinterpret<f64>(0xBFB960C60FF48000),\n  reinterpret<f64>(0x3FF0FEF00F532227), reinterpret<f64>(0xBFB64CE247B60000),\n  reinterpret<f64>(0x3FF0DB2077D03A8F), reinterpret<f64>(0xBFB33F78B2014000),\n  reinterpret<f64>(0x3FF0B7E6D65980D9), reinterpret<f64>(0xBFB0387D1A42C000),\n  reinterpret<f64>(0x3FF0953EFE7B408D), reinterpret<f64>(0xBFAA6F9208B50000),\n  reinterpret<f64>(0x3FF07325CAC53B83), reinterpret<f64>(0xBFA47A954F770000),\n  reinterpret<f64>(0x3FF05197E40D1B5C), reinterpret<f64>(0xBF9D23A8C50C0000),\n  reinterpret<f64>(0x3FF03091C1208EA2), reinterpret<f64>(0xBF916A2629780000),\n  reinterpret<f64>(0x3FF0101025B37E21), reinterpret<f64>(0xBF7720F8D8E80000),\n  reinterpret<f64>(0x3FEFC07EF9CAA76B), reinterpret<f64>(0x3F86FE53B1500000),\n  reinterpret<f64>(0x3FEF4465D3F6F184), reinterpret<f64>(0x3FA11CCCE10F8000),\n  reinterpret<f64>(0x3FEECC079F84107F), reinterpret<f64>(0x3FAC4DFC8C8B8000),\n  reinterpret<f64>(0x3FEE573A99975AE8), reinterpret<f64>(0x3FB3AA321E574000),\n  reinterpret<f64>(0x3FEDE5D6F0BD3DE6), reinterpret<f64>(0x3FB918A0D08B8000),\n  reinterpret<f64>(0x3FED77B681FF38B3), reinterpret<f64>(0x3FBE72E9DA044000),\n  reinterpret<f64>(0x3FED0CB5724DE943), reinterpret<f64>(0x3FC1DCD2507F6000),\n  reinterpret<f64>(0x3FECA4B2DC0E7563), reinterpret<f64>(0x3FC476AB03DEA000),\n  reinterpret<f64>(0x3FEC3F8EE8D6CB51), reinterpret<f64>(0x3FC7074377E22000),\n  reinterpret<f64>(0x3FEBDD2B4F020C4C), reinterpret<f64>(0x3FC98EDE8BA94000),\n  reinterpret<f64>(0x3FEB7D6C006015CA), reinterpret<f64>(0x3FCC0DB86AD2E000),\n  reinterpret<f64>(0x3FEB20366E2E338F), reinterpret<f64>(0x3FCE840AAFCEE000),\n  reinterpret<f64>(0x3FEAC57026295039), reinterpret<f64>(0x3FD0790AB4678000),\n  reinterpret<f64>(0x3FEA6D01BC2731DD), reinterpret<f64>(0x3FD1AC056801C000),\n  reinterpret<f64>(0x3FEA16D3BC3FF18B), reinterpret<f64>(0x3FD2DB11D4FEE000),\n  reinterpret<f64>(0x3FE9C2D14967FEAD), reinterpret<f64>(0x3FD406464EC58000),\n  reinterpret<f64>(0x3FE970E4F47C9902), reinterpret<f64>(0x3FD52DBE093AF000),\n  reinterpret<f64>(0x3FE920FB3982BCF2), reinterpret<f64>(0x3FD651902050D000),\n  reinterpret<f64>(0x3FE8D30187F759F1), reinterpret<f64>(0x3FD771D2CDEAF000),\n  reinterpret<f64>(0x3FE886E5EBB9F66D), reinterpret<f64>(0x3FD88E9C857D9000),\n  reinterpret<f64>(0x3FE83C97B658B994), reinterpret<f64>(0x3FD9A80155E16000),\n  reinterpret<f64>(0x3FE7F405FFC61022), reinterpret<f64>(0x3FDABE186ED3D000),\n  reinterpret<f64>(0x3FE7AD22181415CA), reinterpret<f64>(0x3FDBD0F2AEA0E000),\n  reinterpret<f64>(0x3FE767DCF99EFF8C), reinterpret<f64>(0x3FDCE0A43DBF4000)\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2_DATA_TAB2 = memory.data<f64>([\n  //              chi                 ,                 clo\n  reinterpret<f64>(0x3FE6200012B90A8E), reinterpret<f64>(0x3C8904AB0644B605),\n  reinterpret<f64>(0x3FE66000045734A6), reinterpret<f64>(0x3C61FF9BEA62F7A9),\n  reinterpret<f64>(0x3FE69FFFC325F2C5), reinterpret<f64>(0x3C827ECFCB3C90BA),\n  reinterpret<f64>(0x3FE6E00038B95A04), reinterpret<f64>(0x3C88FF8856739326),\n  reinterpret<f64>(0x3FE71FFFE09994E3), reinterpret<f64>(0x3C8AFD40275F82B1),\n  reinterpret<f64>(0x3FE7600015590E10), reinterpret<f64>(0xBC72FD75B4238341),\n  reinterpret<f64>(0x3FE7A00012655BD5), reinterpret<f64>(0x3C7808E67C242B76),\n  reinterpret<f64>(0x3FE7E0003259E9A6), reinterpret<f64>(0xBC6208E426F622B7),\n  reinterpret<f64>(0x3FE81FFFEDB4B2D2), reinterpret<f64>(0xBC8402461EA5C92F),\n  reinterpret<f64>(0x3FE860002DFAFCC3), reinterpret<f64>(0x3C6DF7F4A2F29A1F),\n  reinterpret<f64>(0x3FE89FFFF78C6B50), reinterpret<f64>(0xBC8E0453094995FD),\n  reinterpret<f64>(0x3FE8E00039671566), reinterpret<f64>(0xBC8A04F3BEC77B45),\n  reinterpret<f64>(0x3FE91FFFE2BF1745), reinterpret<f64>(0xBC77FA34400E203C),\n  reinterpret<f64>(0x3FE95FFFCC5C9FD1), reinterpret<f64>(0xBC76FF8005A0695D),\n  reinterpret<f64>(0x3FE9A0003BBA4767), reinterpret<f64>(0x3C70F8C4C4EC7E03),\n  reinterpret<f64>(0x3FE9DFFFE7B92DA5), reinterpret<f64>(0x3C8E7FD9478C4602),\n  reinterpret<f64>(0x3FEA1FFFD72EFDAF), reinterpret<f64>(0xBC6A0C554DCDAE7E),\n  reinterpret<f64>(0x3FEA5FFFDE04FF95), reinterpret<f64>(0x3C867DA98CE9B26B),\n  reinterpret<f64>(0x3FEA9FFFCA5E8D2B), reinterpret<f64>(0xBC8284C9B54C13DE),\n  reinterpret<f64>(0x3FEADFFFDDAD03EA), reinterpret<f64>(0x3C5812C8EA602E3C),\n  reinterpret<f64>(0x3FEB1FFFF10D3D4D), reinterpret<f64>(0xBC8EFADDAD27789C),\n  reinterpret<f64>(0x3FEB5FFFCE21165A), reinterpret<f64>(0x3C53CB1719C61237),\n  reinterpret<f64>(0x3FEB9FFFD950E674), reinterpret<f64>(0x3C73F7D94194CE00),\n  reinterpret<f64>(0x3FEBE000139CA8AF), reinterpret<f64>(0x3C750AC4215D9BC0),\n  reinterpret<f64>(0x3FEC20005B46DF99), reinterpret<f64>(0x3C6BEEA653E9C1C9),\n  reinterpret<f64>(0x3FEC600040B9F7AE), reinterpret<f64>(0xBC7C079F274A70D6),\n  reinterpret<f64>(0x3FECA0006255FD8A), reinterpret<f64>(0xBC7A0B4076E84C1F),\n  reinterpret<f64>(0x3FECDFFFD94C095D), reinterpret<f64>(0x3C88F933F99AB5D7),\n  reinterpret<f64>(0x3FED1FFFF975D6CF), reinterpret<f64>(0xBC582C08665FE1BE),\n  reinterpret<f64>(0x3FED5FFFA2561C93), reinterpret<f64>(0xBC7B04289BD295F3),\n  reinterpret<f64>(0x3FED9FFF9D228B0C), reinterpret<f64>(0x3C870251340FA236),\n  reinterpret<f64>(0x3FEDE00065BC7E16), reinterpret<f64>(0xBC75011E16A4D80C),\n  reinterpret<f64>(0x3FEE200002F64791), reinterpret<f64>(0x3C89802F09EF62E0),\n  reinterpret<f64>(0x3FEE600057D7A6D8), reinterpret<f64>(0xBC7E0B75580CF7FA),\n  reinterpret<f64>(0x3FEEA00027EDC00C), reinterpret<f64>(0xBC8C848309459811),\n  reinterpret<f64>(0x3FEEE0006CF5CB7C), reinterpret<f64>(0xBC8F8027951576F4),\n  reinterpret<f64>(0x3FEF2000782B7DCC), reinterpret<f64>(0xBC8F81D97274538F),\n  reinterpret<f64>(0x3FEF6000260C450A), reinterpret<f64>(0xBC4071002727FFDC),\n  reinterpret<f64>(0x3FEF9FFFE88CD533), reinterpret<f64>(0xBC581BDCE1FDA8B0),\n  reinterpret<f64>(0x3FEFDFFFD50F8689), reinterpret<f64>(0x3C87F91ACB918E6E),\n  reinterpret<f64>(0x3FF0200004292367), reinterpret<f64>(0x3C9B7FF365324681),\n  reinterpret<f64>(0x3FF05FFFE3E3D668), reinterpret<f64>(0x3C86FA08DDAE957B),\n  reinterpret<f64>(0x3FF0A0000A85A757), reinterpret<f64>(0xBC57E2DE80D3FB91),\n  reinterpret<f64>(0x3FF0E0001A5F3FCC), reinterpret<f64>(0xBC91823305C5F014),\n  reinterpret<f64>(0x3FF11FFFF8AFBAF5), reinterpret<f64>(0xBC8BFABB6680BAC2),\n  reinterpret<f64>(0x3FF15FFFE54D91AD), reinterpret<f64>(0xBC9D7F121737E7EF),\n  reinterpret<f64>(0x3FF1A00011AC36E1), reinterpret<f64>(0x3C9C000A0516F5FF),\n  reinterpret<f64>(0x3FF1E00019C84248), reinterpret<f64>(0xBC9082FBE4DA5DA0),\n  reinterpret<f64>(0x3FF220000FFE5E6E), reinterpret<f64>(0xBC88FDD04C9CFB43),\n  reinterpret<f64>(0x3FF26000269FD891), reinterpret<f64>(0x3C8CFE2A7994D182),\n  reinterpret<f64>(0x3FF2A00029A6E6DA), reinterpret<f64>(0xBC700273715E8BC5),\n  reinterpret<f64>(0x3FF2DFFFE0293E39), reinterpret<f64>(0x3C9B7C39DAB2A6F9),\n  reinterpret<f64>(0x3FF31FFFF7DCF082), reinterpret<f64>(0x3C7DF1336EDC5254),\n  reinterpret<f64>(0x3FF35FFFF05A8B60), reinterpret<f64>(0xBC9E03564CCD31EB),\n  reinterpret<f64>(0x3FF3A0002E0EAECC), reinterpret<f64>(0x3C75F0E74BD3A477),\n  reinterpret<f64>(0x3FF3E000043BB236), reinterpret<f64>(0x3C9C7DCB149D8833),\n  reinterpret<f64>(0x3FF4200002D187FF), reinterpret<f64>(0x3C7E08AFCF2D3D28),\n  reinterpret<f64>(0x3FF460000D387CB1), reinterpret<f64>(0x3C820837856599A6),\n  reinterpret<f64>(0x3FF4A00004569F89), reinterpret<f64>(0xBC89FA5C904FBCD2),\n  reinterpret<f64>(0x3FF4E000043543F3), reinterpret<f64>(0xBC781125ED175329),\n  reinterpret<f64>(0x3FF51FFFCC027F0F), reinterpret<f64>(0x3C9883D8847754DC),\n  reinterpret<f64>(0x3FF55FFFFD87B36F), reinterpret<f64>(0xBC8709E731D02807),\n  reinterpret<f64>(0x3FF59FFFF21DF7BA), reinterpret<f64>(0x3C87F79F68727B02),\n  reinterpret<f64>(0x3FF5DFFFEBFC3481), reinterpret<f64>(0xBC9180902E30E93E)\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function log2_lut(x: f64): f64 {\n  const N_MASK = (1 << LOG2_TABLE_BITS) - 1;\n\n  const\n    LO: u64 = 0x3FEEA4AF00000000, // reinterpret<u64>(1.0 - 0x1.5b51p-5)\n    HI: u64 = 0x3FF0B55900000000; // reinterpret<u64>(1.0 + 0x1.6ab2p-5)\n\n  const\n    InvLn2hi = reinterpret<f64>(0x3FF7154765200000), // 0x1.7154765200000p+0\n    InvLn2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 0x1.705fc2eefa200p-33\n    Ox1p52   = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  const\n    B0 = reinterpret<f64>(0xBFE71547652B82FE), // -0x1.71547652b82fep-1\n    B1 = reinterpret<f64>(0x3FDEC709DC3A03F7), //  0x1.ec709dc3a03f7p-2\n    B2 = reinterpret<f64>(0xBFD71547652B7C3F), // -0x1.71547652b7c3fp-2\n    B3 = reinterpret<f64>(0x3FD2776C50F05BE4), //  0x1.2776c50f05be4p-2\n    B4 = reinterpret<f64>(0xBFCEC709DD768FE5), // -0x1.ec709dd768fe5p-3\n    B5 = reinterpret<f64>(0x3FCA61761EC4E736), //  0x1.a61761ec4e736p-3\n    B6 = reinterpret<f64>(0xBFC7153FBC64A79B), // -0x1.7153fbc64a79bp-3\n    B7 = reinterpret<f64>(0x3FC484D154F01B4A), //  0x1.484d154f01b4ap-3\n    B8 = reinterpret<f64>(0xBFC289E4A72C383C), // -0x1.289e4a72c383cp-3\n    B9 = reinterpret<f64>(0x3FC0B32F285AEE66); //  0x1.0b32f285aee66p-3\n\n  const\n    A0 = reinterpret<f64>(0xBFE71547652B8339), // -0x1.71547652b8339p-1\n    A1 = reinterpret<f64>(0x3FDEC709DC3A04BE), //  0x1.ec709dc3a04bep-2\n    A2 = reinterpret<f64>(0xBFD7154764702FFB), // -0x1.7154764702ffbp-2\n    A3 = reinterpret<f64>(0x3FD2776C50034C48), //  0x1.2776c50034c48p-2\n    A4 = reinterpret<f64>(0xBFCEC7B328EA92BC), // -0x1.ec7b328ea92bcp-3\n    A5 = reinterpret<f64>(0x3FCA6225E117F92E); //  0x1.a6225e117f92ep-3\n\n  var ix = reinterpret<u64>(x);\n  if (ix - LO < HI - LO) {\n    let r = x - 1.0;\n    // #if __FP_FAST_FMA\n    //     hi = r * InvLn2hi;\n    //     lo = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -hi);\n    // #else\n    let rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\n    let rlo = r - rhi;\n    let hi  = rhi * InvLn2hi;\n    let lo  = rlo * InvLn2hi + r * InvLn2lo;\n    // #endif\n    let r2 = r * r; // rounding error: 0x1p-62\n    let r4 = r2 * r2;\n    // Worst-case error is less than 0.54 ULP (0.55 ULP without fma)\n    let p = r2 * (B0 + r * B1);\n    let y = hi + p;\n    lo += hi - y + p;\n    lo += r4 * (B2 + r * B3 + r2 * (B4 + r * B5) +\n          r4 * (B6 + r * B7 + r2 * (B8 + r * B9)));\n    return y + lo;\n  }\n  var top = <u32>(ix >> 48);\n  if (top - 0x0010 >= 0x7ff0 - 0x0010) {\n    // x < 0x1p-1022 or inf or nan.\n    if ((ix << 1) == 0) return -1.0 / (x * x);\n    if (ix == 0x7FF0000000000000) return x; // log(inf) == inf\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ix = reinterpret<u64>(x * Ox1p52);\n    ix -= u64(52) << 52;\n  }\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp  = ix - 0x3FE6000000000000;\n  var i    = <usize>((tmp >> (52 - LOG2_TABLE_BITS)) & N_MASK);\n  var k    = <i64>tmp >> 52;\n  var iz   = ix - (tmp & 0xFFF0000000000000);\n\n  var invc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\n  var logc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\n  var z    = reinterpret<f64>(iz);\n  var kd   = <f64>k;\n\n  // log2(x) = log2(z/c) + log2(c) + k.\n  // r ~= z/c - 1, |r| < 1/(2*N).\n  // #if __FP_FAST_FMA\n  // \t// rounding error: 0x1p-55/N.\n  // \tr = __builtin_fma(z, invc, -1.0);\n  // \tt1 = r * InvLn2hi;\n  // \tt2 = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -t1);\n  // #else\n  // rounding error: 0x1p-55/N + 0x1p-65.\n  var chi = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].chi;\n  var clo = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].clo;\n\n  var r   = (z - chi - clo) * invc;\n  var rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\n  var rlo = r - rhi;\n  var t1  = rhi * InvLn2hi;\n  var t2  = rlo * InvLn2hi + r * InvLn2lo;\n  // #endif\n\n  // hi + lo = r/ln2 + log2(c) + k\n  var t3 = kd + logc;\n  var hi = t3 + t1;\n  var lo = t3 - hi + t1 + t2;\n\n  // log2(r+1) = r/ln2 + r^2*poly(r)\n  // Evaluation is optimized assuming superscalar pipelined execution\n  var r2 = r * r; // rounding error: 0x1p-54/N^2\n  // Worst-case error if |y| > 0x1p-4: 0.547 ULP (0.550 ULP without fma).\n  // ~ 0.5 + 2/N/ln2 + abs-poly-error*0x1p56 ULP (+ 0.003 ULP without fma).\n  var p = A0 + r * A1 + r2 * (A2 + r * A3) + (r2 * r2) * (A4 + r * A5);\n  return lo + r2 * p + hi;\n}\n\n//\n// Lookup data for log. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log.c\n//\n\n// @ts-ignore: decorator\n@inline const LOG_TABLE_BITS = 7;\n\n/* Algorithm:\n\n  x = 2^k z\n  log(x) = k ln2 + log(c) + log(z/c)\n  log(z/c) = poly(z/c - 1)\n\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\ninto the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = (double)log(c)\n  tab2[i].chi = (double)c\n  tab2[i].clo = (double)(c - (double)c)\n\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\nfloating point invc candidates around 1/center and selecting one for which\n\n  1) the rounding error in 0x1.8p9 + logc is 0,\n  2) the rounding error in z - chi - clo is < 0x1p-66 and\n  3) the rounding error in (double)log(c) is minimized (< 0x1p-66).\n\nNote: 1) ensures that k*ln2hi + logc can be computed without rounding error,\n2) ensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to\na single rounding error when there is no fast fma for z*invc - 1, 3) ensures\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\n|log(x)| < 0x1p-4, this is not enough so that is special cased.*/\n\n// @ts-ignore: decorator\n@lazy @inline const LOG_DATA_TAB1 = memory.data<f64>([\n  //              invc                ,                 logc\n  reinterpret<f64>(0x3FF734F0C3E0DE9F), reinterpret<f64>(0xBFD7CC7F79E69000),\n  reinterpret<f64>(0x3FF713786A2CE91F), reinterpret<f64>(0xBFD76FEEC20D0000),\n  reinterpret<f64>(0x3FF6F26008FAB5A0), reinterpret<f64>(0xBFD713E31351E000),\n  reinterpret<f64>(0x3FF6D1A61F138C7D), reinterpret<f64>(0xBFD6B85B38287800),\n  reinterpret<f64>(0x3FF6B1490BC5B4D1), reinterpret<f64>(0xBFD65D5590807800),\n  reinterpret<f64>(0x3FF69147332F0CBA), reinterpret<f64>(0xBFD602D076180000),\n  reinterpret<f64>(0x3FF6719F18224223), reinterpret<f64>(0xBFD5A8CA86909000),\n  reinterpret<f64>(0x3FF6524F99A51ED9), reinterpret<f64>(0xBFD54F4356035000),\n  reinterpret<f64>(0x3FF63356AA8F24C4), reinterpret<f64>(0xBFD4F637C36B4000),\n  reinterpret<f64>(0x3FF614B36B9DDC14), reinterpret<f64>(0xBFD49DA7FDA85000),\n  reinterpret<f64>(0x3FF5F66452C65C4C), reinterpret<f64>(0xBFD445923989A800),\n  reinterpret<f64>(0x3FF5D867B5912C4F), reinterpret<f64>(0xBFD3EDF439B0B800),\n  reinterpret<f64>(0x3FF5BABCCB5B90DE), reinterpret<f64>(0xBFD396CE448F7000),\n  reinterpret<f64>(0x3FF59D61F2D91A78), reinterpret<f64>(0xBFD3401E17BDA000),\n  reinterpret<f64>(0x3FF5805612465687), reinterpret<f64>(0xBFD2E9E2EF468000),\n  reinterpret<f64>(0x3FF56397CEE76BD3), reinterpret<f64>(0xBFD2941B3830E000),\n  reinterpret<f64>(0x3FF54725E2A77F93), reinterpret<f64>(0xBFD23EC58CDA8800),\n  reinterpret<f64>(0x3FF52AFF42064583), reinterpret<f64>(0xBFD1E9E129279000),\n  reinterpret<f64>(0x3FF50F22DBB2BDDF), reinterpret<f64>(0xBFD1956D2B48F800),\n  reinterpret<f64>(0x3FF4F38F4734DED7), reinterpret<f64>(0xBFD141679AB9F800),\n  reinterpret<f64>(0x3FF4D843CFDE2840), reinterpret<f64>(0xBFD0EDD094EF9800),\n  reinterpret<f64>(0x3FF4BD3EC078A3C8), reinterpret<f64>(0xBFD09AA518DB1000),\n  reinterpret<f64>(0x3FF4A27FC3E0258A), reinterpret<f64>(0xBFD047E65263B800),\n  reinterpret<f64>(0x3FF4880524D48434), reinterpret<f64>(0xBFCFEB224586F000),\n  reinterpret<f64>(0x3FF46DCE1B192D0B), reinterpret<f64>(0xBFCF474A7517B000),\n  reinterpret<f64>(0x3FF453D9D3391854), reinterpret<f64>(0xBFCEA4443D103000),\n  reinterpret<f64>(0x3FF43A2744B4845A), reinterpret<f64>(0xBFCE020D44E9B000),\n  reinterpret<f64>(0x3FF420B54115F8FB), reinterpret<f64>(0xBFCD60A22977F000),\n  reinterpret<f64>(0x3FF40782DA3EF4B1), reinterpret<f64>(0xBFCCC00104959000),\n  reinterpret<f64>(0x3FF3EE8F5D57FE8F), reinterpret<f64>(0xBFCC202956891000),\n  reinterpret<f64>(0x3FF3D5D9A00B4CE9), reinterpret<f64>(0xBFCB81178D811000),\n  reinterpret<f64>(0x3FF3BD60C010C12B), reinterpret<f64>(0xBFCAE2C9CCD3D000),\n  reinterpret<f64>(0x3FF3A5242B75DAB8), reinterpret<f64>(0xBFCA45402E129000),\n  reinterpret<f64>(0x3FF38D22CD9FD002), reinterpret<f64>(0xBFC9A877681DF000),\n  reinterpret<f64>(0x3FF3755BC5847A1C), reinterpret<f64>(0xBFC90C6D69483000),\n  reinterpret<f64>(0x3FF35DCE49AD36E2), reinterpret<f64>(0xBFC87120A645C000),\n  reinterpret<f64>(0x3FF34679984DD440), reinterpret<f64>(0xBFC7D68FB4143000),\n  reinterpret<f64>(0x3FF32F5CCEFFCB24), reinterpret<f64>(0xBFC73CB83C627000),\n  reinterpret<f64>(0x3FF3187775A10D49), reinterpret<f64>(0xBFC6A39A9B376000),\n  reinterpret<f64>(0x3FF301C8373E3990), reinterpret<f64>(0xBFC60B3154B7A000),\n  reinterpret<f64>(0x3FF2EB4EBB95F841), reinterpret<f64>(0xBFC5737D76243000),\n  reinterpret<f64>(0x3FF2D50A0219A9D1), reinterpret<f64>(0xBFC4DC7B8FC23000),\n  reinterpret<f64>(0x3FF2BEF9A8B7FD2A), reinterpret<f64>(0xBFC4462C51D20000),\n  reinterpret<f64>(0x3FF2A91C7A0C1BAB), reinterpret<f64>(0xBFC3B08ABC830000),\n  reinterpret<f64>(0x3FF293726014B530), reinterpret<f64>(0xBFC31B996B490000),\n  reinterpret<f64>(0x3FF27DFA5757A1F5), reinterpret<f64>(0xBFC2875490A44000),\n  reinterpret<f64>(0x3FF268B39B1D3BBF), reinterpret<f64>(0xBFC1F3B9F879A000),\n  reinterpret<f64>(0x3FF2539D838FF5BD), reinterpret<f64>(0xBFC160C8252CA000),\n  reinterpret<f64>(0x3FF23EB7AAC9083B), reinterpret<f64>(0xBFC0CE7F57F72000),\n  reinterpret<f64>(0x3FF22A012BA940B6), reinterpret<f64>(0xBFC03CDC49FEA000),\n  reinterpret<f64>(0x3FF2157996CC4132), reinterpret<f64>(0xBFBF57BDBC4B8000),\n  reinterpret<f64>(0x3FF201201DD2FC9B), reinterpret<f64>(0xBFBE370896404000),\n  reinterpret<f64>(0x3FF1ECF4494D480B), reinterpret<f64>(0xBFBD17983EF94000),\n  reinterpret<f64>(0x3FF1D8F5528F6569), reinterpret<f64>(0xBFBBF9674ED8A000),\n  reinterpret<f64>(0x3FF1C52311577E7C), reinterpret<f64>(0xBFBADC79202F6000),\n  reinterpret<f64>(0x3FF1B17C74CB26E9), reinterpret<f64>(0xBFB9C0C3E7288000),\n  reinterpret<f64>(0x3FF19E010C2C1AB6), reinterpret<f64>(0xBFB8A646B372C000),\n  reinterpret<f64>(0x3FF18AB07BB670BD), reinterpret<f64>(0xBFB78D01B3AC0000),\n  reinterpret<f64>(0x3FF1778A25EFBCB6), reinterpret<f64>(0xBFB674F145380000),\n  reinterpret<f64>(0x3FF1648D354C31DA), reinterpret<f64>(0xBFB55E0E6D878000),\n  reinterpret<f64>(0x3FF151B990275FDD), reinterpret<f64>(0xBFB4485CDEA1E000),\n  reinterpret<f64>(0x3FF13F0EA432D24C), reinterpret<f64>(0xBFB333D94D6AA000),\n  reinterpret<f64>(0x3FF12C8B7210F9DA), reinterpret<f64>(0xBFB22079F8C56000),\n  reinterpret<f64>(0x3FF11A3028ECB531), reinterpret<f64>(0xBFB10E4698622000),\n  reinterpret<f64>(0x3FF107FBDA8434AF), reinterpret<f64>(0xBFAFFA6C6AD20000),\n  reinterpret<f64>(0x3FF0F5EE0F4E6BB3), reinterpret<f64>(0xBFADDA8D4A774000),\n  reinterpret<f64>(0x3FF0E4065D2A9FCE), reinterpret<f64>(0xBFABBCECE4850000),\n  reinterpret<f64>(0x3FF0D244632CA521), reinterpret<f64>(0xBFA9A1894012C000),\n  reinterpret<f64>(0x3FF0C0A77CE2981A), reinterpret<f64>(0xBFA788583302C000),\n  reinterpret<f64>(0x3FF0AF2F83C636D1), reinterpret<f64>(0xBFA5715E67D68000),\n  reinterpret<f64>(0x3FF09DDB98A01339), reinterpret<f64>(0xBFA35C8A49658000),\n  reinterpret<f64>(0x3FF08CABAF52E7DF), reinterpret<f64>(0xBFA149E364154000),\n  reinterpret<f64>(0x3FF07B9F2F4E28FB), reinterpret<f64>(0xBF9E72C082EB8000),\n  reinterpret<f64>(0x3FF06AB58C358F19), reinterpret<f64>(0xBF9A55F152528000),\n  reinterpret<f64>(0x3FF059EEA5ECF92C), reinterpret<f64>(0xBF963D62CF818000),\n  reinterpret<f64>(0x3FF04949CDD12C90), reinterpret<f64>(0xBF9228FB8CAA0000),\n  reinterpret<f64>(0x3FF038C6C6F0ADA9), reinterpret<f64>(0xBF8C317B20F90000),\n  reinterpret<f64>(0x3FF02865137932A9), reinterpret<f64>(0xBF8419355DAA0000),\n  reinterpret<f64>(0x3FF0182427EA7348), reinterpret<f64>(0xBF781203C2EC0000),\n  reinterpret<f64>(0x3FF008040614B195), reinterpret<f64>(0xBF60040979240000),\n  reinterpret<f64>(0x3FEFE01FF726FA1A), reinterpret<f64>(0x3F6FEFF384900000),\n  reinterpret<f64>(0x3FEFA11CC261EA74), reinterpret<f64>(0x3F87DC41353D0000),\n  reinterpret<f64>(0x3FEF6310B081992E), reinterpret<f64>(0x3F93CEA3C4C28000),\n  reinterpret<f64>(0x3FEF25F63CEEADCD), reinterpret<f64>(0x3F9B9FC114890000),\n  reinterpret<f64>(0x3FEEE9C8039113E7), reinterpret<f64>(0x3FA1B0D8CE110000),\n  reinterpret<f64>(0x3FEEAE8078CBB1AB), reinterpret<f64>(0x3FA58A5BD001C000),\n  reinterpret<f64>(0x3FEE741AA29D0C9B), reinterpret<f64>(0x3FA95C8340D88000),\n  reinterpret<f64>(0x3FEE3A91830A99B5), reinterpret<f64>(0x3FAD276AEF578000),\n  reinterpret<f64>(0x3FEE01E009609A56), reinterpret<f64>(0x3FB07598E598C000),\n  reinterpret<f64>(0x3FEDCA01E577BB98), reinterpret<f64>(0x3FB253F5E30D2000),\n  reinterpret<f64>(0x3FED92F20B7C9103), reinterpret<f64>(0x3FB42EDD8B380000),\n  reinterpret<f64>(0x3FED5CAC66FB5CCE), reinterpret<f64>(0x3FB606598757C000),\n  reinterpret<f64>(0x3FED272CAA5EDE9D), reinterpret<f64>(0x3FB7DA76356A0000),\n  reinterpret<f64>(0x3FECF26E3E6B2CCD), reinterpret<f64>(0x3FB9AB434E1C6000),\n  reinterpret<f64>(0x3FECBE6DA2A77902), reinterpret<f64>(0x3FBB78C7BB0D6000),\n  reinterpret<f64>(0x3FEC8B266D37086D), reinterpret<f64>(0x3FBD431332E72000),\n  reinterpret<f64>(0x3FEC5894BD5D5804), reinterpret<f64>(0x3FBF0A3171DE6000),\n  reinterpret<f64>(0x3FEC26B533BB9F8C), reinterpret<f64>(0x3FC067152B914000),\n  reinterpret<f64>(0x3FEBF583EEECE73F), reinterpret<f64>(0x3FC147858292B000),\n  reinterpret<f64>(0x3FEBC4FD75DB96C1), reinterpret<f64>(0x3FC2266ECDCA3000),\n  reinterpret<f64>(0x3FEB951E0C864A28), reinterpret<f64>(0x3FC303D7A6C55000),\n  reinterpret<f64>(0x3FEB65E2C5EF3E2C), reinterpret<f64>(0x3FC3DFC33C331000),\n  reinterpret<f64>(0x3FEB374867C9888B), reinterpret<f64>(0x3FC4BA366B7A8000),\n  reinterpret<f64>(0x3FEB094B211D304A), reinterpret<f64>(0x3FC5933928D1F000),\n  reinterpret<f64>(0x3FEADBE885F2EF7E), reinterpret<f64>(0x3FC66ACD2418F000),\n  reinterpret<f64>(0x3FEAAF1D31603DA2), reinterpret<f64>(0x3FC740F8EC669000),\n  reinterpret<f64>(0x3FEA82E63FD358A7), reinterpret<f64>(0x3FC815C0F51AF000),\n  reinterpret<f64>(0x3FEA5740EF09738B), reinterpret<f64>(0x3FC8E92954F68000),\n  reinterpret<f64>(0x3FEA2C2A90AB4B27), reinterpret<f64>(0x3FC9BB3602F84000),\n  reinterpret<f64>(0x3FEA01A01393F2D1), reinterpret<f64>(0x3FCA8BED1C2C0000),\n  reinterpret<f64>(0x3FE9D79F24DB3C1B), reinterpret<f64>(0x3FCB5B515C01D000),\n  reinterpret<f64>(0x3FE9AE2505C7B190), reinterpret<f64>(0x3FCC2967CCBCC000),\n  reinterpret<f64>(0x3FE9852EF297CE2F), reinterpret<f64>(0x3FCCF635D5486000),\n  reinterpret<f64>(0x3FE95CBAEEA44B75), reinterpret<f64>(0x3FCDC1BD3446C000),\n  reinterpret<f64>(0x3FE934C69DE74838), reinterpret<f64>(0x3FCE8C01B8CFE000),\n  reinterpret<f64>(0x3FE90D4F2F6752E6), reinterpret<f64>(0x3FCF5509C0179000),\n  reinterpret<f64>(0x3FE8E6528EFFD79D), reinterpret<f64>(0x3FD00E6C121FB800),\n  reinterpret<f64>(0x3FE8BFCE9FCC007C), reinterpret<f64>(0x3FD071B80E93D000),\n  reinterpret<f64>(0x3FE899C0DABEC30E), reinterpret<f64>(0x3FD0D46B9E867000),\n  reinterpret<f64>(0x3FE87427AA2317FB), reinterpret<f64>(0x3FD13687334BD000),\n  reinterpret<f64>(0x3FE84F00ACB39A08), reinterpret<f64>(0x3FD1980D67234800),\n  reinterpret<f64>(0x3FE82A49E8653E55), reinterpret<f64>(0x3FD1F8FFE0CC8000),\n  reinterpret<f64>(0x3FE8060195F40260), reinterpret<f64>(0x3FD2595FD7636800),\n  reinterpret<f64>(0x3FE7E22563E0A329), reinterpret<f64>(0x3FD2B9300914A800),\n  reinterpret<f64>(0x3FE7BEB377DCB5AD), reinterpret<f64>(0x3FD3187210436000),\n  reinterpret<f64>(0x3FE79BAA679725C2), reinterpret<f64>(0x3FD377266DEC1800),\n  reinterpret<f64>(0x3FE77907F2170657), reinterpret<f64>(0x3FD3D54FFBAF3000),\n  reinterpret<f64>(0x3FE756CADBD6130C), reinterpret<f64>(0x3FD432EEE32FE000)\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOG_DATA_TAB2 = memory.data<f64>([\n  //               chi                ,                  clo\n  reinterpret<f64>(0x3FE61000014FB66B), reinterpret<f64>(0x3C7E026C91425B3C),\n  reinterpret<f64>(0x3FE63000034DB495), reinterpret<f64>(0x3C8DBFEA48005D41),\n  reinterpret<f64>(0x3FE650000D94D478), reinterpret<f64>(0x3C8E7FA786D6A5B7),\n  reinterpret<f64>(0x3FE67000074E6FAD), reinterpret<f64>(0x3C61FCEA6B54254C),\n  reinterpret<f64>(0x3FE68FFFFEDF0FAE), reinterpret<f64>(0xBC7C7E274C590EFD),\n  reinterpret<f64>(0x3FE6B0000763C5BC), reinterpret<f64>(0xBC8AC16848DCDA01),\n  reinterpret<f64>(0x3FE6D0001E5CC1F6), reinterpret<f64>(0x3C833F1C9D499311),\n  reinterpret<f64>(0x3FE6EFFFEB05F63E), reinterpret<f64>(0xBC7E80041AE22D53),\n  reinterpret<f64>(0x3FE710000E869780), reinterpret<f64>(0x3C7BFF6671097952),\n  reinterpret<f64>(0x3FE72FFFFC67E912), reinterpret<f64>(0x3C8C00E226BD8724),\n  reinterpret<f64>(0x3FE74FFFDF81116A), reinterpret<f64>(0xBC6E02916EF101D2),\n  reinterpret<f64>(0x3FE770000F679C90), reinterpret<f64>(0xBC67FC71CD549C74),\n  reinterpret<f64>(0x3FE78FFFFA7EC835), reinterpret<f64>(0x3C81BEC19EF50483),\n  reinterpret<f64>(0x3FE7AFFFFE20C2E6), reinterpret<f64>(0xBC707E1729CC6465),\n  reinterpret<f64>(0x3FE7CFFFED3FC900), reinterpret<f64>(0xBC808072087B8B1C),\n  reinterpret<f64>(0x3FE7EFFFE9261A76), reinterpret<f64>(0x3C8DC0286D9DF9AE),\n  reinterpret<f64>(0x3FE81000049CA3E8), reinterpret<f64>(0x3C897FD251E54C33),\n  reinterpret<f64>(0x3FE8300017932C8F), reinterpret<f64>(0xBC8AFEE9B630F381),\n  reinterpret<f64>(0x3FE850000633739C), reinterpret<f64>(0x3C89BFBF6B6535BC),\n  reinterpret<f64>(0x3FE87000204289C6), reinterpret<f64>(0xBC8BBF65F3117B75),\n  reinterpret<f64>(0x3FE88FFFEBF57904), reinterpret<f64>(0xBC89006EA23DCB57),\n  reinterpret<f64>(0x3FE8B00022BC04DF), reinterpret<f64>(0xBC7D00DF38E04B0A),\n  reinterpret<f64>(0x3FE8CFFFE50C1B8A), reinterpret<f64>(0xBC88007146FF9F05),\n  reinterpret<f64>(0x3FE8EFFFFC918E43), reinterpret<f64>(0x3C83817BD07A7038),\n  reinterpret<f64>(0x3FE910001EFA5FC7), reinterpret<f64>(0x3C893E9176DFB403),\n  reinterpret<f64>(0x3FE9300013467BB9), reinterpret<f64>(0x3C7F804E4B980276),\n  reinterpret<f64>(0x3FE94FFFE6EE076F), reinterpret<f64>(0xBC8F7EF0D9FF622E),\n  reinterpret<f64>(0x3FE96FFFDE3C12D1), reinterpret<f64>(0xBC7082AA962638BA),\n  reinterpret<f64>(0x3FE98FFFF4458A0D), reinterpret<f64>(0xBC87801B9164A8EF),\n  reinterpret<f64>(0x3FE9AFFFDD982E3E), reinterpret<f64>(0xBC8740E08A5A9337),\n  reinterpret<f64>(0x3FE9CFFFED49FB66), reinterpret<f64>(0x3C3FCE08C19BE000),\n  reinterpret<f64>(0x3FE9F00020F19C51), reinterpret<f64>(0xBC8A3FAA27885B0A),\n  reinterpret<f64>(0x3FEA10001145B006), reinterpret<f64>(0x3C74FF489958DA56),\n  reinterpret<f64>(0x3FEA300007BBF6FA), reinterpret<f64>(0x3C8CBEAB8A2B6D18),\n  reinterpret<f64>(0x3FEA500010971D79), reinterpret<f64>(0x3C88FECADD787930),\n  reinterpret<f64>(0x3FEA70001DF52E48), reinterpret<f64>(0xBC8F41763DD8ABDB),\n  reinterpret<f64>(0x3FEA90001C593352), reinterpret<f64>(0xBC8EBF0284C27612),\n  reinterpret<f64>(0x3FEAB0002A4F3E4B), reinterpret<f64>(0xBC69FD043CFF3F5F),\n  reinterpret<f64>(0x3FEACFFFD7AE1ED1), reinterpret<f64>(0xBC823EE7129070B4),\n  reinterpret<f64>(0x3FEAEFFFEE510478), reinterpret<f64>(0x3C6A063EE00EDEA3),\n  reinterpret<f64>(0x3FEB0FFFDB650D5B), reinterpret<f64>(0x3C5A06C8381F0AB9),\n  reinterpret<f64>(0x3FEB2FFFFEAACA57), reinterpret<f64>(0xBC79011E74233C1D),\n  reinterpret<f64>(0x3FEB4FFFD995BADC), reinterpret<f64>(0xBC79FF1068862A9F),\n  reinterpret<f64>(0x3FEB7000249E659C), reinterpret<f64>(0x3C8AFF45D0864F3E),\n  reinterpret<f64>(0x3FEB8FFFF9871640), reinterpret<f64>(0x3C7CFE7796C2C3F9),\n  reinterpret<f64>(0x3FEBAFFFD204CB4F), reinterpret<f64>(0xBC63FF27EEF22BC4),\n  reinterpret<f64>(0x3FEBCFFFD2415C45), reinterpret<f64>(0xBC6CFFB7EE3BEA21),\n  reinterpret<f64>(0x3FEBEFFFF86309DF), reinterpret<f64>(0xBC814103972E0B5C),\n  reinterpret<f64>(0x3FEC0FFFE1B57653), reinterpret<f64>(0x3C8BC16494B76A19),\n  reinterpret<f64>(0x3FEC2FFFF1FA57E3), reinterpret<f64>(0xBC64FEEF8D30C6ED),\n  reinterpret<f64>(0x3FEC4FFFDCBFE424), reinterpret<f64>(0xBC843F68BCEC4775),\n  reinterpret<f64>(0x3FEC6FFFED54B9F7), reinterpret<f64>(0x3C847EA3F053E0EC),\n  reinterpret<f64>(0x3FEC8FFFEB998FD5), reinterpret<f64>(0x3C7383068DF992F1),\n  reinterpret<f64>(0x3FECB0002125219A), reinterpret<f64>(0xBC68FD8E64180E04),\n  reinterpret<f64>(0x3FECCFFFDD94469C), reinterpret<f64>(0x3C8E7EBE1CC7EA72),\n  reinterpret<f64>(0x3FECEFFFEAFDC476), reinterpret<f64>(0x3C8EBE39AD9F88FE),\n  reinterpret<f64>(0x3FED1000169AF82B), reinterpret<f64>(0x3C757D91A8B95A71),\n  reinterpret<f64>(0x3FED30000D0FF71D), reinterpret<f64>(0x3C89C1906970C7DA),\n  reinterpret<f64>(0x3FED4FFFEA790FC4), reinterpret<f64>(0xBC580E37C558FE0C),\n  reinterpret<f64>(0x3FED70002EDC87E5), reinterpret<f64>(0xBC7F80D64DC10F44),\n  reinterpret<f64>(0x3FED900021DC82AA), reinterpret<f64>(0xBC747C8F94FD5C5C),\n  reinterpret<f64>(0x3FEDAFFFD86B0283), reinterpret<f64>(0x3C8C7F1DC521617E),\n  reinterpret<f64>(0x3FEDD000296C4739), reinterpret<f64>(0x3C88019EB2FFB153),\n  reinterpret<f64>(0x3FEDEFFFE54490F5), reinterpret<f64>(0x3C6E00D2C652CC89),\n  reinterpret<f64>(0x3FEE0FFFCDABF694), reinterpret<f64>(0xBC7F8340202D69D2),\n  reinterpret<f64>(0x3FEE2FFFDB52C8DD), reinterpret<f64>(0x3C7B00C1CA1B0864),\n  reinterpret<f64>(0x3FEE4FFFF24216EF), reinterpret<f64>(0x3C72FFA8B094AB51),\n  reinterpret<f64>(0x3FEE6FFFE88A5E11), reinterpret<f64>(0xBC57F673B1EFBE59),\n  reinterpret<f64>(0x3FEE9000119EFF0D), reinterpret<f64>(0xBC84808D5E0BC801),\n  reinterpret<f64>(0x3FEEAFFFDFA51744), reinterpret<f64>(0x3C780006D54320B5),\n  reinterpret<f64>(0x3FEED0001A127FA1), reinterpret<f64>(0xBC5002F860565C92),\n  reinterpret<f64>(0x3FEEF00007BABCC4), reinterpret<f64>(0xBC8540445D35E611),\n  reinterpret<f64>(0x3FEF0FFFF57A8D02), reinterpret<f64>(0xBC4FFB3139EF9105),\n  reinterpret<f64>(0x3FEF30001EE58AC7), reinterpret<f64>(0x3C8A81ACF2731155),\n  reinterpret<f64>(0x3FEF4FFFF5823494), reinterpret<f64>(0x3C8A3F41D4D7C743),\n  reinterpret<f64>(0x3FEF6FFFFCA94C6B), reinterpret<f64>(0xBC6202F41C987875),\n  reinterpret<f64>(0x3FEF8FFFE1F9C441), reinterpret<f64>(0x3C777DD1F477E74B),\n  reinterpret<f64>(0x3FEFAFFFD2E0E37E), reinterpret<f64>(0xBC6F01199A7CA331),\n  reinterpret<f64>(0x3FEFD0001C77E49E), reinterpret<f64>(0x3C7181EE4BCEACB1),\n  reinterpret<f64>(0x3FEFEFFFF7E0C331), reinterpret<f64>(0xBC6E05370170875A),\n  reinterpret<f64>(0x3FF00FFFF465606E), reinterpret<f64>(0xBC8A7EAD491C0ADA),\n  reinterpret<f64>(0x3FF02FFFF3867A58), reinterpret<f64>(0xBC977F69C3FCB2E0),\n  reinterpret<f64>(0x3FF04FFFFDFC0D17), reinterpret<f64>(0x3C97BFFE34CB945B),\n  reinterpret<f64>(0x3FF0700003CD4D82), reinterpret<f64>(0x3C820083C0E456CB),\n  reinterpret<f64>(0x3FF08FFFF9F2CBE8), reinterpret<f64>(0xBC6DFFDFBE37751A),\n  reinterpret<f64>(0x3FF0B000010CDA65), reinterpret<f64>(0xBC913F7FAEE626EB),\n  reinterpret<f64>(0x3FF0D00001A4D338), reinterpret<f64>(0x3C807DFA79489FF7),\n  reinterpret<f64>(0x3FF0EFFFFADAFDFD), reinterpret<f64>(0xBC77040570D66BC0),\n  reinterpret<f64>(0x3FF110000BBAFD96), reinterpret<f64>(0x3C8E80D4846D0B62),\n  reinterpret<f64>(0x3FF12FFFFAE5F45D), reinterpret<f64>(0x3C9DBFFA64FD36EF),\n  reinterpret<f64>(0x3FF150000DD59AD9), reinterpret<f64>(0x3C9A0077701250AE),\n  reinterpret<f64>(0x3FF170000F21559A), reinterpret<f64>(0x3C8DFDF9E2E3DEEE),\n  reinterpret<f64>(0x3FF18FFFFC275426), reinterpret<f64>(0x3C910030DC3B7273),\n  reinterpret<f64>(0x3FF1B000123D3C59), reinterpret<f64>(0x3C997F7980030188),\n  reinterpret<f64>(0x3FF1CFFFF8299EB7), reinterpret<f64>(0xBC65F932AB9F8C67),\n  reinterpret<f64>(0x3FF1EFFFF48AD400), reinterpret<f64>(0x3C937FBF9DA75BEB),\n  reinterpret<f64>(0x3FF210000C8B86A4), reinterpret<f64>(0x3C9F806B91FD5B22),\n  reinterpret<f64>(0x3FF2300003854303), reinterpret<f64>(0x3C93FFC2EB9FBF33),\n  reinterpret<f64>(0x3FF24FFFFFBCF684), reinterpret<f64>(0x3C7601E77E2E2E72),\n  reinterpret<f64>(0x3FF26FFFF52921D9), reinterpret<f64>(0x3C7FFCBB767F0C61),\n  reinterpret<f64>(0x3FF2900014933A3C), reinterpret<f64>(0xBC7202CA3C02412B),\n  reinterpret<f64>(0x3FF2B00014556313), reinterpret<f64>(0xBC92808233F21F02),\n  reinterpret<f64>(0x3FF2CFFFEBFE523B), reinterpret<f64>(0xBC88FF7E384FDCF2),\n  reinterpret<f64>(0x3FF2F0000BB8AD96), reinterpret<f64>(0xBC85FF51503041C5),\n  reinterpret<f64>(0x3FF30FFFFB7AE2AF), reinterpret<f64>(0xBC810071885E289D),\n  reinterpret<f64>(0x3FF32FFFFEAC5F7F), reinterpret<f64>(0xBC91FF5D3FB7B715),\n  reinterpret<f64>(0x3FF350000CA66756), reinterpret<f64>(0x3C957F82228B82BD),\n  reinterpret<f64>(0x3FF3700011FBF721), reinterpret<f64>(0x3C8000BAC40DD5CC),\n  reinterpret<f64>(0x3FF38FFFF9592FB9), reinterpret<f64>(0xBC943F9D2DB2A751),\n  reinterpret<f64>(0x3FF3B00004DDD242), reinterpret<f64>(0x3C857F6B707638E1),\n  reinterpret<f64>(0x3FF3CFFFF5B2C957), reinterpret<f64>(0x3C7A023A10BF1231),\n  reinterpret<f64>(0x3FF3EFFFEAB0B418), reinterpret<f64>(0x3C987F6D66B152B0),\n  reinterpret<f64>(0x3FF410001532AFF4), reinterpret<f64>(0x3C67F8375F198524),\n  reinterpret<f64>(0x3FF4300017478B29), reinterpret<f64>(0x3C8301E672DC5143),\n  reinterpret<f64>(0x3FF44FFFE795B463), reinterpret<f64>(0x3C89FF69B8B2895A),\n  reinterpret<f64>(0x3FF46FFFE80475E0), reinterpret<f64>(0xBC95C0B19BC2F254),\n  reinterpret<f64>(0x3FF48FFFEF6FC1E7), reinterpret<f64>(0x3C9B4009F23A2A72),\n  reinterpret<f64>(0x3FF4AFFFE5BEA704), reinterpret<f64>(0xBC94FFB7BF0D7D45),\n  reinterpret<f64>(0x3FF4D000171027DE), reinterpret<f64>(0xBC99C06471DC6A3D),\n  reinterpret<f64>(0x3FF4F0000FF03EE2), reinterpret<f64>(0x3C977F890B85531C),\n  reinterpret<f64>(0x3FF5100012DC4BD1), reinterpret<f64>(0x3C6004657166A436),\n  reinterpret<f64>(0x3FF530001605277A), reinterpret<f64>(0xBC96BFCECE233209),\n  reinterpret<f64>(0x3FF54FFFECDB704C), reinterpret<f64>(0xBC8902720505A1D7),\n  reinterpret<f64>(0x3FF56FFFEF5F54A9), reinterpret<f64>(0x3C9BBFE60EC96412),\n  reinterpret<f64>(0x3FF5900017E61012), reinterpret<f64>(0x3C887EC581AFEF90),\n  reinterpret<f64>(0x3FF5B00003C93E92), reinterpret<f64>(0xBC9F41080ABF0CC0),\n  reinterpret<f64>(0x3FF5D0001D4919BC), reinterpret<f64>(0xBC98812AFB254729),\n  reinterpret<f64>(0x3FF5EFFFE7B87A89), reinterpret<f64>(0xBC947EB780ED6904)\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function log_lut(x: f64): f64 {\n  const N_MASK = (1 << LOG_TABLE_BITS) - 1;\n\n  const\n    B0  = reinterpret<f64>(0xBFE0000000000000), // -0x1p-1\n    B1  = reinterpret<f64>(0x3FD5555555555577), //  0x1.5555555555577p-2\n    B2  = reinterpret<f64>(0xBFCFFFFFFFFFFDCB), // -0x1.ffffffffffdcbp-3\n    B3  = reinterpret<f64>(0x3FC999999995DD0C), //  0x1.999999995dd0cp-3\n    B4  = reinterpret<f64>(0xBFC55555556745A7), // -0x1.55555556745a7p-3\n    B5  = reinterpret<f64>(0x3FC24924A344DE30), //  0x1.24924a344de3p-3\n    B6  = reinterpret<f64>(0xBFBFFFFFA4423D65), // -0x1.fffffa4423d65p-4\n    B7  = reinterpret<f64>(0x3FBC7184282AD6CA), //  0x1.c7184282ad6cap-4\n    B8  = reinterpret<f64>(0xBFB999EB43B068FF), // -0x1.999eb43b068ffp-4\n    B9  = reinterpret<f64>(0x3FB78182F7AFD085), //  0x1.78182f7afd085p-4\n    B10 = reinterpret<f64>(0xBFB5521375D145CD); // -0x1.5521375d145cdp-4\n\n  const\n    A0 = reinterpret<f64>(0xBFE0000000000001),  // -0x1.0000000000001p-1\n    A1 = reinterpret<f64>(0x3FD555555551305B),  //  0x1.555555551305bp-2\n    A2 = reinterpret<f64>(0xBFCFFFFFFFEB4590),  // -0x1.fffffffeb459p-3\n    A3 = reinterpret<f64>(0x3FC999B324F10111),  //  0x1.999b324f10111p-3\n    A4 = reinterpret<f64>(0xBFC55575E506C89F);  // -0x1.55575e506c89fp-3\n\n  const\n    LO: u64 = 0x3FEE000000000000,\n    HI: u64 = 0x3FF1090000000000;\n\n  const\n    Ln2hi  = reinterpret<f64>(0x3FE62E42FEFA3800), // 0x1.62e42fefa3800p-1\n    Ln2lo  = reinterpret<f64>(0x3D2EF35793C76730), // 0x1.ef35793c76730p-45\n    Ox1p27 = reinterpret<f64>(0x41A0000000000000), // 0x1p27\n    Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  var ix = reinterpret<u64>(x);\n  if (ix - LO < HI - LO) {\n    let r  = x - 1.0;\n    let r2 = r * r;\n    let r3 = r2 * r;\n    let y =\n      r3 * (B1 + r * B2 + r2 * B3 +\n      r3 * (B4 + r * B5 + r2 * B6 +\n      r3 * (B7 + r * B8 + r2 * B9 + r3 * B10)));\n    // Worst-case error is around 0.507 ULP\n    let w   = r * Ox1p27;\n    let rhi = r + w - w;\n    let rlo = r - rhi;\n    w = rhi * rhi * B0; // B[0] == -0.5\n    let hi = r + w;\n    let lo = r - hi + w;\n    lo += B0 * rlo * (rhi + r);\n    return y + lo + hi;\n  }\n  var top = u32(ix >> 48);\n  if (top - 0x0010 >= 0x7FF0 - 0x0010) {\n    // x < 0x1p-1022 or inf or nan\n    if ((ix << 1) == 0) return -1.0 / (x * x);\n    if (ix == reinterpret<u64>(Infinity)) return x; // log(inf) == inf\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\n    // x is subnormal, normalize it\n    ix = reinterpret<u64>(x * Ox1p52);\n    ix -= u64(52) << 52;\n  }\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp  = ix - 0x3FE6000000000000;\n  var i    = <usize>((tmp >> (52 - LOG_TABLE_BITS)) & N_MASK);\n  var k    = <i64>tmp >> 52;\n  var iz   = ix - (tmp & (u64(0xFFF) << 52));\n\n  var invc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\n  var logc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\n  var z    = reinterpret<f64>(iz);\n\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2.\n  // r ~= z/c - 1, |r| < 1/(2*N)\n  // #if __FP_FAST_FMA\n  // \t// rounding error: 0x1p-55/N\n  // \tr = __builtin_fma(z, invc, -1.0);\n  // #else\n  // rounding error: 0x1p-55/N + 0x1p-66\n  const chi = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T2[i].chi\n  const clo = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T2[i].clo\n  var r = (z - chi - clo) * invc;\n  // #endif\n  var kd = <f64>k;\n\n  // hi + lo = r + log(c) + k*Ln2\n  var w  = kd * Ln2hi + logc;\n  var hi = w + r;\n  var lo = w - hi + r + kd * Ln2lo;\n\n  // log(x) = lo + (log1p(r) - r) + hi\n  var r2 = r * r; // rounding error: 0x1p-54/N^2\n  // Worst case error if |y| > 0x1p-5:\n  // 0.5 + 4.13/N + abs-poly-error*2^57 ULP (+ 0.002 ULP without fma)\n  // Worst case error if |y| > 0x1p-4:\n  // 0.5 + 2.06/N + abs-poly-error*2^56 ULP (+ 0.001 ULP without fma).\n  return lo + r2 * A0 + r * r2 * (A1 + r * A2 + r2 * (A3 + r * A4)) + hi;\n}\n\n//\n// Lookup data for pow. See: https://git.musl-libc.org/cgit/musl/tree/src/math/pow.c\n//\n\n// @ts-ignore: decorator\n@inline const POW_LOG_TABLE_BITS = 7;\n\n/* Algorithm:\n\n  x = 2^k z\n  log(x) = k ln2 + log(c) + log(z/c)\n  log(z/c) = poly(z/c - 1)\n\nwhere z is in [0x1.69555p-1; 0x1.69555p0] which is split into N subintervals\nand z falls into the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = round(0x1p43*log(c))/0x1p43\n  tab[i].logctail = (double)(log(c) - logc)\n\nwhere c is chosen near the center of the subinterval such that 1/c has only a\nfew precision bits so z/c - 1 is exactly representible as double:\n\n  1/c = center < 1 ? round(N/center)/N : round(2*N/center)/N/2\n\nNote: |z/c - 1| < 1/N for the chosen c, |log(c) - logc - logctail| < 0x1p-97,\nthe last few bits of logc are rounded away so k*ln2hi + logc has no rounding\nerror and the interval for z is selected such that near x == 1, where log(x)\nis tiny, large cancellation error is avoided in logc + poly(z/c - 1). */\n\n// @ts-ignore: decorator\n@lazy @inline const POW_LOG_DATA_TAB = memory.data<f64>([\n  //             invc                 ,pad,               logc                 ,               logctail\n  reinterpret<f64>(0x3FF6A00000000000), 0, reinterpret<f64>(0xBFD62C82F2B9C800), reinterpret<f64>(0x3CFAB42428375680),\n  reinterpret<f64>(0x3FF6800000000000), 0, reinterpret<f64>(0xBFD5D1BDBF580800), reinterpret<f64>(0xBD1CA508D8E0F720),\n  reinterpret<f64>(0x3FF6600000000000), 0, reinterpret<f64>(0xBFD5767717455800), reinterpret<f64>(0xBD2362A4D5B6506D),\n  reinterpret<f64>(0x3FF6400000000000), 0, reinterpret<f64>(0xBFD51AAD872DF800), reinterpret<f64>(0xBCE684E49EB067D5),\n  reinterpret<f64>(0x3FF6200000000000), 0, reinterpret<f64>(0xBFD4BE5F95777800), reinterpret<f64>(0xBD041B6993293EE0),\n  reinterpret<f64>(0x3FF6000000000000), 0, reinterpret<f64>(0xBFD4618BC21C6000), reinterpret<f64>(0x3D13D82F484C84CC),\n  reinterpret<f64>(0x3FF5E00000000000), 0, reinterpret<f64>(0xBFD404308686A800), reinterpret<f64>(0x3CDC42F3ED820B3A),\n  reinterpret<f64>(0x3FF5C00000000000), 0, reinterpret<f64>(0xBFD3A64C55694800), reinterpret<f64>(0x3D20B1C686519460),\n  reinterpret<f64>(0x3FF5A00000000000), 0, reinterpret<f64>(0xBFD347DD9A988000), reinterpret<f64>(0x3D25594DD4C58092),\n  reinterpret<f64>(0x3FF5800000000000), 0, reinterpret<f64>(0xBFD2E8E2BAE12000), reinterpret<f64>(0x3D267B1E99B72BD8),\n  reinterpret<f64>(0x3FF5600000000000), 0, reinterpret<f64>(0xBFD2895A13DE8800), reinterpret<f64>(0x3D15CA14B6CFB03F),\n  reinterpret<f64>(0x3FF5600000000000), 0, reinterpret<f64>(0xBFD2895A13DE8800), reinterpret<f64>(0x3D15CA14B6CFB03F),\n  reinterpret<f64>(0x3FF5400000000000), 0, reinterpret<f64>(0xBFD22941FBCF7800), reinterpret<f64>(0xBD165A242853DA76),\n  reinterpret<f64>(0x3FF5200000000000), 0, reinterpret<f64>(0xBFD1C898C1699800), reinterpret<f64>(0xBD1FAFBC68E75404),\n  reinterpret<f64>(0x3FF5000000000000), 0, reinterpret<f64>(0xBFD1675CABABA800), reinterpret<f64>(0x3D1F1FC63382A8F0),\n  reinterpret<f64>(0x3FF4E00000000000), 0, reinterpret<f64>(0xBFD1058BF9AE4800), reinterpret<f64>(0xBD26A8C4FD055A66),\n  reinterpret<f64>(0x3FF4C00000000000), 0, reinterpret<f64>(0xBFD0A324E2739000), reinterpret<f64>(0xBD0C6BEE7EF4030E),\n  reinterpret<f64>(0x3FF4A00000000000), 0, reinterpret<f64>(0xBFD0402594B4D000), reinterpret<f64>(0xBCF036B89EF42D7F),\n  reinterpret<f64>(0x3FF4A00000000000), 0, reinterpret<f64>(0xBFD0402594B4D000), reinterpret<f64>(0xBCF036B89EF42D7F),\n  reinterpret<f64>(0x3FF4800000000000), 0, reinterpret<f64>(0xBFCFB9186D5E4000), reinterpret<f64>(0x3D0D572AAB993C87),\n  reinterpret<f64>(0x3FF4600000000000), 0, reinterpret<f64>(0xBFCEF0ADCBDC6000), reinterpret<f64>(0x3D2B26B79C86AF24),\n  reinterpret<f64>(0x3FF4400000000000), 0, reinterpret<f64>(0xBFCE27076E2AF000), reinterpret<f64>(0xBD172F4F543FFF10),\n  reinterpret<f64>(0x3FF4200000000000), 0, reinterpret<f64>(0xBFCD5C216B4FC000), reinterpret<f64>(0x3D21BA91BBCA681B),\n  reinterpret<f64>(0x3FF4000000000000), 0, reinterpret<f64>(0xBFCC8FF7C79AA000), reinterpret<f64>(0x3D27794F689F8434),\n  reinterpret<f64>(0x3FF4000000000000), 0, reinterpret<f64>(0xBFCC8FF7C79AA000), reinterpret<f64>(0x3D27794F689F8434),\n  reinterpret<f64>(0x3FF3E00000000000), 0, reinterpret<f64>(0xBFCBC286742D9000), reinterpret<f64>(0x3D194EB0318BB78F),\n  reinterpret<f64>(0x3FF3C00000000000), 0, reinterpret<f64>(0xBFCAF3C94E80C000), reinterpret<f64>(0x3CBA4E633FCD9066),\n  reinterpret<f64>(0x3FF3A00000000000), 0, reinterpret<f64>(0xBFCA23BC1FE2B000), reinterpret<f64>(0xBD258C64DC46C1EA),\n  reinterpret<f64>(0x3FF3A00000000000), 0, reinterpret<f64>(0xBFCA23BC1FE2B000), reinterpret<f64>(0xBD258C64DC46C1EA),\n  reinterpret<f64>(0x3FF3800000000000), 0, reinterpret<f64>(0xBFC9525A9CF45000), reinterpret<f64>(0xBD2AD1D904C1D4E3),\n  reinterpret<f64>(0x3FF3600000000000), 0, reinterpret<f64>(0xBFC87FA06520D000), reinterpret<f64>(0x3D2BBDBF7FDBFA09),\n  reinterpret<f64>(0x3FF3400000000000), 0, reinterpret<f64>(0xBFC7AB890210E000), reinterpret<f64>(0x3D2BDB9072534A58),\n  reinterpret<f64>(0x3FF3400000000000), 0, reinterpret<f64>(0xBFC7AB890210E000), reinterpret<f64>(0x3D2BDB9072534A58),\n  reinterpret<f64>(0x3FF3200000000000), 0, reinterpret<f64>(0xBFC6D60FE719D000), reinterpret<f64>(0xBD10E46AA3B2E266),\n  reinterpret<f64>(0x3FF3000000000000), 0, reinterpret<f64>(0xBFC5FF3070A79000), reinterpret<f64>(0xBD1E9E439F105039),\n  reinterpret<f64>(0x3FF3000000000000), 0, reinterpret<f64>(0xBFC5FF3070A79000), reinterpret<f64>(0xBD1E9E439F105039),\n  reinterpret<f64>(0x3FF2E00000000000), 0, reinterpret<f64>(0xBFC526E5E3A1B000), reinterpret<f64>(0xBD20DE8B90075B8F),\n  reinterpret<f64>(0x3FF2C00000000000), 0, reinterpret<f64>(0xBFC44D2B6CCB8000), reinterpret<f64>(0x3D170CC16135783C),\n  reinterpret<f64>(0x3FF2C00000000000), 0, reinterpret<f64>(0xBFC44D2B6CCB8000), reinterpret<f64>(0x3D170CC16135783C),\n  reinterpret<f64>(0x3FF2A00000000000), 0, reinterpret<f64>(0xBFC371FC201E9000), reinterpret<f64>(0x3CF178864D27543A),\n  reinterpret<f64>(0x3FF2800000000000), 0, reinterpret<f64>(0xBFC29552F81FF000), reinterpret<f64>(0xBD248D301771C408),\n  reinterpret<f64>(0x3FF2600000000000), 0, reinterpret<f64>(0xBFC1B72AD52F6000), reinterpret<f64>(0xBD2E80A41811A396),\n  reinterpret<f64>(0x3FF2600000000000), 0, reinterpret<f64>(0xBFC1B72AD52F6000), reinterpret<f64>(0xBD2E80A41811A396),\n  reinterpret<f64>(0x3FF2400000000000), 0, reinterpret<f64>(0xBFC0D77E7CD09000), reinterpret<f64>(0x3D0A699688E85BF4),\n  reinterpret<f64>(0x3FF2400000000000), 0, reinterpret<f64>(0xBFC0D77E7CD09000), reinterpret<f64>(0x3D0A699688E85BF4),\n  reinterpret<f64>(0x3FF2200000000000), 0, reinterpret<f64>(0xBFBFEC9131DBE000), reinterpret<f64>(0xBD2575545CA333F2),\n  reinterpret<f64>(0x3FF2000000000000), 0, reinterpret<f64>(0xBFBE27076E2B0000), reinterpret<f64>(0x3D2A342C2AF0003C),\n  reinterpret<f64>(0x3FF2000000000000), 0, reinterpret<f64>(0xBFBE27076E2B0000), reinterpret<f64>(0x3D2A342C2AF0003C),\n  reinterpret<f64>(0x3FF1E00000000000), 0, reinterpret<f64>(0xBFBC5E548F5BC000), reinterpret<f64>(0xBD1D0C57585FBE06),\n  reinterpret<f64>(0x3FF1C00000000000), 0, reinterpret<f64>(0xBFBA926D3A4AE000), reinterpret<f64>(0x3D253935E85BAAC8),\n  reinterpret<f64>(0x3FF1C00000000000), 0, reinterpret<f64>(0xBFBA926D3A4AE000), reinterpret<f64>(0x3D253935E85BAAC8),\n  reinterpret<f64>(0x3FF1A00000000000), 0, reinterpret<f64>(0xBFB8C345D631A000), reinterpret<f64>(0x3D137C294D2F5668),\n  reinterpret<f64>(0x3FF1A00000000000), 0, reinterpret<f64>(0xBFB8C345D631A000), reinterpret<f64>(0x3D137C294D2F5668),\n  reinterpret<f64>(0x3FF1800000000000), 0, reinterpret<f64>(0xBFB6F0D28AE56000), reinterpret<f64>(0xBD269737C93373DA),\n  reinterpret<f64>(0x3FF1600000000000), 0, reinterpret<f64>(0xBFB51B073F062000), reinterpret<f64>(0x3D1F025B61C65E57),\n  reinterpret<f64>(0x3FF1600000000000), 0, reinterpret<f64>(0xBFB51B073F062000), reinterpret<f64>(0x3D1F025B61C65E57),\n  reinterpret<f64>(0x3FF1400000000000), 0, reinterpret<f64>(0xBFB341D7961BE000), reinterpret<f64>(0x3D2C5EDACCF913DF),\n  reinterpret<f64>(0x3FF1400000000000), 0, reinterpret<f64>(0xBFB341D7961BE000), reinterpret<f64>(0x3D2C5EDACCF913DF),\n  reinterpret<f64>(0x3FF1200000000000), 0, reinterpret<f64>(0xBFB16536EEA38000), reinterpret<f64>(0x3D147C5E768FA309),\n  reinterpret<f64>(0x3FF1000000000000), 0, reinterpret<f64>(0xBFAF0A30C0118000), reinterpret<f64>(0x3D2D599E83368E91),\n  reinterpret<f64>(0x3FF1000000000000), 0, reinterpret<f64>(0xBFAF0A30C0118000), reinterpret<f64>(0x3D2D599E83368E91),\n  reinterpret<f64>(0x3FF0E00000000000), 0, reinterpret<f64>(0xBFAB42DD71198000), reinterpret<f64>(0x3D1C827AE5D6704C),\n  reinterpret<f64>(0x3FF0E00000000000), 0, reinterpret<f64>(0xBFAB42DD71198000), reinterpret<f64>(0x3D1C827AE5D6704C),\n  reinterpret<f64>(0x3FF0C00000000000), 0, reinterpret<f64>(0xBFA77458F632C000), reinterpret<f64>(0xBD2CFC4634F2A1EE),\n  reinterpret<f64>(0x3FF0C00000000000), 0, reinterpret<f64>(0xBFA77458F632C000), reinterpret<f64>(0xBD2CFC4634F2A1EE),\n  reinterpret<f64>(0x3FF0A00000000000), 0, reinterpret<f64>(0xBFA39E87B9FEC000), reinterpret<f64>(0x3CF502B7F526FEAA),\n  reinterpret<f64>(0x3FF0A00000000000), 0, reinterpret<f64>(0xBFA39E87B9FEC000), reinterpret<f64>(0x3CF502B7F526FEAA),\n  reinterpret<f64>(0x3FF0800000000000), 0, reinterpret<f64>(0xBF9F829B0E780000), reinterpret<f64>(0xBD2980267C7E09E4),\n  reinterpret<f64>(0x3FF0800000000000), 0, reinterpret<f64>(0xBF9F829B0E780000), reinterpret<f64>(0xBD2980267C7E09E4),\n  reinterpret<f64>(0x3FF0600000000000), 0, reinterpret<f64>(0xBF97B91B07D58000), reinterpret<f64>(0xBD288D5493FAA639),\n  reinterpret<f64>(0x3FF0400000000000), 0, reinterpret<f64>(0xBF8FC0A8B0FC0000), reinterpret<f64>(0xBCDF1E7CF6D3A69C),\n  reinterpret<f64>(0x3FF0400000000000), 0, reinterpret<f64>(0xBF8FC0A8B0FC0000), reinterpret<f64>(0xBCDF1E7CF6D3A69C),\n  reinterpret<f64>(0x3FF0200000000000), 0, reinterpret<f64>(0xBF7FE02A6B100000), reinterpret<f64>(0xBD19E23F0DDA40E4),\n  reinterpret<f64>(0x3FF0200000000000), 0, reinterpret<f64>(0xBF7FE02A6B100000), reinterpret<f64>(0xBD19E23F0DDA40E4),\n  reinterpret<f64>(0x3FF0000000000000), 0, 0, 0,\n  reinterpret<f64>(0x3FF0000000000000), 0, 0, 0,\n  reinterpret<f64>(0x3FEFC00000000000), 0, reinterpret<f64>(0x3F80101575890000), reinterpret<f64>(0xBD10C76B999D2BE8),\n  reinterpret<f64>(0x3FEF800000000000), 0, reinterpret<f64>(0x3F90205658938000), reinterpret<f64>(0xBD23DC5B06E2F7D2),\n  reinterpret<f64>(0x3FEF400000000000), 0, reinterpret<f64>(0x3F98492528C90000), reinterpret<f64>(0xBD2AA0BA325A0C34),\n  reinterpret<f64>(0x3FEF000000000000), 0, reinterpret<f64>(0x3FA0415D89E74000), reinterpret<f64>(0x3D0111C05CF1D753),\n  reinterpret<f64>(0x3FEEC00000000000), 0, reinterpret<f64>(0x3FA466AED42E0000), reinterpret<f64>(0xBD2C167375BDFD28),\n  reinterpret<f64>(0x3FEE800000000000), 0, reinterpret<f64>(0x3FA894AA149FC000), reinterpret<f64>(0xBD197995D05A267D),\n  reinterpret<f64>(0x3FEE400000000000), 0, reinterpret<f64>(0x3FACCB73CDDDC000), reinterpret<f64>(0xBD1A68F247D82807),\n  reinterpret<f64>(0x3FEE200000000000), 0, reinterpret<f64>(0x3FAEEA31C006C000), reinterpret<f64>(0xBD0E113E4FC93B7B),\n  reinterpret<f64>(0x3FEDE00000000000), 0, reinterpret<f64>(0x3FB1973BD1466000), reinterpret<f64>(0xBD25325D560D9E9B),\n  reinterpret<f64>(0x3FEDA00000000000), 0, reinterpret<f64>(0x3FB3BDF5A7D1E000), reinterpret<f64>(0x3D2CC85EA5DB4ED7),\n  reinterpret<f64>(0x3FED600000000000), 0, reinterpret<f64>(0x3FB5E95A4D97A000), reinterpret<f64>(0xBD2C69063C5D1D1E),\n  reinterpret<f64>(0x3FED400000000000), 0, reinterpret<f64>(0x3FB700D30AEAC000), reinterpret<f64>(0x3CEC1E8DA99DED32),\n  reinterpret<f64>(0x3FED000000000000), 0, reinterpret<f64>(0x3FB9335E5D594000), reinterpret<f64>(0x3D23115C3ABD47DA),\n  reinterpret<f64>(0x3FECC00000000000), 0, reinterpret<f64>(0x3FBB6AC88DAD6000), reinterpret<f64>(0xBD1390802BF768E5),\n  reinterpret<f64>(0x3FECA00000000000), 0, reinterpret<f64>(0x3FBC885801BC4000), reinterpret<f64>(0x3D2646D1C65AACD3),\n  reinterpret<f64>(0x3FEC600000000000), 0, reinterpret<f64>(0x3FBEC739830A2000), reinterpret<f64>(0xBD2DC068AFE645E0),\n  reinterpret<f64>(0x3FEC400000000000), 0, reinterpret<f64>(0x3FBFE89139DBE000), reinterpret<f64>(0xBD2534D64FA10AFD),\n  reinterpret<f64>(0x3FEC000000000000), 0, reinterpret<f64>(0x3FC1178E8227E000), reinterpret<f64>(0x3D21EF78CE2D07F2),\n  reinterpret<f64>(0x3FEBE00000000000), 0, reinterpret<f64>(0x3FC1AA2B7E23F000), reinterpret<f64>(0x3D2CA78E44389934),\n  reinterpret<f64>(0x3FEBA00000000000), 0, reinterpret<f64>(0x3FC2D1610C868000), reinterpret<f64>(0x3D039D6CCB81B4A1),\n  reinterpret<f64>(0x3FEB800000000000), 0, reinterpret<f64>(0x3FC365FCB0159000), reinterpret<f64>(0x3CC62FA8234B7289),\n  reinterpret<f64>(0x3FEB400000000000), 0, reinterpret<f64>(0x3FC4913D8333B000), reinterpret<f64>(0x3D25837954FDB678),\n  reinterpret<f64>(0x3FEB200000000000), 0, reinterpret<f64>(0x3FC527E5E4A1B000), reinterpret<f64>(0x3D2633E8E5697DC7),\n  reinterpret<f64>(0x3FEAE00000000000), 0, reinterpret<f64>(0x3FC6574EBE8C1000), reinterpret<f64>(0x3D19CF8B2C3C2E78),\n  reinterpret<f64>(0x3FEAC00000000000), 0, reinterpret<f64>(0x3FC6F0128B757000), reinterpret<f64>(0xBD25118DE59C21E1),\n  reinterpret<f64>(0x3FEAA00000000000), 0, reinterpret<f64>(0x3FC7898D85445000), reinterpret<f64>(0xBD1C661070914305),\n  reinterpret<f64>(0x3FEA600000000000), 0, reinterpret<f64>(0x3FC8BEAFEB390000), reinterpret<f64>(0xBD073D54AAE92CD1),\n  reinterpret<f64>(0x3FEA400000000000), 0, reinterpret<f64>(0x3FC95A5ADCF70000), reinterpret<f64>(0x3D07F22858A0FF6F),\n  reinterpret<f64>(0x3FEA000000000000), 0, reinterpret<f64>(0x3FCA93ED3C8AE000), reinterpret<f64>(0xBD28724350562169),\n  reinterpret<f64>(0x3FE9E00000000000), 0, reinterpret<f64>(0x3FCB31D8575BD000), reinterpret<f64>(0xBD0C358D4EACE1AA),\n  reinterpret<f64>(0x3FE9C00000000000), 0, reinterpret<f64>(0x3FCBD087383BE000), reinterpret<f64>(0xBD2D4BC4595412B6),\n  reinterpret<f64>(0x3FE9A00000000000), 0, reinterpret<f64>(0x3FCC6FFBC6F01000), reinterpret<f64>(0xBCF1EC72C5962BD2),\n  reinterpret<f64>(0x3FE9600000000000), 0, reinterpret<f64>(0x3FCDB13DB0D49000), reinterpret<f64>(0xBD2AFF2AF715B035),\n  reinterpret<f64>(0x3FE9400000000000), 0, reinterpret<f64>(0x3FCE530EFFE71000), reinterpret<f64>(0x3CC212276041F430),\n  reinterpret<f64>(0x3FE9200000000000), 0, reinterpret<f64>(0x3FCEF5ADE4DD0000), reinterpret<f64>(0xBCCA211565BB8E11),\n  reinterpret<f64>(0x3FE9000000000000), 0, reinterpret<f64>(0x3FCF991C6CB3B000), reinterpret<f64>(0x3D1BCBECCA0CDF30),\n  reinterpret<f64>(0x3FE8C00000000000), 0, reinterpret<f64>(0x3FD07138604D5800), reinterpret<f64>(0x3CF89CDB16ED4E91),\n  reinterpret<f64>(0x3FE8A00000000000), 0, reinterpret<f64>(0x3FD0C42D67616000), reinterpret<f64>(0x3D27188B163CEAE9),\n  reinterpret<f64>(0x3FE8800000000000), 0, reinterpret<f64>(0x3FD1178E8227E800), reinterpret<f64>(0xBD2C210E63A5F01C),\n  reinterpret<f64>(0x3FE8600000000000), 0, reinterpret<f64>(0x3FD16B5CCBACF800), reinterpret<f64>(0x3D2B9ACDF7A51681),\n  reinterpret<f64>(0x3FE8400000000000), 0, reinterpret<f64>(0x3FD1BF99635A6800), reinterpret<f64>(0x3D2CA6ED5147BDB7),\n  reinterpret<f64>(0x3FE8200000000000), 0, reinterpret<f64>(0x3FD214456D0EB800), reinterpret<f64>(0x3D0A87DEBA46BAEA),\n  reinterpret<f64>(0x3FE7E00000000000), 0, reinterpret<f64>(0x3FD2BEF07CDC9000), reinterpret<f64>(0x3D2A9CFA4A5004F4),\n  reinterpret<f64>(0x3FE7C00000000000), 0, reinterpret<f64>(0x3FD314F1E1D36000), reinterpret<f64>(0xBD28E27AD3213CB8),\n  reinterpret<f64>(0x3FE7A00000000000), 0, reinterpret<f64>(0x3FD36B6776BE1000), reinterpret<f64>(0x3D116ECDB0F177C8),\n  reinterpret<f64>(0x3FE7800000000000), 0, reinterpret<f64>(0x3FD3C25277333000), reinterpret<f64>(0x3D183B54B606BD5C),\n  reinterpret<f64>(0x3FE7600000000000), 0, reinterpret<f64>(0x3FD419B423D5E800), reinterpret<f64>(0x3D08E436EC90E09D),\n  reinterpret<f64>(0x3FE7400000000000), 0, reinterpret<f64>(0x3FD4718DC271C800), reinterpret<f64>(0xBD2F27CE0967D675),\n  reinterpret<f64>(0x3FE7200000000000), 0, reinterpret<f64>(0x3FD4C9E09E173000), reinterpret<f64>(0xBD2E20891B0AD8A4),\n  reinterpret<f64>(0x3FE7000000000000), 0, reinterpret<f64>(0x3FD522AE0738A000), reinterpret<f64>(0x3D2EBE708164C759),\n  reinterpret<f64>(0x3FE6E00000000000), 0, reinterpret<f64>(0x3FD57BF753C8D000), reinterpret<f64>(0x3D1FADEDEE5D40EF),\n  reinterpret<f64>(0x3FE6C00000000000), 0, reinterpret<f64>(0x3FD5D5BDDF596000), reinterpret<f64>(0xBD0A0B2A08A465DC)\n]);\n\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\n// the bit representation of a non-zero finite floating-point value.\n// @ts-ignore: decorator\n@inline\nfunction checkint(iy: u64): i32 {\n  var e = iy >> 52 & 0x7FF;\n  if (e < 0x3FF     ) return 0;\n  if (e > 0x3FF + 52) return 2;\n  e = u64(1) << (0x3FF + 52 - e);\n  if (iy & (e - 1)) return 0;\n  if (iy &  e     ) return 1;\n  return 2;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction xflow(sign: u32, y: f64): f64 {\n  return select(-y, y, sign) * y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction uflow(sign: u32): f64 {\n  return xflow(sign, reinterpret<f64>(0x1000000000000000)); // 0x1p-767\n}\n\n// @ts-ignore: decorator\n@inline\nfunction oflow(sign: u32): f64 {\n  return xflow(sign, reinterpret<f64>(0x7000000000000000)); // 0x1p769\n}\n\n// Returns 1 if input is the bit representation of 0, infinity or nan.\n// @ts-ignore: decorator\n@inline\nfunction zeroinfnan(u: u64): bool {\n  return (u << 1) - 1 >= 0xFFE0000000000000 - 1;\n}\n\n// @ts-ignore: decorator\n@lazy var log_tail: f64 = 0;\n\n// Compute y+TAIL = log(x) where the rounded result is y and TAIL has about\n// additional 15 bits precision. IX is the bit representation of x, but\n// normalized in the subnormal range using the sign bit for the exponent.\n// @ts-ignore: decorator\n@inline\nfunction log_inline(ix: u64): f64 {\n  const N = 1 << POW_LOG_TABLE_BITS;\n  const N_MASK = N - 1;\n\n  const\n    Ln2hi = reinterpret<f64>(0x3FE62E42FEFA3800),\n    Ln2lo = reinterpret<f64>(0x3D2EF35793C76730);\n\n  const\n    A0 = reinterpret<f64>(0xBFE0000000000000),\n    A1 = reinterpret<f64>(0xBFE5555555555560),\n    A2 = reinterpret<f64>(0x3FE0000000000006),\n    A3 = reinterpret<f64>(0x3FE999999959554E),\n    A4 = reinterpret<f64>(0xBFE555555529A47A),\n    A5 = reinterpret<f64>(0xBFF2495B9B4845E9),\n    A6 = reinterpret<f64>(0x3FF0002B8B263FC3);\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp = ix - 0x3fE6955500000000;\n  var i   = <usize>((tmp >> (52 - POW_LOG_TABLE_BITS)) & N_MASK);\n  var k   = <i64>tmp >> 52;\n  var iz  = ix - (tmp & u64(0xFFF) << 52);\n  var z   = reinterpret<f64>(iz);\n  var kd  = <f64>k;\n\n  // log(x) = k*Ln2 + log(c) + log1p(z/c-1).\n  var invc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 0 << alignof<f64>()); // tab[i].invc\n  var logc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 2 << alignof<f64>()); // tab[i].logc\n  var logctail = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 3 << alignof<f64>()); // tab[i].logctail\n\n  // Note: 1/c is j/N or j/N/2 where j is an integer in [N,2N) and\n  // |z/c - 1| < 1/N, so r = z/c - 1 is exactly representible.\n  // Split z such that rhi, rlo and rhi*rhi are exact and |rlo| <= |r|.\n  var zhi = reinterpret<f64>((iz + u64(0x80000000)) & 0xFFFFFFFF00000000);\n  var zlo = z - zhi;\n  var rhi = zhi * invc - 1.0;\n  var rlo = zlo * invc;\n  var r   = rhi + rlo;\n\n  // k * Ln2 + log(c) + r.\n  var t1  = kd * Ln2hi + logc;\n  var t2  = t1 + r;\n  var lo1 = kd * Ln2lo + logctail;\n  var lo2 = t1 - t2 + r;\n\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  var ar  = A0 * r; // A[0] = -0.5\n  var ar2 = r * ar;\n  var ar3 = r * ar2;\n  // k * Ln2 + log(c) + r + A[0] * r * r.\n  var arhi  = A0  * rhi;\n  var arhi2 = rhi * arhi;\n  var hi    = t2  + arhi2;\n  var lo3   = rlo * (ar + arhi);\n  var lo4   = t2 - hi + arhi2;\n\n  // p = log1p(r) - r - A[0] * r * r.\n  var p  = ar3 * (A1 + r * A2 + ar2 * (A3 + r * A4 + ar2 * (A5 + r * A6)));\n  var lo = lo1 + lo2 + lo3 + lo4 + p;\n  var y  = hi + lo;\n  log_tail = hi - y + lo;\n\n  return y;\n}\n\n// @ts-ignore: decorator\n@inline const SIGN_BIAS = 0x800 << EXP_TABLE_BITS;\n\n// Computes sign*exp(x+xtail) where |xtail| < 2^-8/N and |xtail| <= |x|.\n// The sign_bias argument is SIGN_BIAS or 0 and sets the sign to -1 or 1.\n// @ts-ignore: decorator\n@inline\nfunction exp_inline(x: f64, xtail: f64, sign_bias: u32): f64 {\n  const N      = 1 << EXP_TABLE_BITS;\n  const N_MASK = N - 1;\n\n  const\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52\n\n  const\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\n\n  var abstop: u32;\n  var ki: u64, top: u64, sbits: u64;\n  var idx: usize;\n  // double_t for better performance on targets with FLT_EVAL_METHOD==2.\n  var kd: f64, z: f64, r: f64, r2: f64, scale: f64, tail: f64, tmp: f64;\n\n  var ux = reinterpret<u64>(x);\n  abstop = <u32>(ux >> 52) & 0x7FF;\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) {\n      // Avoid spurious underflow for tiny x.\n      // Note: 0 is common input.\n      return select(-1.0, 1.0, sign_bias);\n    }\n    if (abstop >= 0x409) { // top12(1024.0)\n      // Note: inf and nan are already handled.\n      return ux >> 63 ? uflow(sign_bias) : oflow(sign_bias);\n    }\n    // Large x is special cased below.\n    abstop = 0;\n  }\n\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)].\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N].\n  z = InvLn2N * x;\n\n  // #if TOINT_INTRINSICS\n  //   kd = roundtoint(z);\n  //   ki = converttoint(z);\n  // #elif EXP_USE_TOINT_NARROW\n  //   // z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\n  //   kd = eval_as_double(z + shift);\n  //   ki = asuint64(kd) >> 16;\n  //   kd = (double_t)(int32_t)ki;\n  // #else\n  // z - kd is in [-1, 1] in non-nearest rounding modes\n  kd  = z + shift;\n  ki  = reinterpret<u64>(kd);\n  kd -= shift;\n  // #endif\n  r = x + kd * NegLn2hiN + kd * NegLn2loN;\n  // The code assumes 2^-200 < |xtail| < 2^-8/N\n  r += xtail;\n  // 2^(k/N) ~= scale * (1 + tail)\n  idx = <usize>((ki & N_MASK) << 1);\n  top = (ki + sign_bias) << (52 - EXP_TABLE_BITS);\n\n  tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>())));\n  // This is only a valid scale when -1023*N < k < 1024*N\n  sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top;\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  r2 = r * r;\n  // Without fma the worst case error is 0.25/N ulp larger.\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp\n  tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\n  scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\n  // is no spurious underflow here even without fma.\n  return scale + scale * tmp;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function pow_lut(x: f64, y: f64): f64 {\n  const Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  var sign_bias: u32 = 0;\n  var ix = reinterpret<u64>(x);\n  var iy = reinterpret<u64>(y);\n  var topx = ix >> 52;\n  var topy = iy >> 52;\n\n  if (topx - 0x001 >= 0x7FF - 0x001 || (topy & 0x7FF) - 0x3BE >= 0x43e - 0x3BE) {\n    // Note: if |y| > 1075 * ln2 * 2^53 ~= 0x1.749p62 then pow(x,y) = inf/0\n    // and if |y| < 2^-54 / 1075 ~= 0x1.e7b6p-65 then pow(x,y) = +-1.\n    // Special cases: (x < 0x1p-126 or inf or nan) or\n    // (|y| < 0x1p-65 or |y| >= 0x1p63 or nan).\n    if (zeroinfnan(iy)) {\n      if ((iy << 1) == 0) return 1.0;\n      if (ix == 0x3FF0000000000000) return NaN; // original: 1.0\n      if ((ix << 1) > 0xFFE0000000000000 || (iy << 1) > 0xFFE0000000000000) return x + y;\n      if ((ix << 1) == 0x7FE0000000000000) return NaN; // original: 1.0\n      if (((ix << 1) < 0x7FE0000000000000) == !(iy >> 63)) return 0; // |x|<1 && y==inf or |x|>1 && y==-inf.\n      return y * y;\n    }\n    if (zeroinfnan(ix)) {\n      let x2 = x * x;\n      if (i32(ix >> 63) && checkint(iy) == 1) x2 = -x2;\n      return iy >> 63 ? 1 / x2 : x2;\n    }\n    // Here x and y are non-zero finite\n    if (ix >> 63) {\n      // Finite x < 0\n      let yint = checkint(iy);\n      if (yint == 0) return (x - x) / (x - x);\n      if (yint == 1) sign_bias = SIGN_BIAS;\n      ix   &= 0x7FFFFFFFFFFFFFFF;\n      topx &= 0x7FF;\n    }\n    if ((topy & 0x7FF) - 0x3BE >= 0x43E - 0x3BE) {\n      // Note: sign_bias == 0 here because y is not odd.\n      if (ix == 0x3FF0000000000000) return 1;\n      if ((topy & 0x7FF) < 0x3BE)   return 1; // |y| < 2^-65, x^y ~= 1 + y*log(x).\n      return (ix > 0x3FF0000000000000) == (topy < 0x800) ? Infinity : 0;\n    }\n    if (topx == 0) {\n      // Normalize subnormal x so exponent becomes negative.\n      ix = reinterpret<u64>(x * Ox1p52);\n      ix &= 0x7FFFFFFFFFFFFFFF;\n      ix -= u64(52) << 52;\n    }\n  }\n\n  var hi = log_inline(ix);\n  var lo = log_tail;\n  var ehi: f64, elo: f64;\n  // #if __FP_FAST_FMA\n  //   ehi = y * hi;\n  //   elo = y * lo + __builtin_fma(y, hi, -ehi);\n  // #else\n  var yhi = reinterpret<f64>(iy & 0xFFFFFFFFF8000000);\n  var ylo = y - yhi;\n  var lhi = reinterpret<f64>(reinterpret<u64>(hi) & 0xFFFFFFFFF8000000);\n  var llo = hi - lhi + lo;\n  ehi = yhi * lhi;\n  elo = ylo * lhi + y * llo; // |elo| < |ehi| * 2^-25.\n  // #endif\n  return exp_inline(ehi, elo, sign_bias);\n}\n","import { itoa32, utoa32, itoa64, utoa64, dtoa, itoa_buffered, dtoa_buffered, MAX_DOUBLE_LENGTH } from \"./number\";\nimport { ipow32 } from \"../math\";\n\n// All tables are stored as two staged lookup tables (static tries)\n// because the full range of Unicode symbols can't be efficiently\n// represented as-is in memory (see Unicode spec ch 5, p.196):\n// https://www.unicode.org/versions/Unicode12.0.0/ch05.pdf\n// Tables have been generated using these forked musl tools:\n// https://github.com/MaxGraey/musl-chartable-tools/tree/case-ignorable\n\n// Lookup table to check if a character is alphanumeric or not\n// See: https://git.musl-libc.org/cgit/musl/tree/src/ctype/alpha.h\n// size: 3904 bytes\n// @ts-ignore\n@inline @lazy const ALPHA_TABLE = memory.data<u8>([\n  18,17,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,17,34,35,36,17,37,38,39,40,\n  41,42,43,44,17,45,46,47,16,16,48,16,16,16,16,16,16,16,49,50,51,16,52,53,16,16,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,54,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,55,17,17,17,17,56,17,57,58,59,60,61,62,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,63,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,64,65,17,66,67,\n  68,69,70,71,72,73,74,17,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,\n  93,94,16,95,96,97,98,17,17,17,99,100,101,16,16,16,16,16,16,16,16,16,16,17,17,\n  17,17,102,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,17,103,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,17,17,104,105,16,16,106,107,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,108,17,17,17,17,109,110,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  17,111,112,16,16,16,16,16,16,16,16,16,113,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,114,115,116,117,16,16,16,16,16,16,16,16,118,\n  119,120,16,16,16,16,16,121,122,16,16,16,16,123,16,16,124,16,16,16,16,16,16,16,\n  16,16,125,16,16,16,\n  16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,254,255,255,7,254,\n  255,255,7,0,0,0,0,0,4,32,4,255,255,127,255,255,255,127,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,195,255,3,0,31,80,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,223,188,64,215,255,255,\n  251,255,255,255,255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,3,252,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,254,255,255,255,127,2,255,255,255,\n  255,255,1,0,0,0,0,255,191,182,0,255,255,255,135,7,0,0,0,255,7,255,255,255,255,\n  255,255,255,254,255,195,255,255,255,255,255,255,255,255,255,255,255,255,239,\n  31,254,225,255,\n  159,0,0,255,255,255,255,255,255,0,224,255,255,255,255,255,255,255,255,255,255,\n  255,255,3,0,255,255,255,255,255,7,48,4,255,255,255,252,255,31,0,0,255,255,255,\n  1,255,7,0,0,0,0,0,0,255,255,223,255,255,0,240,255,248,3,255,255,255,255,255,\n  255,255,255,255,239,255,223,225,255,207,255,254,255,239,159,249,255,255,253,\n  197,227,159,89,128,176,207,255,3,16,238,135,249,255,255,253,109,195,135,25,2,\n  94,192,255,63,0,238,191,251,255,255,253,237,227,191,27,1,0,207,255,0,30,238,\n  159,249,255,255,253,237,227,159,25,192,176,207,255,2,0,236,199,61,214,24,199,\n  255,195,199,29,129,0,192,255,0,0,239,223,253,255,255,253,255,227,223,29,96,7,\n  207,255,0,0,239,223,253,255,255,253,239,227,223,29,96,64,207,255,6,0,255,223,\n  253,255,255,255,255,231,223,93,240,128,207,255,0,252,238,255,127,252,255,255,\n  251,47,127,128,95,255,192,255,12,0,254,255,255,255,255,127,255,7,63,32,255,3,\n  0,0,0,0,214,247,255,255,175,255,255,59,95,32,255,243,0,0,0,\n  0,1,0,0,0,255,3,0,0,255,254,255,255,255,31,254,255,3,255,255,254,255,255,255,\n  31,0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,249,255,3,255,255,255,255,255,\n  255,255,255,255,63,255,255,255,255,191,32,255,255,255,255,255,247,255,255,255,\n  255,255,255,255,255,255,61,127,61,255,255,255,255,255,61,255,255,255,255,61,\n  127,61,255,127,255,255,255,255,255,255,255,61,255,255,255,255,255,255,255,255,\n  7,0,0,0,0,255,255,0,0,255,255,255,255,255,255,255,255,255,255,63,63,254,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,159,255,255,254,255,255,7,255,255,255,255,255,255,255,255,\n  255,199,255,1,255,223,15,0,255,255,15,0,255,255,15,0,255,223,13,0,255,255,255,\n  255,255,255,207,255,255,1,128,16,255,3,0,0,0,0,255,3,255,255,255,255,255,255,\n  255,255,255,255,255,1,255,255,255,255,255,7,255,255,255,255,255,255,255,255,\n  63,\n  0,255,255,255,127,255,15,255,1,192,255,255,255,255,63,31,0,255,255,255,255,\n  255,15,255,255,255,3,255,3,0,0,0,0,255,255,255,15,255,255,255,255,255,255,255,\n  127,254,255,31,0,255,3,255,3,128,0,0,128,1,0,0,0,0,0,0,0,255,255,255,255,255,\n  255,239,255,239,15,255,3,0,0,0,0,255,255,255,255,255,243,255,255,255,255,255,\n  255,191,255,3,0,255,255,255,255,255,255,127,0,255,227,255,255,255,255,255,63,\n  255,1,255,255,255,255,255,231,0,0,0,0,0,222,111,4,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,\n  128,255,31,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,255,\n  255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,132,252,47,62,80,189,255,243,\n  224,67,0,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,\n  0,255,255,255,255,255,127,255,255,255,255,255,127,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,31,120,12,0,255,255,255,255,191,32,255,\n  255,255,255,255,255,255,128,0,0,255,255,127,0,127,127,127,127,127,127,127,127,\n  255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,224,0,0,0,254,3,62,31,254,255,255,255,255,255,255,255,255,255,127,224,254,\n  255,255,255,255,255,255,255,255,255,255,247,224,255,255,255,255,255,254,255,\n  255,255,255,255,255,255,255,255,255,127,0,0,255,255,255,255,0,0,0,0,0,0,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,\n  31,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,\n  0,0,0,0,0,0,255,255,255,255,255,63,255,31,255,255,255,15,0,0,255,255,255,255,\n  255,127,240,143,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,\n  0,128,255,252,255,255,255,255,255,255,255,255,255,255,255,255,249,255,255,255,\n  255,255,255,252,7,0,0,0,0,224,255,191,255,255,255,255,0,0,0,255,255,255,255,\n  255,255,15,0,255,255,255,255,255,255,255,255,47,0,255,3,0,0,252,232,255,255,\n  255,255,255,7,255,255,255,255,7,0,255,255,255,31,255,255,255,255,255,255,247,\n  255,0,128,255,3,255,255,255,127,255,255,255,255,255,255,127,0,255,63,255,3,\n  255,255,127,252,255,255,255,255,255,255,255,127,5,0,0,56,255,255,60,0,126,126,\n  126,0,127,127,255,255,255,255,255,247,255,3,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,7,255,3,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,15,0,255,255,127,248,255,255,255,255,\n  255,\n  15,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,3,0,0,0,0,127,0,248,224,255,253,127,95,219,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,3,0,0,0,248,255,255,255,\n  255,255,255,255,255,255,255,255,255,63,0,0,255,255,255,255,255,255,255,255,\n  252,255,255,255,255,255,255,0,0,0,0,0,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,223,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,255,3,\n  254,255,255,7,254,255,255,7,192,255,255,255,255,255,255,255,255,255,255,127,\n  252,252,252,28,0,0,0,0,255,239,255,255,127,255,255,183,255,63,255,63,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,31,255,255,255,255,255,255,1,0,0,0,0,\n  0,255,255,255,255,0,224,255,255,255,7,255,255,255,255,255,7,255,255,255,63,\n  255,255,255,255,15,255,62,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,63,255,3,255,255,255,255,15,255,255,255,\n  255,15,255,255,255,255,255,0,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,0,255,255,63,0,255,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,63,253,255,255,255,255,191,145,255,255,63,0,255,255,\n  127,0,255,255,255,127,0,0,0,0,0,0,0,0,255,255,55,0,255,255,63,0,255,255,255,3,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,192,0,0,0,0,0,0,0,0,111,240,239,\n  254,255,255,63,0,0,0,0,0,255,255,255,31,255,255,255,31,0,0,0,0,255,254,255,\n  255,31,0,0,0,255,255,255,255,255,255,63,0,255,255,63,0,255,255,7,0,255,255,3,\n  0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,255,1,0,0,0,0,0,0,255,255,255,255,255,255,7,\n  0,255,255,255,255,255,255,7,0,255,255,255,255,255,0,255,3,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\n  255,27,3,0,0,0,0,0,0,0,0,0,255,255,255,31,128,0,255,255,63,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,31,0,0,0,255,255,127,0,255,255,255,255,255,255,255,255,63,0,0,\n  0,192,255,0,0,252,255,255,255,255,255,255,1,0,0,255,255,255,1,255,3,255,255,\n  255,255,255,255,199,255,240,0,255,255,255,255,71,0,255,255,255,255,255,255,\n  255,255,30,192,255,23,0,0,0,0,255,255,251,255,255,255,159,64,0,0,0,0,0,0,0,0,\n  127,189,255,191,255,1,255,255,255,255,255,255,255,1,255,3,239,159,249,255,255,\n  253,237,227,159,25,129,224,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,187,7,255,131,3,0,0,0,255,255,255,255,255,\n  255,255,255,179,0,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\n  255,255,255,63,127,0,0,0,63,0,0,0,0,255,255,255,255,255,255,255,127,17,0,255,\n  3,0,0,0,0,255,255,255,255,255,255,63,1,255,3,0,0,0,0,0,0,255,255,255,231,255,\n  7,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,\n  255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,3,0,128,\n  127,242,111,255,255,255,191,153,7,0,255,3,0,0,0,0,0,0,0,0,255,252,255,255,255,\n  255,255,252,26,0,0,0,255,255,255,255,255,255,231,127,0,0,255,255,255,255,255,\n  255,255,255,255,32,0,0,0,0,255,255,255,255,255,255,255,1,255,253,255,255,255,\n  255,127,127,1,0,255,3,0,0,252,255,255,255,252,255,255,254,127,0,0,0,0,0,0,0,0,\n  0,127,251,255,255,255,255,127,180,203,0,255,3,191,253,255,255,255,127,123,1,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,\n  0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,127,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,\n  0,255,255,255,255,255,255,255,1,255,255,255,127,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,63,0,0,255,255,255,255,255,255,0,0,15,0,255,3,248,255,255,224,255,\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,135,\n  255,255,255,255,255,255,255,128,255,255,0,0,0,0,0,0,0,0,11,0,3,0,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,0,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,0,0,0,0,0,\n  255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\n  127,0,0,0,0,0,0,7,0,240,0,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,15,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,7,255,31,255,1,255,67,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,255,255,255,\n  223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,\n  255,123,95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,63,255,255,255,253,255,255,247,255,255,255,\n  247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,255,253,\n  255,255,255,253,255,255,247,207,255,255,255,255,255,255,127,255,255,249,219,7,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,31,\n  128,63,255,67,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,15,255,\n  3,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,31,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,143,8,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,239,255,255,255,150,254,247,10,\n  132,234,150,170,150,247,247,94,255,251,255,15,238,251,255,15,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,3\n]);\n\n// size: 1568 bytes (compressed to ~1380 bytes after binaryen)\n// @ts-ignore: decorator\n@lazy @inline const CASED = memory.data<u8>([\n  18,19,20,21,22,23,16,16,16,16,16,16,16,16,16,16,\n  24,16,16,25,16,16,16,16,16,16,16,16,26,27,17,28,\n  29,30,16,16,31,16,16,16,16,16,16,16,32,33,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,34,35,16,16,16,36,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,37,16,16,16,38,\n  16,16,16,16,39,16,16,16,16,16,16,16,40,16,16,16,\n  16,16,16,16,16,16,16,16,41,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,42,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,43,44,45,46,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,47,16,16,16,16,16,16,\n  16,48,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,254,255,255,7,254,255,255,7,0,0,0,0,0,4,32,4,\n  255,255,127,255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,247,240,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,239,255,255,255,255,1,3,0,0,0,31,0,0,0,\n  0,0,0,0,0,0,0,0,32,0,0,0,0,0,207,188,64,215,255,255,251,255,255,255,\n  255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  3,252,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,255,\n  255,255,127,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\n  191,32,255,255,255,255,255,231,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,255,255,255,255,255,255,255,255,63,63,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,1,255,255,255,255,255,231,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,\n  255,255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,\n  132,252,47,62,80,189,31,242,224,67,0,0,255,255,255,255,24,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,0,255,255,255,255,255,127,255,255,\n  255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,120,12,0,\n  255,255,255,255,191,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,63,0,0,\n  255,255,255,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,255,255,\n  255,255,255,255,255,255,255,255,255,120,255,255,255,255,255,255,252,7,0,0,0,0,96,7,\n  0,0,0,0,0,0,255,255,255,255,255,247,255,1,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,127,0,248,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,254,255,255,7,\n  254,255,255,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\n  255,255,15,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,7,0,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,\n  255,255,255,223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,255,123,\n  95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,\n  253,255,255,247,255,255,255,247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,\n  255,253,255,255,255,253,255,255,247,15,0,0,0,0,0,0,255,255,255,255,255,255,255,255,\n  15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0\n]);\n\n// size: 2976 bytes (compressed to ~2050 bytes after binaryen)\n// @ts-ignore: decorator\n@lazy @inline const CASE_IGNORABLES = memory.data<u8>([\n  18,16,19,20,21,22,23,24,25,26,27,28,29,30,31,32,\n  33,16,16,34,16,16,16,35,36,37,38,39,40,41,16,42,\n  43,16,16,16,16,16,16,16,16,16,16,16,44,45,46,16,\n  47,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  48,16,16,16,49,16,50,51,52,53,54,55,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,56,16,16,57,58,\n  16,59,60,61,16,16,16,16,16,16,62,16,16,63,64,65,\n  66,67,68,69,70,71,72,73,74,75,76,16,77,78,79,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,80,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,81,82,16,16,16,83,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,84,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,85,86,16,16,16,16,16,16,16,87,16,16,16,16,16,\n  88,89,90,16,16,16,16,16,91,92,16,16,16,16,16,16,\n  16,16,16,93,16,16,16,16,16,16,16,16,16,16,16,16,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,128,64,0,4,0,0,0,64,1,0,0,0,0,0,0,0,0,161,144,1,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,48,4,176,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,248,3,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,130,0,0,0,0,\n  0,0,254,255,255,255,255,191,182,0,0,0,0,0,16,0,63,0,255,23,0,0,0,0,\n  1,248,255,255,0,0,1,0,0,0,0,0,0,0,0,0,0,0,192,191,255,61,0,0,\n  0,128,2,0,0,0,255,255,255,7,0,0,0,0,0,0,0,0,0,0,192,255,1,0,\n  0,0,0,0,0,248,63,36,0,0,192,255,255,63,0,0,0,0,0,14,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,248,255,255,255,255,255,7,0,0,0,0,0,0,20,\n  254,33,254,0,12,0,2,0,2,0,0,0,0,0,0,16,30,32,0,0,12,0,0,64,\n  6,0,0,0,0,0,0,16,134,57,2,0,0,0,35,0,6,0,0,0,0,0,0,16,\n  190,33,0,0,12,0,0,252,2,0,0,0,0,0,0,144,30,32,96,0,12,0,0,0,\n  4,0,0,0,0,0,0,0,1,32,0,0,0,0,0,0,17,0,0,0,0,0,0,192,\n  193,61,96,0,12,0,0,0,2,0,0,0,0,0,0,144,64,48,0,0,12,0,0,0,\n  3,0,0,0,0,0,0,24,30,32,0,0,12,0,0,0,2,0,0,0,0,0,0,0,\n  0,4,92,0,0,0,0,0,0,0,0,0,0,0,242,7,192,127,0,0,0,0,0,0,\n  0,0,0,0,0,0,242,31,64,63,0,0,0,0,0,0,0,0,0,3,0,0,160,2,\n  0,0,0,0,0,0,254,127,223,224,255,254,255,255,255,31,64,0,0,0,0,0,0,0,\n  0,0,0,0,0,224,253,102,0,0,0,195,1,0,30,0,100,32,0,32,0,0,0,0,\n  0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,224,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,0,0,0,28,0,\n  0,0,12,0,0,0,12,0,0,0,0,0,0,0,176,63,64,254,143,32,0,0,0,0,\n  0,120,0,0,0,0,0,0,8,0,0,0,0,0,0,0,96,0,0,0,0,2,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,135,1,4,14,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,9,0,0,0,0,\n  0,0,64,127,229,31,248,159,0,0,0,0,128,0,255,255,1,0,0,0,0,0,0,0,\n  15,0,0,0,0,0,208,23,4,0,0,0,0,248,15,0,3,0,0,0,60,59,0,0,\n  0,0,0,0,64,163,3,0,0,0,0,0,0,240,207,0,0,0,0,0,0,0,0,63,\n  0,0,0,0,0,0,0,0,0,0,247,255,253,33,16,3,0,0,0,0,0,240,255,255,\n  255,255,255,255,255,7,0,1,0,0,0,248,255,255,255,255,255,255,255,255,255,255,255,251,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,160,\n  3,224,0,224,0,224,0,96,0,248,0,3,144,124,0,0,0,0,0,0,223,255,2,128,\n  0,0,255,31,0,0,0,0,0,0,255,255,255,255,1,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,128,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,60,62,8,\n  0,0,0,0,0,0,0,0,0,0,0,126,0,0,0,0,0,0,0,0,0,0,0,112,\n  0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,63,0,16,0,0,0,0,0,0,\n  0,0,0,0,0,128,247,191,0,0,0,240,0,0,0,0,0,0,0,0,0,0,3,0,\n  255,255,255,255,3,0,0,0,0,0,0,0,0,0,1,0,0,7,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,3,68,8,0,0,96,16,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,48,0,0,0,255,255,3,128,0,0,0,0,192,63,0,0,\n  128,255,3,0,0,0,0,0,7,0,0,0,0,0,200,51,0,128,0,0,96,0,0,0,\n  0,0,0,0,0,126,102,0,8,16,0,0,0,0,1,16,0,0,0,0,0,0,157,193,\n  2,0,0,32,0,48,88,0,0,0,0,0,0,0,0,0,0,0,0,248,0,14,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,32,33,0,0,0,0,0,64,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,3,0,0,0,0,0,0,0,\n  255,255,8,0,255,255,0,0,0,0,36,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,128,128,64,0,4,0,0,0,64,1,0,0,0,0,0,1,0,\n  0,0,0,192,0,0,0,0,0,0,0,0,8,0,0,14,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,7,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,110,240,0,0,0,0,0,135,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,\n  0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,24,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  192,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  2,0,0,0,0,0,0,255,127,0,0,0,0,0,0,128,3,0,0,0,0,0,120,38,\n  0,32,0,0,0,0,0,0,7,0,0,0,128,239,31,0,0,0,0,0,0,0,8,0,\n  3,0,0,0,0,0,192,127,0,158,0,0,0,0,0,0,0,0,0,0,0,128,211,64,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,248,7,0,0,\n  3,0,0,0,0,0,0,24,1,0,0,0,192,31,31,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,92,0,0,64,0,0,0,0,\n  0,0,0,0,0,0,248,133,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,60,176,1,0,0,48,0,0,0,0,\n  0,0,0,0,0,0,248,167,1,0,0,0,0,0,0,0,0,0,0,0,0,40,191,0,\n  0,0,0,0,0,0,0,0,0,0,0,224,188,15,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,255,6,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,88,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,240,12,1,0,0,0,254,7,0,0,0,0,248,121,128,0,126,14,0,0,0,0,\n  0,252,127,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,127,191,\n  0,0,0,0,0,0,0,0,0,0,252,255,255,252,109,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,126,180,191,0,0,0,0,0,0,0,0,0,163,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,255,1,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,31,0,0,0,0,0,0,0,127,0,15,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,128,0,0,0,0,0,0,0,128,255,255,0,0,0,0,0,0,0,0,27,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,15,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,248,255,\n  231,15,0,0,0,60,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,127,248,255,255,255,255,255,31,32,0,16,0,0,248,254,255,0,0,\n  0,0,0,0,0,0,0,0,127,255,255,249,219,7,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,63,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,127,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  240,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,248\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOWER127 = memory.data<u8>([\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\n  91,92,93,94,95,96,\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\n  123,124,125,126,127\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const UPPER127 = memory.data<u8>([\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\n  91,92,93,94,95,96,\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\n  123,124,125,126,127\n]);\n\n// 23 * 8 = 184 bytes\n// @ts-ignore: decorator\n@lazy @inline const POWERS10 = memory.data<f64>([\n  1e00, 1e01, 1e02, 1e03, 1e04, 1e05, 1e06, 1e07, 1e08, 1e09,\n  1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,\n  1e20, 1e21, 1e22\n]);\n\n// @ts-ignore: decorator\n@inline\nexport const enum CharCode {\n  PERCENT = 0x25,\n  PLUS = 0x2B,\n  MINUS = 0x2D,\n  DOT = 0x2E,\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n  A = 0x41,\n  B = 0x42,\n  E = 0x45,\n  I = 0x49,\n  N = 0x4E,\n  O = 0x4F,\n  X = 0x58,\n  Z = 0x5A,\n  a = 0x61,\n  b = 0x62,\n  e = 0x65,\n  n = 0x6E,\n  o = 0x6F,\n  u = 0x75,\n  x = 0x78,\n  z = 0x7A\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isAscii(c: u32): bool {\n  return !(c >> 7);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isLower8(c: u32): bool {\n  return c - CharCode.a < 26;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isUpper8(c: u32): bool {\n  return c - CharCode.A < 26;\n}\n\nexport function isSpace(c: u32): bool {\n  if (c < 0x1680) { // < <LS> (1)\n    // <SP>, <TAB>, <LF>, <VT>, <FF>, <CR> and <NBSP>\n    // (c == 0x20 || c == 0xA0) was optimized to (c | 0x80) == 0xA0\n    return ((c | 0x80) == 0xA0) || (c - 0x09 <= 0x0D - 0x09);\n  }\n  if (c - 0x2000 <= 0x200A - 0x2000) return true;\n  switch (c) {\n    case 0x1680: // <LS> (1)\n    case 0x2028: // <LS> (2)\n    case 0x2029: // <PS>\n    case 0x202F: // <NNS>\n    case 0x205F: // <MMSP>\n    case 0x3000: // <IS>\n    case 0xFEFF: return true; // <ZWNBSP>\n  }\n  return false;\n}\n\nexport function isAlpha(c: u32): bool {\n  if (isAscii(c)) return (c | 32) - CharCode.a < 26;\n  if (c < 0x20000) {\n    // @ts-ignore: cast\n    return stagedBinaryLookup(ALPHA_TABLE, c);\n  }\n  return c < 0x2FFFE;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isCased(c: u32): bool {\n  // @ts-ignore: cast\n  return c < 0x1F18A && stagedBinaryLookup(CASED, c);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isCaseIgnorable(c: u32): bool {\n  // @ts-ignore: cast\n  return c < 0xE01F0 && stagedBinaryLookup(CASE_IGNORABLES, c);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isFinalSigma(buffer: usize, index: isize, len: isize): bool {\n  const lookaheadLimit = 30; // max lookahead limit\n  var found = false;\n  var pos = index;\n  var minPos = max(0, pos - lookaheadLimit);\n  while (pos > minPos) {\n    let c = codePointBefore(buffer, pos);\n    if (!isCaseIgnorable(c)) {\n      if (isCased(c)) {\n        found = true;\n      } else {\n        return false;\n      }\n    }\n    pos -= isize(c >= 0x10000) + 1;\n  }\n  if (!found) return false;\n  pos = index + 1;\n  var maxPos = min(pos + lookaheadLimit, len);\n  while (pos < maxPos) {\n    let c = <u32>load<u16>(buffer + (pos << 1));\n    if (u32((c & 0xFC00) == 0xD800) & u32(pos + 1 != len)) {\n      let c1 = <u32>load<u16>(buffer + (pos << 1), 2);\n      if ((c1 & 0xFC00) == 0xDC00) {\n        c = (c - 0xD800 << 10) + (c1 - 0xDC00) + 0x10000;\n      }\n    }\n    if (!isCaseIgnorable(c)) {\n      return !isCased(c);\n    }\n    pos += isize(c >= 0x10000) + 1;\n  }\n  return true;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction codePointBefore(buffer: usize, index: isize): i32 {\n  if (index <= 0) return -1;\n  var c = <u32>load<u16>(buffer + (index - 1 << 1));\n  if (u32((c & 0xFC00) == 0xDC00) & u32(index - 2 >= 0)) {\n    let c1 = <u32>load<u16>(buffer + (index - 2 << 1));\n    if ((c1 & 0xFC00) == 0xD800) {\n      return ((c1 & 0x3FF) << 10) + (c & 0x3FF) + 0x10000;\n    }\n  }\n  return (c & 0xF800) == 0xD800 ? 0xFFFD : c;\n}\n\n// Search routine for two-staged lookup tables\nfunction stagedBinaryLookup(table: usize, c: u32): bool {\n  return <bool>((load<u8>(table + (<u32>load<u8>(table + (c >>> 8)) << 5) + ((c & 255) >> 3)) >>> (c & 7)) & 1);\n}\n\nexport function compareImpl(str1: string, index1: usize, str2: string, index2: usize, len: usize): i32 {\n  var ptr1 = changetype<usize>(str1) + (index1 << 1);\n  var ptr2 = changetype<usize>(str2) + (index2 << 1);\n  if (ASC_SHRINK_LEVEL < 2) {\n    if (len >= 4 && !((ptr1 & 7) | (ptr2 & 7))) {\n      do {\n        if (load<u64>(ptr1) != load<u64>(ptr2)) break;\n        ptr1 += 8;\n        ptr2 += 8;\n        len  -= 4;\n      } while (len >= 4);\n    }\n  }\n  while (len--) {\n    let a = <i32>load<u16>(ptr1);\n    let b = <i32>load<u16>(ptr2);\n    if (a != b) return a - b;\n    ptr1 += 2;\n    ptr2 += 2;\n  }\n  return 0;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function toLower8(c: u32): u32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    return c | u32(isUpper8(c)) << 5;\n  } else {\n    return <u32>load<u8>(LOWER127 + c);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function toUpper8(c: u32): u32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    return c & ~(u32(isLower8(c)) << 5);\n  } else {\n    return <u32>load<u8>(UPPER127 + c);\n  }\n}\n\n/** Parses a string to an integer (usually), using the specified radix. */\nexport function strtol<T>(str: string, radix: i32 = 0): T {\n  var len = str.length;\n  if (!len) {\n    if (isFloat<T>()) {\n      // @ts-ignore: cast\n      return <T>NaN;\n    } else {\n      // @ts-ignore: cast\n      return <T>0;\n    }\n  }\n\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  var code = <u32>load<u16>(ptr);\n\n  // trim white spaces\n  while (isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  // determine sign\n  // @ts-ignore\n  var sign: T = 1;\n  if (code == CharCode.MINUS || code == CharCode.PLUS) {\n    if (!--len) {\n      if (isFloat<T>()) {\n        // @ts-ignore: cast\n        return <T>NaN;\n      } else {\n        // @ts-ignore: cast\n        return <T>0;\n      }\n    }\n    if (code == CharCode.MINUS) {\n      // @ts-ignore: type\n      sign = -1;\n    }\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // See https://tc39.es/ecma262/#sec-parseint-string-radix\n  if (radix) {\n    if (radix < 2 || radix > 36) {\n      if (isFloat<T>()) {\n        // @ts-ignore: cast\n        return <T>NaN;\n      } else {\n        // @ts-ignore: cast\n        return <T>0;\n      }\n    }\n    // handle case as parseInt(\"0xFF\", 16) by spec\n    if (radix == 16) {\n      if (\n        len > 2 &&\n        code == CharCode._0 &&\n        (<u32>load<u16>(ptr, 2) | 32) == CharCode.x\n      ) {\n        ptr += 4; len -= 2;\n      }\n    }\n  } else {\n    // determine radix by literal prefix\n    if (code == CharCode._0 && len > 2) {\n      switch (<u32>load<u16>(ptr, 2) | 32) {\n        case CharCode.b: {\n          ptr += 4; len -= 2;\n          radix = 2;\n          break;\n        }\n        case CharCode.o: {\n          ptr += 4; len -= 2;\n          radix = 8;\n          break;\n        }\n        case CharCode.x: {\n          ptr += 4; len -= 2;\n          radix = 16;\n          break;\n        }\n      }\n    }\n    if (!radix) radix = 10;\n  }\n\n  // calculate value\n  // @ts-ignore: type\n  var num: T = 0;\n  while (len--) {\n    code = <u32>load<u16>(ptr);\n    if (code - CharCode._0 < 10) {\n      code -= CharCode._0;\n    } else if (code - CharCode.A <= <u32>(CharCode.Z - CharCode.A)) {\n      code -= CharCode.A - 10;\n    } else if (code - CharCode.a <= <u32>(CharCode.z - CharCode.a)) {\n      code -= CharCode.a - 10;\n    }\n    if (code >= <u32>radix) {\n      if (!num) {\n        if (isFloat<T>()) {\n          // @ts-ignore: cast\n          return <T>NaN;\n        } else {\n          // @ts-ignore: cast\n          return <T>0;\n        }\n      }\n      break;\n    }\n    // @ts-ignore: type\n    num = num * radix + code;\n    ptr += 2;\n  }\n  // @ts-ignore: type\n  return sign * num;\n}\n\nexport function strtod(str: string): f64 {\n  var len = str.length;\n  if (!len) return NaN;\n\n  var ptr  = changetype<usize>(str);\n  var code = <u32>load<u16>(ptr);\n\n  var sign = 1.0;\n  // skip white spaces\n  while (len && isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (!len) return NaN;\n\n  // try parse '-' or '+'\n  if (code == CharCode.MINUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // try parse Infinity\n  if (len >= 8 && code == CharCode.I) {\n    if (\n      load<u64>(ptr, 0) == 0x690066006E0049 && // ifnI\n      load<u64>(ptr, 8) == 0x7900740069006E    // ytin\n    ) {\n      return Infinity * sign;\n    }\n    return NaN;\n  }\n  // validate next symbol\n  if (code != CharCode.DOT && <u32>(code - CharCode._0) >= 10) {\n    return NaN;\n  }\n  var savedPtr = ptr;\n  // skip zeros\n  while (code == CharCode._0) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (len <= 0) return 0;\n  const capacity = 19; // int(64 * 0.3010)\n  var pointed = false;\n  var consumed = 0;\n  var position = 0;\n  var x: u64 = 0;\n  if (code == CharCode.DOT) {\n    let noDigits = !(savedPtr - ptr);\n    ptr += 2; --len;\n    if (!len && noDigits) return NaN;\n    for (pointed = true; (code = <u32>load<u16>(ptr)) == CharCode._0; --position, ptr += 2) --len;\n    if (len <= 0) return 0;\n    if (!position && noDigits && code - CharCode._0 >= 10) return NaN;\n  }\n  for (let digit = code - CharCode._0; digit < 10 || (code == CharCode.DOT && !pointed); digit = code - CharCode._0) {\n    if (digit < 10) {\n      x = consumed < capacity ? 10 * x + digit : x | u64(!!digit);\n      ++consumed;\n    } else {\n      position = consumed;\n      pointed = true;\n    }\n    if (!--len) break;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  if (!pointed) position = consumed;\n  return copysign<f64>(scientific(x, position - min(capacity, consumed) + parseExp(ptr, len)), sign);\n}\n\nexport function joinBooleanArray(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) return select(\"true\", \"false\", load<bool>(dataStart));\n\n  var sepLen = separator.length;\n  var valueLen = 5; // max possible length of element len(\"false\")\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  var result = changetype<string>(__new(estLen << 1, idof<string>()));\n  var offset = 0;\n  var value: bool;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<bool>(dataStart + i);\n    valueLen = 4 + i32(!value);\n    memory.copy(\n      changetype<usize>(result) + (<usize>offset << 1),\n      changetype<usize>(select(\"true\", \"false\", value)),\n      <usize>valueLen << 1\n    );\n    offset += valueLen;\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<bool>(dataStart + <usize>lastIndex);\n  valueLen = 4 + i32(!value);\n  memory.copy(\n    changetype<usize>(result) + (<usize>offset << 1),\n    changetype<usize>(select(\"true\", \"false\", value)),\n    valueLen << 1\n  );\n  offset += valueLen;\n\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinIntegerArray<T>(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    let value = load<T>(dataStart);\n    if (isSigned<T>()) {\n      if (sizeof<T>() <= 4) {\n        // @ts-ignore: type\n        return changetype<string>(itoa32(<i32>value, 10));\n      } else {\n        // @ts-ignore: type\n        return changetype<string>(itoa64(<i32>value, 10));\n      }\n    } else {\n      if (sizeof<T>() <= 4) {\n        // @ts-ignore: type\n        return changetype<string>(utoa32(<u32>value, 10));\n      } else {\n        // @ts-ignore: type\n        return changetype<string>(utoa64(<u64>value, 10));\n      }\n    }\n  }\n\n  var sepLen = separator.length;\n  const valueLen = (sizeof<T>() <= 4 ? 10 : 20) + i32(isSigned<T>());\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  var result = changetype<string>(__new(estLen << 1, idof<string>()));\n  var offset = 0;\n  var value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinFloatArray<T>(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    return changetype<string>(dtoa(\n      // @ts-ignore: type\n      load<T>(dataStart))\n    );\n  }\n\n  const valueLen = MAX_DOUBLE_LENGTH;\n  var sepLen = separator.length;\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  var result = changetype<string>(__new(estLen << 1, idof<string>()));\n  var offset = 0;\n  var value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinStringArray(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    // @ts-ignore: type\n    return load<string>(dataStart) || \"\";\n  }\n  var estLen = 0;\n  var value: string;\n  for (let i = 0; i < length; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    // @ts-ignore: type\n    if (value !== null) estLen += value.length;\n  }\n  var offset = 0;\n  var sepLen = separator.length;\n  var result = changetype<string>(__new((estLen + sepLen * lastIndex) << 1, idof<string>()));\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    if (value !== null) {\n      let valueLen = value.length;\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(value),\n        <usize>valueLen << 1\n      );\n      offset += valueLen;\n    }\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<string>(dataStart + (<usize>lastIndex << alignof<string>()));\n  if (value !== null) {\n    memory.copy(\n      changetype<usize>(result) + (<usize>offset << 1),\n      changetype<usize>(value),\n      <usize>value.length << 1\n    );\n  }\n  return result;\n}\n\nexport function joinReferenceArray<T>(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  var value: T;\n  if (!lastIndex) {\n    value = load<T>(dataStart);\n    // @ts-ignore: type\n    return value !== null ? value.toString() : \"\";\n  }\n  var result = \"\";\n  var sepLen = separator.length;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    if (value !== null) result += value.toString();\n    if (sepLen) result += separator;\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  if (value !== null) result += value.toString();\n  return result;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction scientific(significand: u64, exp: i32): f64 {\n  if (!significand || exp < -342) return 0;\n  if (exp > 308) return Infinity;\n  // Try use fast path\n  // Use fast path for string-to-double conversion if possible\n  // see http://www.exploringbinary.com/fast-path-decimal-to-floating-point-conversion\n  // Simple integer\n  var significandf = <f64>significand;\n  if (!exp) return significandf;\n  if (exp > 22 && exp <= 22 + 15) {\n    significandf *= pow10(exp - 22);\n    exp = 22;\n  }\n  if (significand <= 9007199254740991 && abs(exp) <= 22) {\n    if (exp > 0) return significandf * pow10(exp);\n    return significandf / pow10(-exp);\n  } else if (exp < 0) {\n    return scaledown(significand, exp);\n  } else {\n    return scaleup(significand, exp);\n  }\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaledown(significand: u64, exp: i32): f64 {\n  const denom: u64 = 6103515625; // 1e14 * 0x1p-14\n  const scale = reinterpret<f64>(0x3F06849B86A12B9B); // 1e-14 * 0x1p32\n\n  var shift = clz(significand);\n  significand <<= shift;\n  shift = exp - shift;\n\n  for (; exp <= -14; exp += 14) {\n    let q = significand / denom;\n    let r = significand % denom;\n    let s = clz(q);\n    significand = (q << s) + <u64>nearest(scale * <f64>(r << (s - 18)));\n    shift -= s;\n  }\n  var b = <u64>ipow32(5, -exp);\n  var q = significand / b;\n  var r = significand % b;\n  var s = clz(q);\n  significand = (q << s) + <u64>(reinterpret<f64>(reinterpret<u64>(<f64>r) + (s << 52)) / <f64>b);\n  shift -= s;\n\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaleup(significand: u64, exp: i32): f64 {\n  const coeff: u32 = 1220703125; // 1e13 * 0x1p-13;\n  var shift = ctz(significand);\n  significand >>= shift;\n  shift += exp;\n\n  __fixmulShift = shift;\n  for (; exp >= 13; exp -= 13) {\n    significand = fixmul(significand, coeff);\n  }\n  significand = fixmul(significand, <u32>ipow32(5, exp));\n  shift = __fixmulShift;\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction parseExp(ptr: usize, len: i32): i32 {\n  var sign = 1, magnitude = 0;\n  var code = <u32>load<u16>(ptr);\n  // check code is 'e' or 'E'\n  if ((code | 32) != CharCode.e) return 0;\n\n  if (!--len) return 0;\n  code = <u32>load<u16>(ptr += 2);\n  if (code == CharCode.MINUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  // skip zeros\n  while (code == CharCode._0) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  for (let digit: u32 = code - CharCode._0; len && digit < 10; digit = code - CharCode._0) {\n    if (magnitude >= 3200) return sign * 3200;\n    magnitude = 10 * magnitude + digit;\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  return sign * magnitude;\n}\n\n// @ts-ignore: decorator\n@lazy var __fixmulShift: u64 = 0;\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction fixmul(a: u64, b: u32): u64 {\n  var low  = (a & 0xFFFFFFFF) * b;\n  var high = (a >> 32) * b + (low >> 32);\n  var overflow = <u32>(high >> 32);\n  var space = clz(overflow);\n  var revspace: u64 = 32 - space;\n  __fixmulShift += revspace;\n  return (high << space | (low & 0xFFFFFFFF) >> revspace) + (low << space >> 31 & 1);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction pow10(n: i32): f64 {\n  // argument `n` should bounds in [0, 22] range\n  return load<f64>(POWERS10 + (n << alignof<f64>()));\n}\n","/// <reference path=\"../rt/index.d.ts\" />\n\nimport { idof } from \"../builtins\";\nimport { CharCode } from \"./string\";\n\n// @ts-ignore: decorator\n@inline\nexport const MAX_DOUBLE_LENGTH = 28;\n\n// @ts-ignore: decorator\n@lazy @inline const POWERS10 = memory.data<u32>([\n  1,\n  10,\n  100,\n  1000,\n  10000,\n  100000,\n  1000000,\n  10000000,\n  100000000,\n  1000000000\n]);\n\n/*\n  Lookup table for pairwise char codes in range [0-99]\n\n  \"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\",\n  \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\",\n  \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\",\n  \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\",\n  \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\",\n  \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\",\n  \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\",\n  \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\",\n  \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\",\n  \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\"\n*/\n// @ts-ignore: decorator\n@lazy @inline const DIGITS = memory.data<u32>([\n  0x00300030, 0x00310030, 0x00320030, 0x00330030, 0x00340030,\n  0x00350030, 0x00360030, 0x00370030, 0x00380030, 0x00390030,\n  0x00300031, 0x00310031, 0x00320031, 0x00330031, 0x00340031,\n  0x00350031, 0x00360031, 0x00370031, 0x00380031, 0x00390031,\n  0x00300032, 0x00310032, 0x00320032, 0x00330032, 0x00340032,\n  0x00350032, 0x00360032, 0x00370032, 0x00380032, 0x00390032,\n  0x00300033, 0x00310033, 0x00320033, 0x00330033, 0x00340033,\n  0x00350033, 0x00360033, 0x00370033, 0x00380033, 0x00390033,\n  0x00300034, 0x00310034, 0x00320034, 0x00330034, 0x00340034,\n  0x00350034, 0x00360034, 0x00370034, 0x00380034, 0x00390034,\n  0x00300035, 0x00310035, 0x00320035, 0x00330035, 0x00340035,\n  0x00350035, 0x00360035, 0x00370035, 0x00380035, 0x00390035,\n  0x00300036, 0x00310036, 0x00320036, 0x00330036, 0x00340036,\n  0x00350036, 0x00360036, 0x00370036, 0x00380036, 0x00390036,\n  0x00300037, 0x00310037, 0x00320037, 0x00330037, 0x00340037,\n  0x00350037, 0x00360037, 0x00370037, 0x00380037, 0x00390037,\n  0x00300038, 0x00310038, 0x00320038, 0x00330038, 0x00340038,\n  0x00350038, 0x00360038, 0x00370038, 0x00380038, 0x00390038,\n  0x00300039, 0x00310039, 0x00320039, 0x00330039, 0x00340039,\n  0x00350039, 0x00360039, 0x00370039, 0x00380039, 0x00390039\n]);\n\n// Lookup table for pairwise char codes in range [0x00-0xFF]\n// @ts-ignore: decorator\n@lazy @inline const HEX_DIGITS =\n\"000102030405060708090a0b0c0d0e0f\\\n101112131415161718191a1b1c1d1e1f\\\n202122232425262728292a2b2c2d2e2f\\\n303132333435363738393a3b3c3d3e3f\\\n404142434445464748494a4b4c4d4e4f\\\n505152535455565758595a5b5c5d5e5f\\\n606162636465666768696a6b6c6d6e6f\\\n707172737475767778797a7b7c7d7e7f\\\n808182838485868788898a8b8c8d8e8f\\\n909192939495969798999a9b9c9d9e9f\\\na0a1a2a3a4a5a6a7a8a9aaabacadaeaf\\\nb0b1b2b3b4b5b6b7b8b9babbbcbdbebf\\\nc0c1c2c3c4c5c6c7c8c9cacbcccdcecf\\\nd0d1d2d3d4d5d6d7d8d9dadbdcdddedf\\\ne0e1e2e3e4e5e6e7e8e9eaebecedeeef\\\nf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\";\n\n// @ts-ignore: decorator\n@lazy @inline const ANY_DIGITS = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n\n// @ts-ignore: decorator\n@lazy @inline const EXP_POWERS = memory.data<i16>([/* eslint-disable indent */\n  -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007,  -980,\n   -954,  -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,\n   -688,  -661,  -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,\n   -422,  -396,  -369,  -343,  -316,  -289,  -263,  -236,  -210,  -183,\n   -157,  -130,  -103,   -77,   -50,   -24,     3,    30,    56,    83,\n    109,   136,   162,   189,   216,   242,   269,   295,   322,   348,\n    375,   402,   428,   455,   481,   508,   534,   561,   588,   614,\n    641,   667,   694,   720,   747,   774,   800,   827,   853,   880,\n    907,   933,   960,   986,  1013,  1039,  1066\n/* eslint-enable indent */]);\n\n// 1e-348, 1e-340, ..., 1e340\n// @ts-ignore: decorator\n@lazy @inline const FRC_POWERS = memory.data<u64>([\n  0xFA8FD5A0081C0288, 0xBAAEE17FA23EBF76, 0x8B16FB203055AC76, 0xCF42894A5DCE35EA,\n  0x9A6BB0AA55653B2D, 0xE61ACF033D1A45DF, 0xAB70FE17C79AC6CA, 0xFF77B1FCBEBCDC4F,\n  0xBE5691EF416BD60C, 0x8DD01FAD907FFC3C, 0xD3515C2831559A83, 0x9D71AC8FADA6C9B5,\n  0xEA9C227723EE8BCB, 0xAECC49914078536D, 0x823C12795DB6CE57, 0xC21094364DFB5637,\n  0x9096EA6F3848984F, 0xD77485CB25823AC7, 0xA086CFCD97BF97F4, 0xEF340A98172AACE5,\n  0xB23867FB2A35B28E, 0x84C8D4DFD2C63F3B, 0xC5DD44271AD3CDBA, 0x936B9FCEBB25C996,\n  0xDBAC6C247D62A584, 0xA3AB66580D5FDAF6, 0xF3E2F893DEC3F126, 0xB5B5ADA8AAFF80B8,\n  0x87625F056C7C4A8B, 0xC9BCFF6034C13053, 0x964E858C91BA2655, 0xDFF9772470297EBD,\n  0xA6DFBD9FB8E5B88F, 0xF8A95FCF88747D94, 0xB94470938FA89BCF, 0x8A08F0F8BF0F156B,\n  0xCDB02555653131B6, 0x993FE2C6D07B7FAC, 0xE45C10C42A2B3B06, 0xAA242499697392D3,\n  0xFD87B5F28300CA0E, 0xBCE5086492111AEB, 0x8CBCCC096F5088CC, 0xD1B71758E219652C,\n  0x9C40000000000000, 0xE8D4A51000000000, 0xAD78EBC5AC620000, 0x813F3978F8940984,\n  0xC097CE7BC90715B3, 0x8F7E32CE7BEA5C70, 0xD5D238A4ABE98068, 0x9F4F2726179A2245,\n  0xED63A231D4C4FB27, 0xB0DE65388CC8ADA8, 0x83C7088E1AAB65DB, 0xC45D1DF942711D9A,\n  0x924D692CA61BE758, 0xDA01EE641A708DEA, 0xA26DA3999AEF774A, 0xF209787BB47D6B85,\n  0xB454E4A179DD1877, 0x865B86925B9BC5C2, 0xC83553C5C8965D3D, 0x952AB45CFA97A0B3,\n  0xDE469FBD99A05FE3, 0xA59BC234DB398C25, 0xF6C69A72A3989F5C, 0xB7DCBF5354E9BECE,\n  0x88FCF317F22241E2, 0xCC20CE9BD35C78A5, 0x98165AF37B2153DF, 0xE2A0B5DC971F303A,\n  0xA8D9D1535CE3B396, 0xFB9B7CD9A4A7443C, 0xBB764C4CA7A44410, 0x8BAB8EEFB6409C1A,\n  0xD01FEF10A657842C, 0x9B10A4E5E9913129, 0xE7109BFBA19C0C9D, 0xAC2820D9623BF429,\n  0x80444B5E7AA7CF85, 0xBF21E44003ACDD2D, 0x8E679C2F5E44FF8F, 0xD433179D9C8CB841,\n  0x9E19DB92B4E31BA9, 0xEB96BF6EBADF77D9, 0xAF87023B9BF0EE6B\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function isPowerOf2<T extends number>(value: T): bool {\n  return popcnt<T>(value) == 1;\n}\n\n// Count number of decimals for u32 values\n// In our case input value always non-zero so we can simplify some parts\nexport function decimalCount32(value: u32): u32 {\n  if (value < 100000) {\n    if (value < 100) {\n      return 1 + u32(value >= 10);\n    } else {\n      return 3 + u32(value >= 10000) + u32(value >= 1000);\n    }\n  } else {\n    if (value < 10000000) {\n      return 6 + u32(value >= 1000000);\n    } else {\n      return 8 + u32(value >= 1000000000) + u32(value >= 100000000);\n    }\n  }\n}\n\n// Count number of decimals for u64 values\n// In our case input value always greater than 2^32-1 so we can skip some parts\nexport function decimalCount64High(value: u64): u32 {\n  if (value < 1000000000000000) {\n    if (value < 1000000000000) {\n      return 10 + u32(value >= 100000000000) + u32(value >= 10000000000);\n    } else {\n      return 13 + u32(value >= 100000000000000) + u32(value >= 10000000000000);\n    }\n  } else {\n    if (value < 100000000000000000) {\n      return 16 + u32(value >= 10000000000000000);\n    } else {\n      return 18 + u32(value >= 10000000000000000000) + u32(value >= 1000000000000000000);\n    }\n  }\n}\n\nfunction ulog_base(num: u64, base: i32): u32 {\n  if (isPowerOf2(base)) {\n    return (63 - <u32>clz(num)) / (31 - <u32>clz(base)) + 1;\n  }\n  var b64 = u64(base), b = b64, e: u32 = 1;\n  while (num >= b) {\n    num /= b;\n    b *= b;\n    e <<= 1;\n  }\n  while (num >= 1) {\n    num /= b64;\n    e++;\n  }\n  return e - 1;\n}\n\nfunction utoa32_dec_lut(buffer: usize, num: u32, offset: usize): void {\n  while (num >= 10000) {\n    // in most VMs i32/u32 div and modulo by constant can be shared and simplificate\n    let t = num / 10000;\n    let r = num % 10000;\n    num = t;\n\n    let d1 = r / 100;\n    let d2 = r % 100;\n\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>d2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  if (num >= 100) {\n    let t  = num / 100;\n    let d1 = num % 100;\n    num = t;\n    offset -= 2;\n    let digits = load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  }\n\n  if (num >= 10) {\n    offset -= 2;\n    let digits = load<u32>(DIGITS + (<usize>num << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  } else {\n    offset -= 1;\n    let digit = CharCode._0 + num;\n    store<u16>(buffer + (offset << 1), digit);\n  }\n}\n\nfunction utoa64_dec_lut(buffer: usize, num: u64, offset: usize): void {\n  while (num >= 100000000) {\n    let t = num / 100000000;\n    let r = <usize>(num - t * 100000000);\n    num = t;\n\n    let b = r / 10000;\n    let c = r % 10000;\n\n    let b1 = b / 100;\n    let b2 = b % 100;\n    let c1 = c / 100;\n    let c2 = c % 100;\n\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>c1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>c2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n\n    digits1 = <u64>load<u32>(DIGITS + (<usize>b1 << alignof<u32>()));\n    digits2 = <u64>load<u32>(DIGITS + (<usize>b2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  utoa32_dec_lut(buffer, <u32>num, offset);\n}\n\nfunction utoa_hex_lut(buffer: usize, num: u64, offset: usize): void {\n  const lut = changetype<usize>(HEX_DIGITS);\n  while (offset >= 2) {\n    offset -= 2;\n    store<u32>(\n      buffer + (offset << 1),\n      load<u32>(lut + ((<usize>num & 0xFF) << alignof<u32>()))\n    );\n    num >>= 8;\n  }\n  if (offset & 1) {\n    store<u16>(buffer, load<u16>(lut + (<usize>num << 6)));\n  }\n}\n\nfunction utoa_dec_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let t = num / 10;\n    let r = <u32>(num % 10);\n    num = changetype<T>(t);\n    offset--;\n    store<u16>(buffer + (offset << 1), CharCode._0 + r);\n  } while (num);\n}\n\nfunction utoa_hex_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let d = num & 0x0F | CharCode._0;\n    d += select<T>(<T>0x27, <T>0, d > <T>CharCode._9);\n    offset--;\n    store<u16>(buffer + (offset << 1), d);\n    // @ts-ignore: type\n    num >>= 4;\n  } while (num);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function utoa32_dec_core(buffer: usize, num: u32, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_dec_simple<u32>(buffer, num, offset);\n  } else {\n    utoa32_dec_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa32_hex_core(buffer: usize, num: u32, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_hex_simple<u32>(buffer, num, offset);\n  } else {\n    utoa_hex_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa64_dec_core(buffer: usize, num: u64, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_dec_simple<u64>(buffer, num, offset);\n  } else {\n    utoa64_dec_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa64_hex_core(buffer: usize, num: u64, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_hex_simple<u64>(buffer, num, offset);\n  } else {\n    utoa_hex_lut(buffer, num, offset);\n  }\n}\n\nfunction utoa64_any_core(buffer: usize, num: u64, offset: usize, radix: i32): void {\n  const lut = changetype<usize>(ANY_DIGITS);\n  var base = u64(radix);\n  if ((radix & (radix - 1)) == 0) { // for radix which pow of two\n    let shift = u64(ctz(radix) & 7);\n    let mask = base - 1;\n    do {\n      offset--;\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num & mask) << 1)));\n      num >>= shift;\n    } while (num);\n  } else {\n    do {\n      offset--;\n      let q = num / base;\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num - q * base) << 1)));\n      num = q;\n    } while (num);\n  }\n}\n\nexport function utoa32(value: u32, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n  var out: String;\n\n  if (radix == 10) {\n    let decimals = decimalCount32(value);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_dec_core(changetype<usize>(out), value, decimals);\n  } else if (radix == 16) {\n    let decimals = (31 - clz(value) >> 2) + 1;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\n  }\n  return out;\n}\n\nexport function itoa32(value: i32, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n\n  var sign = value >>> 31;\n  if (sign) value = -value;\n  var out: String;\n\n  if (radix == 10) {\n    let decimals = decimalCount32(value) + sign;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_dec_core(changetype<usize>(out), value, decimals);\n  } else if (radix == 16) {\n    let decimals = (31 - clz(value) >> 2) + 1 + sign;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let val32 = u32(value);\n    let decimals = ulog_base(val32, radix) + sign;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), val32, decimals, radix);\n  }\n  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);\n  return out;\n}\n\nexport function utoa64(value: u64, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n  var out: String;\n\n  if (radix == 10) {\n    if (value <= u32.MAX_VALUE) {\n      let val32    = <u32>value;\n      let decimals = decimalCount32(val32);\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa32_dec_core(changetype<usize>(out), val32, decimals);\n    } else {\n      let decimals = decimalCount64High(value);\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa64_dec_core(changetype<usize>(out), value, decimals);\n    }\n  } else if (radix == 16) {\n    let decimals = (63 - u32(clz(value)) >> 2) + 1;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\n  }\n  return out;\n}\n\nexport function itoa64(value: i64, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n\n  var sign = u32(value >>> 63);\n  if (sign) value = -value;\n  var out: String;\n\n  if (radix == 10) {\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\n      let val32    = <u32>value;\n      let decimals = decimalCount32(val32) + sign;\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa32_dec_core(changetype<usize>(out), val32, decimals);\n    } else {\n      let decimals = decimalCount64High(value) + sign;\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa64_dec_core(changetype<usize>(out), value, decimals);\n    }\n  } else if (radix == 16) {\n    let decimals = (63 - u32(clz(value)) >> 2) + 1 + sign;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix) + sign;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\n  }\n  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);\n  return out;\n}\n\n// @ts-ignore: decorator\n@lazy var _K: i32 = 0;\n\n// // @ts-ignore: decorator\n// @lazy\n// var _frc: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy var _exp: i32 = 0;\n\n// @ts-ignore: decorator\n@lazy var _frc_minus: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy var _frc_plus:  u64 = 0;\n\n// @ts-ignore: decorator\n@lazy var _frc_pow: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy var _exp_pow: i32 = 0;\n\n// @ts-ignore: decorator\n@inline\nfunction umul64f(u: u64, v: u64): u64 {\n  var u0 = u & 0xFFFFFFFF;\n  var v0 = v & 0xFFFFFFFF;\n\n  var u1 = u >> 32;\n  var v1 = v >> 32;\n\n  var l = u0 * v0;\n  var t = u1 * v0 + (l >> 32);\n  var w = u0 * v1 + (t & 0xFFFFFFFF);\n\n  w += 0x7FFFFFFF; // rounding\n\n  t >>= 32;\n  w >>= 32;\n\n  return u1 * v1 + t + w;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction umul64e(e1: i32, e2: i32): i32 {\n  return e1 + e2 + 64; // where 64 is significand size\n}\n\n// @ts-ignore: decorator\n@inline\nfunction normalizedBoundaries(f: u64, e: i32): void {\n  var frc = (f << 1) + 1;\n  var exp = e - 1;\n  var off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  var m = 1 + i32(f == 0x0010000000000000);\n\n  _frc_plus  = frc;\n  _frc_minus = ((f << m) - 1) << e - m - exp;\n  _exp = exp;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisuRound(buffer: usize, len: i32, delta: u64, rest: u64, ten_kappa: u64, wp_w: u64): void {\n  var lastp = buffer + ((len - 1) << 1);\n  var digit = load<u16>(lastp);\n  while (\n    rest < wp_w &&\n    delta - rest >= ten_kappa && (\n      rest + ten_kappa < wp_w ||\n      wp_w - rest > rest + ten_kappa - wp_w\n    )\n  ) {\n    --digit;\n    rest += ten_kappa;\n  }\n  store<u16>(lastp, digit);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction getCachedPower(minExp: i32): void {\n  const c = reinterpret<f64>(0x3FD34413509F79FE); // 1 / lg(10) = 0.30102999566398114\n  var dk = (-61 - minExp) * c + 347;\t            // dk must be positive, so can do ceiling in positive\n  var k = <i32>dk;\n  k += i32(k != dk); // conversion with ceil\n\n  var index = (k >> 3) + 1;\n  _K = 348 - (index << 3);\t// decimal exponent no need lookup table\n  _frc_pow = load<u64>(FRC_POWERS + (<usize>index << alignof<u64>()));\n  _exp_pow = load<i16>(EXP_POWERS + (<usize>index << alignof<i16>()));\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisu2(value: f64, buffer: usize, sign: i32): i32 {\n\n  // frexp routine\n  var uv  = reinterpret<u64>(value);\n  var exp = i32((uv & 0x7FF0000000000000) >>> 52);\n  var sid = uv & 0x000FFFFFFFFFFFFF;\n  var frc = (u64(exp != 0) << 52) + sid;\n  exp = select<i32>(exp, 1, exp) - (0x3FF + 52);\n\n  normalizedBoundaries(frc, exp);\n  getCachedPower(_exp);\n\n  // normalize\n  var off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  var frc_pow = _frc_pow;\n  var exp_pow = _exp_pow;\n\n  var w_frc = umul64f(frc, frc_pow);\n  var w_exp = umul64e(exp, exp_pow);\n\n  var wp_frc = umul64f(_frc_plus, frc_pow) - 1;\n  var wp_exp = umul64e(_exp, exp_pow);\n\n  var wm_frc = umul64f(_frc_minus, frc_pow) + 1;\n  var delta  = wp_frc - wm_frc;\n\n  return genDigits(buffer, w_frc, w_exp, wp_frc, wp_exp, delta, sign);\n}\n\nfunction genDigits(buffer: usize, w_frc: u64, w_exp: i32, mp_frc: u64, mp_exp: i32, delta: u64, sign: i32): i32 {\n  var one_exp = -mp_exp;\n  var one_frc = (<u64>1) << one_exp;\n  var mask    = one_frc - 1;\n\n  var wp_w_frc = mp_frc - w_frc;\n\n  var p1 = u32(mp_frc >> one_exp);\n  var p2 = mp_frc & mask;\n\n  var kappa = <i32>decimalCount32(p1);\n  var len = sign;\n\n  while (kappa > 0) {\n    let d: u32;\n    switch (kappa) {\n      case 10: { d = p1 / 1000000000; p1 %= 1000000000; break; }\n      case  9: { d = p1 /  100000000; p1 %=  100000000; break; }\n      case  8: { d = p1 /   10000000; p1 %=   10000000; break; }\n      case  7: { d = p1 /    1000000; p1 %=    1000000; break; }\n      case  6: { d = p1 /     100000; p1 %=     100000; break; }\n      case  5: { d = p1 /      10000; p1 %=      10000; break; }\n      case  4: { d = p1 /       1000; p1 %=       1000; break; }\n      case  3: { d = p1 /        100; p1 %=        100; break; }\n      case  2: { d = p1 /         10; p1 %=         10; break; }\n      case  1: { d = p1;              p1 =           0; break; }\n      default: { d = 0; break; }\n    }\n\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    --kappa;\n    let tmp = ((<u64>p1) << one_exp) + p2;\n    if (tmp <= delta) {\n      _K += kappa;\n      grisuRound(buffer, len, delta, tmp, <u64>load<u32>(POWERS10 + (<usize>kappa << alignof<u32>())) << one_exp, wp_w_frc);\n      return len;\n    }\n  }\n\n  while (true) {\n    p2    *= 10;\n    delta *= 10;\n\n    let d = p2 >> one_exp;\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    p2 &= mask;\n    --kappa;\n    if (p2 < delta) {\n      _K += kappa;\n      wp_w_frc *= <u64>load<u32>(POWERS10 + (<usize>-kappa << alignof<u32>()));\n      grisuRound(buffer, len, delta, p2, one_frc, wp_w_frc);\n      return len;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction genExponent(buffer: usize, k: i32): i32 {\n  var sign = k < 0;\n  if (sign) k = -k;\n  var decimals = decimalCount32(k) + 1;\n  utoa32_dec_core(buffer, k, decimals);\n  store<u16>(buffer, <u16>select<u32>(CharCode.MINUS, CharCode.PLUS, sign));\n  return decimals;\n}\n\nfunction prettify(buffer: usize, length: i32, k: i32): i32 {\n  if (!k) {\n    store<u32>(buffer + (length << 1), CharCode.DOT | (CharCode._0 << 16));\n    return length + 2;\n  }\n\n  var kk = length + k;\n  if (length <= kk && kk <= 21) {\n    // 1234e7 -> 12340000000\n    for (let i = length; i < kk; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    store<u32>(buffer + (kk << 1), CharCode.DOT | (CharCode._0 << 16));\n    return kk + 2;\n  } else if (kk > 0 && kk <= 21) {\n    // 1234e-2 -> 12.34\n    let ptr = buffer + (kk << 1);\n    memory.copy(\n      ptr + 2,\n      ptr,\n      -k << 1\n    );\n    store<u16>(buffer + (kk << 1), CharCode.DOT);\n    return length + 1;\n  } else if (-6 < kk && kk <= 0) {\n    // 1234e-6 -> 0.001234\n    let offset = 2 - kk;\n    memory.copy(\n      buffer + (offset << 1),\n      buffer,\n      length << 1\n    );\n    store<u32>(buffer, CharCode._0 | (CharCode.DOT << 16));\n    for (let i = 2; i < offset; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    return length + offset;\n  } else if (length == 1) {\n    // 1e30\n    store<u16>(buffer, CharCode.e, 2);\n    length = genExponent(buffer + 4, kk - 1);\n    return length + 2;\n  } else {\n    let len = length << 1;\n    memory.copy(\n      buffer + 4,\n      buffer + 2,\n      len - 2\n    );\n    store<u16>(buffer,       CharCode.DOT, 2);\n    store<u16>(buffer + len, CharCode.e,   2);\n    length += genExponent(buffer + len + 4, kk - 1);\n    return length + 2;\n  }\n}\n\nfunction dtoa_core(buffer: usize, value: f64): i32 {\n  var sign = i32(value < 0);\n  if (sign) {\n    value = -value;\n    store<u16>(buffer, CharCode.MINUS);\n  }\n  // assert(value > 0 && value <= 1.7976931348623157e308);\n  var len = grisu2(value, buffer, sign);\n  len = prettify(buffer + (sign << 1), len - sign, _K);\n  return len + sign;\n}\n\n// @ts-ignore: decorator\n@lazy @inline const dtoa_buf = memory.data(MAX_DOUBLE_LENGTH << 1);\n\nexport function dtoa(value: f64): String {\n  if (value == 0) return \"0.0\";\n  if (!isFinite(value)) {\n    if (isNaN(value)) return \"NaN\";\n    return select<String>(\"-Infinity\", \"Infinity\", value < 0);\n  }\n  var size = dtoa_core(dtoa_buf, value) << 1;\n  var result = changetype<String>(__new(size, idof<String>()));\n  memory.copy(changetype<usize>(result), dtoa_buf, size);\n  return result;\n}\n\nexport function itoa_buffered<T extends number>(buffer: usize, value: T): u32 {\n  var sign: u32 = 0;\n  if (isSigned<T>()) {\n    sign = u32(value < 0);\n    if (sign) {\n      value = changetype<T>(-value);\n      store<u16>(buffer, CharCode.MINUS);\n    }\n  }\n  if (ASC_SHRINK_LEVEL <= 1) {\n    if (isSigned<T>()) {\n      if (sizeof<T>() <= 4) {\n        if (<u32>value < 10) {\n          store<u16>(buffer + (sign << 1), value | CharCode._0);\n          return 1 + sign;\n        }\n      } else {\n        if (<u64>value < 10) {\n          store<u16>(buffer + (sign << 1), value | CharCode._0);\n          return 1 + sign;\n        }\n      }\n    } else {\n      if (value < 10) {\n        store<u16>(buffer, value | CharCode._0);\n        return 1;\n      }\n    }\n  }\n  var decimals = sign;\n  if (sizeof<T>() <= 4) {\n    decimals += decimalCount32(value);\n    utoa32_dec_core(buffer, value, decimals);\n  } else {\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\n      let val32 = <u32>value;\n      decimals += decimalCount32(val32);\n      utoa32_dec_core(buffer, val32, decimals);\n    } else {\n      decimals += decimalCount64High(value);\n      utoa64_dec_core(buffer, value, decimals);\n    }\n  }\n  return decimals;\n}\n\nexport function dtoa_buffered(buffer: usize, value: f64): u32 {\n  if (value == 0) {\n    store<u16>(buffer, CharCode._0);\n    store<u16>(buffer, CharCode.DOT, 2);\n    store<u16>(buffer, CharCode._0,  4);\n    return 3;\n  }\n  if (!isFinite(value)) {\n    if (isNaN(value)) {\n      store<u16>(buffer, CharCode.N);\n      store<u16>(buffer, CharCode.a, 2);\n      store<u16>(buffer, CharCode.N, 4);\n      return 3;\n    } else {\n      let sign = value < 0;\n      if (sign) {\n        store<u16>(buffer, CharCode.MINUS); // -\n        buffer += 2;\n      }\n      store<u64>(buffer, 0x690066006E0049, 0); // ifnI\n      store<u64>(buffer, 0x7900740069006E, 8); // ytin\n      return 8 + u32(sign);\n    }\n  }\n  return dtoa_core(buffer, value);\n}\n","import {\n  proc_exit,\n  fd_write,\n  iovec,\n  random_get,\n  tempbuf\n} from \"bindings/wasi\";\n\nimport {\n  MAX_DOUBLE_LENGTH,\n  decimalCount32,\n  dtoa_buffered\n} from \"util/number\";\n\n// @ts-ignore: decorator\n@global @inline const ASC_WASI = true; // eslint-disable-line @typescript-eslint/no-unused-vars\n\nfunction abort( // eslint-disable-line @typescript-eslint/no-unused-vars\n  message: string | null = null,\n  fileName: string | null = null,\n  lineNumber: u32 = 0,\n  columnNumber: u32 = 0\n): void {\n  // 0: iov.buf\n  // 4: iov.buf_len\n  // 8: len\n  // 12: buf...\n  const iovPtr: usize = 0;\n  const lenPtr: usize = iovPtr + offsetof<iovec>();\n  const bufPtr: usize = lenPtr + sizeof<usize>();\n  changetype<iovec>(iovPtr).buf = bufPtr;\n  var ptr = bufPtr;\n  store<u64>(ptr, 0x203A74726F6261); ptr += 7; // 'abort: '\n  if (message !== null) {\n    ptr += String.UTF8.encodeUnsafe(changetype<usize>(message), message.length, ptr);\n  }\n  store<u32>(ptr, 0x206E6920); ptr += 4; // ' in '\n  if (fileName !== null) {\n    ptr += String.UTF8.encodeUnsafe(changetype<usize>(fileName), fileName.length, ptr);\n  }\n  store<u8>(ptr++, 0x28); // (\n  var len = decimalCount32(lineNumber); ptr += len;\n  do {\n    let t = lineNumber / 10;\n    store<u8>(--ptr, 0x30 + lineNumber % 10);\n    lineNumber = t;\n  } while (lineNumber); ptr += len;\n  store<u8>(ptr++, 0x3A); // :\n  len = decimalCount32(columnNumber); ptr += len;\n  do {\n    let t = columnNumber / 10;\n    store<u8>(--ptr, 0x30 + columnNumber % 10);\n    columnNumber = t;\n  } while (columnNumber); ptr += len;\n  store<u16>(ptr, 0x0A29); ptr += 2; // )\\n\n  changetype<iovec>(iovPtr).buf_len = ptr - bufPtr;\n  fd_write(2, iovPtr, 1, lenPtr);\n  proc_exit(255);\n}\n\nfunction trace( // eslint-disable-line @typescript-eslint/no-unused-vars\n  message: string,\n  n: i32 = 0,\n  a0: f64 = 0,\n  a1: f64 = 0,\n  a2: f64 = 0,\n  a3: f64 = 0,\n  a4: f64 = 0\n): void {\n  // 0: iov.buf\n  // 4: iov.buf_len\n  // 8: len\n  // 12: buf...\n  var iovPtr = __alloc(offsetof<iovec>() + sizeof<usize>() + 1 + <usize>(max(String.UTF8.byteLength(message), MAX_DOUBLE_LENGTH << 1)));\n  var lenPtr = iovPtr + offsetof<iovec>();\n  var bufPtr = lenPtr + sizeof<usize>();\n  changetype<iovec>(iovPtr).buf = bufPtr;\n  store<u64>(bufPtr, 0x203A6563617274); // 'trace: '\n  changetype<iovec>(iovPtr).buf_len = 7;\n  fd_write(2, iovPtr, 1, lenPtr);\n  changetype<iovec>(iovPtr).buf_len = String.UTF8.encodeUnsafe(changetype<usize>(message), message.length, bufPtr);\n  fd_write(2, iovPtr, 1, lenPtr);\n  if (n) {\n    store<u8>(bufPtr++, 0x20); // space\n    changetype<iovec>(iovPtr).buf_len = 1 + String.UTF8.encodeUnsafe(bufPtr, dtoa_buffered(bufPtr, a0), bufPtr);\n    fd_write(2, iovPtr, 1, lenPtr);\n    if (n > 1) {\n      changetype<iovec>(iovPtr).buf_len = 1 + String.UTF8.encodeUnsafe(bufPtr, dtoa_buffered(bufPtr, a1), bufPtr);\n      fd_write(2, iovPtr, 1, lenPtr);\n      if (n > 2) {\n        changetype<iovec>(iovPtr).buf_len = 1 + String.UTF8.encodeUnsafe(bufPtr, dtoa_buffered(bufPtr, a2), bufPtr);\n        fd_write(2, iovPtr, 1, lenPtr);\n        if (n > 3) {\n          changetype<iovec>(iovPtr).buf_len = 1 + String.UTF8.encodeUnsafe(bufPtr, dtoa_buffered(bufPtr, a3), bufPtr);\n          fd_write(2, iovPtr, 1, lenPtr);\n          if (n > 4) {\n            changetype<iovec>(iovPtr).buf_len = 1 + String.UTF8.encodeUnsafe(bufPtr, dtoa_buffered(bufPtr, a4), bufPtr);\n            fd_write(2, iovPtr, 1, lenPtr);\n          }\n        }\n      }\n    }\n    --bufPtr;\n  }\n  store<u8>(bufPtr, 0x0A); // \\n\n  changetype<iovec>(iovPtr).buf_len = 1;\n  fd_write(2, iovPtr, 1, lenPtr);\n  __free(iovPtr);\n}\n\nfunction seed(): f64 { // eslint-disable-line @typescript-eslint/no-unused-vars\n  var rand: u64;\n  do {\n    random_get(tempbuf, 8);\n    rand = load<u64>(tempbuf);\n  } while (!rand);\n  return reinterpret<f64>(rand);\n}\n\nexport * from \"bindings/wasi\";\n","export enum WireType {\n  /**\n   * int32, int64, uint32, uint64, sint32, sint64, bool, enum\n   */\n  VARINT = 0,\n  /**\n   * fixed64, sfixed64, double\n   */\n  FIXED_64 = 1,\n  /**\n   * string, bytes, embedded messages, packed repeated fields\n   */\n  LENGTH_DELIMITED = 2,\n  /**\n   * groups (deprecated)\n   * @deprecated\n   */\n  START_GROUP = 3,\n  /**\n   * groups (deprecated)\n   * @deprecated\n   */\n  END_GROUP = 4,\n  /**\n   * fixed32, sfixed32, float\n   */\n  FIXED_32 = 5,\n}\n","// This file is shared with the compiler and must remain portable\n\n/** Runtime types. */\nexport enum Runtime {\n  /** Simple bump allocator without GC. */\n  Stub = 0,\n  /** Stop the world semi-automatic GC. */\n  Minimal = 1,\n  /** incremental GC. */\n  Incremental = 2,\n}\n","import { compareImpl } from \"./string\";\n\ntype Comparator<T> = (a: T, b: T) => i32;\n\n// @ts-ignore: decorator\n@lazy @inline const EMPTY = u32.MAX_VALUE;\n// @ts-ignore: decorator\n@inline const INSERTION_SORT_THRESHOLD = 48;\n// @ts-ignore: decorator\n@inline const MIN_RUN_LENGTH = 32;\n\n// @ts-ignore: decorator\n@inline\nfunction log2u(n: u32): u32 {\n  return 31 - clz(n);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function COMPARATOR<T>(): Comparator<T> {\n  if (isInteger<T>()) {\n    if (isSigned<T>() && sizeof<T>() <= 4) {\n      return (a, b) => i32(a) - i32(b);\n    } else {\n      return (a, b) => i32(a > b) - i32(a < b);\n    }\n  } else if (isFloat<T>()) {\n    if (sizeof<T>() == 4) {\n      return (a, b) => {\n        var ia = reinterpret<i32>(f32(a));\n        var ib = reinterpret<i32>(f32(b));\n        ia ^= ia >> 31 >>> 1;\n        ib ^= ib >> 31 >>> 1;\n        return i32(ia > ib) - i32(ia < ib);\n      };\n    } else {\n      return (a, b) => {\n        var ia = reinterpret<i64>(f64(a));\n        var ib = reinterpret<i64>(f64(b));\n        ia ^= ia >> 63 >>> 1;\n        ib ^= ib >> 63 >>> 1;\n        return i32(ia > ib) - i32(ia < ib);\n      };\n    }\n  } else if (isString<T>()) {\n    return (a, b) => {\n      if (a === b || a === null || b === null) return 0;\n      var alen = changetype<string>(a).length;\n      var blen = changetype<string>(b).length;\n      if (!(alen | blen)) return 0;\n      if (!alen) return -1;\n      if (!blen) return  1;\n      let res = compareImpl(\n        changetype<string>(a), 0,\n        changetype<string>(b), 0,\n        <usize>min(alen, blen)\n      );\n      return res ? res : alen - blen;\n    };\n  } else {\n    return (a, b) => i32(a > b) - i32(a < b);\n  }\n}\n\n// Power Sort implementation (stable) from paper \"Nearly-Optimal Mergesorts\"\n// https://arxiv.org/pdf/1805.04154.pdf\n// This method usually outperform TimSort.\n// TODO: refactor c >>> 31 to c < 0 when binaryen will support this opt\nexport function SORT<T>(\n  ptr: usize,\n  len: i32,\n  comparator: Comparator<T>\n): void {\n  if (len <= INSERTION_SORT_THRESHOLD) {\n    if (len <= 1) return;\n    if (ASC_SHRINK_LEVEL < 1) {\n      switch (len) {\n        case 3: {\n          let a = load<T>(ptr, 0);\n          let b = load<T>(ptr, 1 << alignof<T>());\n          let c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 0);\n          a = select<T>(a, b, c);\n          b = load<T>(ptr, 2 << alignof<T>());\n          c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 1 << alignof<T>());\n          store<T>(ptr, select<T>(a, b, c), 2 << alignof<T>());\n        }\n        case 2: {\n          let a = load<T>(ptr, 0);\n          let b = load<T>(ptr, 1 << alignof<T>());\n          let c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 0);\n          store<T>(ptr, select<T>(a, b, c), 1 << alignof<T>());\n          return;\n        }\n      }\n    }\n    insertionSort<T>(ptr, 0, len - 1, 0, comparator);\n    return;\n  }\n\n  var lgPlus2         = log2u(len) + 2;\n  var lgPlus2Size     = lgPlus2 << alignof<u32>();\n  var leftRunStartBuf = __alloc(lgPlus2Size << 1);\n  var leftRunEndBuf   = leftRunStartBuf + lgPlus2Size;\n\n  for (let i: u32 = 0; i < lgPlus2; ++i) {\n    store<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()), EMPTY);\n  }\n\n  var buffer = __alloc(len << alignof<T>());\n\n  var hi   = len - 1;\n  var endA = extendRunRight<T>(ptr, 0, hi, comparator);\n  var lenA = endA + 1;\n\n  if (lenA < MIN_RUN_LENGTH) {\n    endA = min(hi, MIN_RUN_LENGTH - 1);\n    insertionSort<T>(ptr, 0, endA, lenA, comparator);\n  }\n\n  var top: u32 = 0, startA = 0;\n  while (endA < hi) {\n    let startB = endA + 1;\n    let endB = extendRunRight<T>(ptr, startB, hi, comparator);\n    let lenB = endB - startB + 1;\n\n    if (lenB < MIN_RUN_LENGTH) {\n      endB = min(hi, startB + MIN_RUN_LENGTH - 1);\n      insertionSort<T>(ptr, startB, endB, lenB, comparator);\n    }\n\n    let k = nodePower(0, hi, startA, startB, endB);\n\n    for (let i = top; i > k; --i) {\n      let start = load<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()));\n      if (start != EMPTY) {\n        mergeRuns<T>(\n          ptr,\n          start,\n          load<u32>(leftRunEndBuf + (<usize>i << alignof<u32>())) + 1,\n          endA,\n          buffer,\n          comparator\n        );\n        startA = start;\n        store<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()), EMPTY);\n      }\n    }\n\n    store<u32>(leftRunStartBuf + (<usize>k << alignof<u32>()), startA);\n    store<u32>(leftRunEndBuf   + (<usize>k << alignof<u32>()), endA);\n    startA = startB;\n    endA = endB;\n    top = k;\n  }\n\n  for (let i = top; i != 0; --i) {\n    let start = load<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()));\n    if (start != EMPTY) {\n      mergeRuns<T>(\n        ptr,\n        start,\n        load<u32>(leftRunEndBuf + (<usize>i << alignof<u32>())) + 1,\n        hi,\n        buffer,\n        comparator\n      );\n    }\n  }\n  // dealloc aux buffers\n  __free(buffer);\n  __free(leftRunStartBuf);\n}\n\nfunction insertionSort<T>(\n  ptr: usize,\n  left: i32,\n  right: i32,\n  presorted: i32,\n  comparator: Comparator<T>\n): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    // slightly improved original insertion sort\n    for (let i = left + presorted; i <= right; ++i) {\n      let j = i - 1;\n      let a = load<T>(ptr + (<usize>i << alignof<T>()));\n      while (j >= left) {\n        let b = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, b) < 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), b, 1 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), a, 1 << alignof<T>());\n    }\n  } else {\n    // even-odd two-way insertion sort which allow increase minRunLen\n    let range = right - left + 1;\n    let i = left + select(range & 1, presorted - ((range - presorted) & 1), presorted == 0);\n    for (; i <= right; i += 2) {\n      let a = load<T>(ptr + (<usize>i << alignof<T>()), 0);\n      let b = load<T>(ptr + (<usize>i << alignof<T>()), 1 << alignof<T>());\n      let min = b, max = a;\n      if (comparator(a, b) <= 0) {\n        min = a, max = b;\n      }\n      let j = i - 1;\n      while (j >= left) {\n        a = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, max) > 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), a, 2 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), max, 2 << alignof<T>());\n      while (j >= left) {\n        a = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, min) > 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), a, 1 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), min, 1 << alignof<T>());\n    }\n  }\n}\n\nfunction nodePower(left: u32, right: u32, startA: u32, startB: u32, endB: u32): u32 {\n  var n: u64 = right - left + 1;\n  var s = startB - (left << 1);\n  var l = startA + s;\n  var r = endB   + s + 1;\n  var a = (<u64>l << 30) / n;\n  var b = (<u64>r << 30) / n;\n  return clz(<u32>(a ^ b));\n}\n\nfunction extendRunRight<T>(\n  ptr: usize,\n  i: i32,\n  right: i32,\n  comparator: Comparator<T>\n): i32 {\n  if (i == right) return i;\n  var j = i;\n  if (comparator(\n    load<T>(ptr + (<usize>  j << alignof<T>())),\n    load<T>(ptr + (<usize>++j << alignof<T>()))\n  ) > 0) {\n    while (\n      j < right &&\n      (comparator(\n        load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>()),\n        load<T>(ptr + (<usize>j << alignof<T>()))\n      ) >>> 31) // < 0\n    ) ++j;\n    // reverse\n    let k = j;\n    while (i < k) {\n      let tmp = load<T>(ptr + (<usize>i << alignof<T>()));\n      store<T>(ptr + (<usize>i << alignof<T>()), load<T>(ptr + (<usize>k << alignof<T>()))); ++i;\n      store<T>(ptr + (<usize>k << alignof<T>()), tmp); --k;\n    }\n  } else {\n    while (\n      j < right &&\n      comparator(\n        load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>()),\n        load<T>(ptr + (<usize>j << alignof<T>()))\n      ) >= 0\n    ) ++j;\n  }\n  return j;\n}\n\n// Merges arr[l..m - 1] and arr[m..r]\nfunction mergeRuns<T>(\n  ptr: usize,\n  l: i32,\n  m: i32,\n  r: i32,\n  buffer: usize,\n  comparator: Comparator<T>\n): void {\n  --m;\n  var i: i32, j: i32, t = r + m;\n  for (i = m + 1; i > l; --i) {\n    store<T>(\n      buffer + (<usize>(i - 1) << alignof<T>()),\n      load<T>(ptr + (<usize>(i - 1) << alignof<T>()))\n    );\n  }\n  for (j = m; j < r; ++j) {\n    store<T>(\n      buffer + (<usize>(t - j) << alignof<T>()),\n      load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>())\n    );\n  }\n  for (let k = l; k <= r; ++k) {\n    let a = load<T>(buffer + (<usize>j << alignof<T>()));\n    let b = load<T>(buffer + (<usize>i << alignof<T>()));\n    if (comparator(a, b) < 0) {\n      store<T>(ptr + (<usize>k << alignof<T>()), a);\n      --j;\n    } else {\n      store<T>(ptr + (<usize>k << alignof<T>()), b);\n      ++i;\n    }\n  }\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { compareImpl, strtol, strtod, isSpace, isAscii, isFinalSigma, toLower8, toUpper8 } from \"./util/string\";\nimport { SPECIALS_UPPER, casemap, bsearch } from \"./util/casemap\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_UNPAIRED_SURROGATE } from \"./util/error\";\nimport { idof } from \"./builtins\";\nimport { Array } from \"./array\";\n\n@final export abstract class String {\n\n  @lazy static readonly MAX_LENGTH: i32 = <i32>(BLOCK_MAXSIZE >>> alignof<u16>());\n\n  static fromCharCode(unit: i32, surr: i32 = -1): String {\n    var hasSur = surr > 0;\n    var out = changetype<String>(__new(2 << i32(hasSur), idof<String>()));\n    store<u16>(changetype<usize>(out), <u16>unit);\n    if (hasSur) store<u16>(changetype<usize>(out), <u16>surr, 2);\n    return out;\n  }\n\n  static fromCharCodes(units: Array<i32>): String {\n    var length = units.length;\n    var out = changetype<String>(__new(<usize>length << 1, idof<String>()));\n    var ptr = units.dataStart;\n    for (let i = 0; i < length; ++i) {\n      store<u16>(changetype<usize>(out) + (<usize>i << 1), load<i32>(ptr + (<usize>i << 2)));\n    }\n    return out;\n  }\n\n  static fromCodePoint(code: i32): String {\n    var hasSur = <u32>code > 0xFFFF;\n    var out = changetype<String>(__new(2 << i32(hasSur), idof<String>()));\n    if (!hasSur) {\n      store<u16>(changetype<usize>(out), <u16>code);\n    } else {\n      // Checks valid code point range\n      assert(<u32>code <= 0x10FFFF);\n      code -= 0x10000;\n      let hi = (code & 0x03FF) | 0xDC00;\n      let lo = code >>> 10 | 0xD800;\n      store<u32>(changetype<usize>(out), lo | hi << 16);\n    }\n    return out;\n  }\n\n  @builtin static raw(parts: TemplateStringsArray, ...args: unknown[]): string { return unreachable(); }\n\n  get length(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize >> 1;\n  }\n\n  at(pos: i32): String {\n    var len = this.length;\n    pos += select(0, len, pos >= 0);\n    if (<u32>pos >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    var out = __new(2, idof<String>());\n    store<u16>(out, load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\n    return changetype<String>(out); // retains\n  }\n\n  @operator(\"[]\") charAt(pos: i32): String {\n    if (<u32>pos >= <u32>this.length) return changetype<String>(\"\");\n    var out = changetype<String>(__new(2, idof<String>()));\n    store<u16>(changetype<usize>(out), load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\n    return out;\n  }\n\n  charCodeAt(pos: i32): i32 {\n    if (<u32>pos >= <u32>this.length) return -1; // (NaN)\n    return load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n  }\n\n  codePointAt(pos: i32): i32 {\n    var len = this.length;\n    if (<u32>pos >= <u32>len) return -1; // (undefined)\n    var first = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n    if ((first & 0xFC00) != 0xD800 || pos + 1 == len) return first;\n    var second = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1), 2);\n    if ((second & 0xFC00) != 0xDC00) return first;\n    return (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n  }\n\n  @operator(\"+\") private static __concat(left: String, right: String): String {\n    return left.concat(right);\n  }\n\n  concat(other: String): String {\n    var thisSize: isize = this.length << 1;\n    var otherSize: isize = other.length << 1;\n    var outSize: usize = thisSize + otherSize;\n    if (outSize == 0) return changetype<String>(\"\");\n    var out = changetype<String>(__new(outSize, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\n    memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(other), otherSize);\n    return out;\n  }\n\n  endsWith(search: String, end: i32 = String.MAX_LENGTH): bool {\n    end = min(max(end, 0), this.length);\n    var searchLength = <isize>search.length;\n    var searchStart = <isize>end - searchLength;\n    if (searchStart < 0) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  @operator(\"==\") private static __eq(left: String | null, right: String | null): bool {\n    if (left === right) return true;\n    if (left === null || right === null) return false;\n    var leftLength = left.length;\n    if (leftLength != right.length) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(left, 0, right, 0, leftLength);\n  }\n\n  @operator.prefix(\"!\")\n  private static __not(str: String | null): bool {\n    return str === null || !str.length;\n  }\n\n  @operator(\"!=\")\n  private static __ne(left: String | null, right: String | null): bool {\n    return !this.__eq(left, right);\n  }\n\n  @operator(\">\") private static __gt(left: String, right: String): bool {\n    if (left === right) return false;\n    var leftLength  = left.length;\n    if (!leftLength) return false;\n    var rightLength = right.length;\n    if (!rightLength) return true;\n    // @ts-ignore: string <-> String\n    var res = compareImpl(left, 0, right, 0, min(leftLength, rightLength));\n    return res ? res > 0 : leftLength > rightLength;\n  }\n\n  @operator(\">=\") private static __gte(left: String, right: String): bool {\n    return !this.__lt(left, right);\n  }\n\n  @operator(\"<\") private static __lt(left: String, right: String): bool {\n    if (left === right) return false;\n    var rightLength = right.length;\n    if (!rightLength) return false;\n    var leftLength  = left.length;\n    if (!leftLength) return true;\n    // @ts-ignore: string <-> String\n    var res = compareImpl(left, 0, right, 0, min(leftLength, rightLength));\n    return res ? res < 0 : leftLength < rightLength;\n  }\n\n  @operator(\"<=\") private static __lte(left: String, right: String): bool {\n    return !this.__gt(left, right);\n  }\n\n  includes(search: String, start: i32 = 0): bool {\n    return this.indexOf(search, start) != -1;\n  }\n\n  indexOf(search: String, start: i32 = 0): i32 {\n    var searchLen = <isize>search.length;\n    if (!searchLen) return 0;\n    var len = <isize>this.length;\n    if (!len) return -1;\n    var searchStart = min(max(<isize>start, 0), len);\n    for (len -= searchLen; searchStart <= len; ++searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  lastIndexOf(search: String, start: i32 = i32.MAX_VALUE): i32 {\n    var searchLen = <isize>search.length;\n    if (!searchLen) return this.length;\n    var len = this.length;\n    if (!len) return -1;\n    var searchStart = min(max(<isize>start, 0), <isize>len - searchLen);\n    for (; searchStart >= 0; --searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  // TODO: implement full locale comparison with locales and Collator options\n  localeCompare(other: String): i32 {\n    if (other === this) return 0; // compare pointers\n    var len: isize = this.length;\n    var otherLen: isize = other.length;\n    if (otherLen != len) return select(1, -1, len > otherLen);\n    if (!otherLen) return 0; // \"\" == \"\"\n    // @ts-ignore: string <-> String\n    return compareImpl(this, 0, other, 0, otherLen);\n  }\n\n  startsWith(search: String, start: i32 = 0): bool {\n    var len = <isize>this.length;\n    var searchStart = min(max(<isize>start, 0), len);\n    var searchLength = <isize>search.length;\n    if (searchLength + searchStart > len) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  substr(start: i32, length: i32 = i32.MAX_VALUE): String { // legacy\n    var intStart: isize = start;\n    var end: isize = length;\n    var len: isize = this.length;\n    if (intStart < 0) intStart = max(len + intStart, 0);\n    var size = min(max(end, 0), len - intStart) << 1;\n    if (size <= 0) return changetype<String>(\"\");\n    var out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + (intStart << 1), size);\n    return out;\n  }\n\n  substring(start: i32, end: i32 = i32.MAX_VALUE): String {\n    var len: isize = this.length;\n    var finalStart = min<isize>(max(start, 0), len);\n    var finalEnd = min<isize>(max(end, 0), len);\n    var fromPos = min<isize>(finalStart, finalEnd) << 1;\n    var toPos = max<isize>(finalStart, finalEnd) << 1;\n    var size = toPos - fromPos;\n    if (!size) return changetype<String>(\"\");\n    if (!fromPos && toPos == len << 1) return this;\n    var out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + fromPos, size);\n    return out;\n  }\n\n  trim(): String {\n    var len = this.length;\n    var size: usize = len << 1;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    var offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2; size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (!offset && size == len << 1) return this;\n    var out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + offset, size);\n    return out;\n  }\n\n  @inline\n  trimLeft(): String {\n    return this.trimStart();\n  }\n\n  @inline\n  trimRight(): String {\n    return this.trimEnd();\n  }\n\n  trimStart(): String {\n    var size = <usize>this.length << 1;\n    var offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2;\n    }\n    if (!offset) return this;\n    size -= offset;\n    if (!size) return changetype<String>(\"\");\n    var out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + offset, size);\n    return out;\n  }\n\n  trimEnd(): String {\n    var originalSize = <usize>this.length << 1;\n    var size = originalSize;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (size == originalSize) return this;\n    var out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), size);\n    return out;\n  }\n\n  padStart(length: i32, pad: string = \" \"): String {\n    var thisSize = <usize>this.length << 1;\n    var targetSize = <usize>length << 1;\n    var padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    var prependSize = targetSize - thisSize;\n    var out = changetype<String>(__new(targetSize, idof<String>()));\n    if (prependSize > padSize) {\n      let repeatCount = (prependSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = prependSize - restBase;\n      memory.repeat(changetype<usize>(out), changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(changetype<usize>(out) + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(changetype<usize>(out), changetype<usize>(pad), prependSize);\n    }\n    memory.copy(changetype<usize>(out) + prependSize, changetype<usize>(this), thisSize);\n    return out;\n  }\n\n  padEnd(length: i32, pad: string = \" \"): String {\n    var thisSize = <usize>this.length << 1;\n    var targetSize = <usize>length << 1;\n    var padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    var appendSize = targetSize - thisSize;\n    var out = changetype<String>(__new(targetSize, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\n    if (appendSize > padSize) {\n      let repeatCount = (appendSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = appendSize - restBase;\n      memory.repeat(changetype<usize>(out) + thisSize, changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(changetype<usize>(out) + thisSize + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(pad), appendSize);\n    }\n    return out;\n  }\n\n  repeat(count: i32 = 0): String {\n    var length = this.length;\n\n    // Most browsers can't handle strings 1 << 28 chars or longer\n    if (count < 0 || <u64>length * count > (1 << 28)) {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n\n    if (count == 0 || !length) return changetype<String>(\"\");\n    if (count == 1) return this;\n    var out = changetype<String>(__new((length * count) << 1, idof<String>()));\n    memory.repeat(changetype<usize>(out), changetype<usize>(this), <usize>length << 1, count);\n    return out;\n  }\n\n  replace(search: String, replacement: String): String {\n    var len: usize = this.length;\n    var slen: usize = search.length;\n    if (len <= slen) {\n      return len < slen ? this : select<String>(replacement, this, search == this);\n    }\n    var index: isize = this.indexOf(search);\n    if (~index) {\n      let rlen: usize = replacement.length;\n      len -= slen;\n      let olen = len + rlen;\n      if (olen) {\n        let out = changetype<String>(__new(olen << 1, idof<String>()));\n        memory.copy(changetype<usize>(out), changetype<usize>(this), index << 1);\n        memory.copy(\n          changetype<usize>(out) + (index << 1),\n          changetype<usize>(replacement),\n          rlen << 1\n        );\n        memory.copy(\n          changetype<usize>(out) + ((index + rlen) << 1),\n          changetype<usize>(this) + ((index + slen) << 1),\n          (len - index) << 1\n        );\n        return out;\n      }\n    }\n    return this;\n  }\n\n  replaceAll(search: String, replacement: String): String {\n    var thisLen: usize = this.length;\n    var searchLen: usize = search.length;\n    if (thisLen <= searchLen) {\n      return thisLen < searchLen\n        ? this\n        : select<String>(replacement, this, search == this);\n    }\n    var replaceLen: usize = replacement.length;\n    if (!searchLen) {\n      if (!replaceLen) return this;\n      // Special case: 'abc'.replaceAll('', '-') -> '-a-b-c-'\n      let out = changetype<String>(__new((thisLen + (thisLen + 1) * replaceLen) << 1, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(replacement), replaceLen << 1);\n      let offset = replaceLen;\n      for (let i: usize = 0; i < thisLen; ++i) {\n        store<u16>(\n          changetype<usize>(out) + (offset++ << 1),\n          load<u16>(changetype<usize>(this) + (i << 1))\n        );\n        memory.copy(\n          changetype<usize>(out) + (offset << 1),\n          changetype<usize>(replacement),\n          replaceLen << 1\n        );\n        offset += replaceLen;\n      }\n      return out;\n    }\n    var prev: isize = 0, next: isize = 0;\n    if (searchLen == replaceLen) {\n      // Fast path when search and replacement have same length\n      let outSize = thisLen << 1;\n      let out = changetype<String>(__new(outSize, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(this), outSize);\n      while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n        memory.copy(changetype<usize>(out) + (next << 1), changetype<usize>(replacement), replaceLen << 1);\n        prev = next + searchLen;\n      }\n      return out;\n    }\n    var out: String | null = null, offset: usize = 0, outSize = thisLen;\n    while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n      if (!out) out = changetype<String>(__new(thisLen << 1, idof<String>()));\n      let chunk = next - prev;\n      if (offset + chunk + replaceLen > outSize) {\n        outSize <<= 1;\n        out = changetype<String>(__renew(changetype<usize>(out), outSize << 1));\n      }\n      memory.copy(\n        changetype<usize>(out) + (offset << 1),\n        changetype<usize>(this) + (prev << 1),\n        chunk << 1\n      );\n      offset += chunk;\n      memory.copy(\n        changetype<usize>(out) + (offset << 1),\n        changetype<usize>(replacement),\n        replaceLen << 1\n      );\n      offset += replaceLen;\n      prev = next + searchLen;\n    }\n    if (out) {\n      let rest = thisLen - prev;\n      if (offset + rest > outSize) {\n        outSize <<= 1;\n        out = changetype<String>(__renew(changetype<usize>(out), outSize << 1));\n      }\n      if (rest) {\n        memory.copy(\n          changetype<usize>(out) + (offset << 1),\n          changetype<usize>(this) + (prev << 1),\n          rest << 1\n        );\n      }\n      rest += offset;\n      if (outSize > rest) {\n        out = changetype<String>(__renew(changetype<usize>(out), rest << 1));\n      }\n      return out;\n    }\n    return this;\n  }\n\n  slice(start: i32, end: i32 = i32.MAX_VALUE): String {\n    var len = this.length;\n    start = start < 0 ? max(start + len, 0) : min(start, len);\n    end   = end   < 0 ? max(end   + len, 0) : min(end,   len);\n    len   = end - start;\n    if (len <= 0) return changetype<String>(\"\");\n    var out = changetype<String>(__new(len << 1, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n    return out;\n  }\n\n  split(separator: String | null = null, limit: i32 = i32.MAX_VALUE): String[] {\n    if (!limit) return changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n    if (separator === null) return [this];\n    var length: isize = this.length;\n    var sepLen = separator.length;\n    if (limit < 0) limit = i32.MAX_VALUE;\n    if (!sepLen) {\n      if (!length) return changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n      // split by chars\n      length = min<isize>(length, <isize>limit);\n      let result = changetype<String[]>(__newArray(<i32>length, alignof<String>(), idof<Array<String>>()));\n      // @ts-ignore: cast\n      let resultStart = result.dataStart as usize;\n      for (let i: isize = 0; i < length; ++i) {\n        let charStr = changetype<String>(__new(2, idof<String>()));\n        store<u16>(changetype<usize>(charStr), load<u16>(changetype<usize>(this) + (<usize>i << 1)));\n        store<usize>(resultStart + (<usize>i << alignof<usize>()), changetype<usize>(charStr)); // result[i] = charStr\n        __link(changetype<usize>(result), changetype<usize>(charStr), true);\n      }\n      return result;\n    } else if (!length) {\n      let result = changetype<String[]>(__newArray(1, alignof<String>(), idof<Array<String>>()));\n      // @ts-ignore: cast\n      store<usize>(result.dataStart as usize, changetype<usize>(\"\")); // static \"\"\n      return result;\n    }\n    var result = changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n    var end = 0, start = 0, i = 0;\n    while (~(end = this.indexOf(separator, start))) {\n      let len = end - start;\n      if (len > 0) {\n        let out = changetype<String>(__new(<usize>len << 1, idof<String>()));\n        memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n        result.push(out);\n      } else {\n        result.push(changetype<String>(\"\"));\n      }\n      if (++i == limit) return result;\n      start = end + sepLen;\n    }\n    if (!start) { // also means: loop above didn't do anything\n      result.push(this);\n      return result;\n    }\n    var len = length - start;\n    if (len > 0) {\n      let out = changetype<String>(__new(<usize>len << 1, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n      result.push(out);\n    } else {\n      result.push(changetype<String>(\"\")); // static \"\"\n    }\n    return result;\n  }\n\n  toLowerCase(): String {\n    var len = <usize>this.length;\n    if (!len) return this;\n    var codes = changetype<String>(__new(len * 2 * 2, idof<String>()));\n    var j: usize = 0;\n    for (let i: usize = 0; i < len; ++i, ++j) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\n      if (isAscii(c)) {\n        store<u16>(changetype<usize>(codes) + (j << 1), toLower8(c));\n      } else {\n        // check and read surrogate pair\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\n            let c0 = c;\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\n            ++i;\n            if (c >= 0x20000) {\n              store<u32>(changetype<usize>(codes) + (j << 1), c0 | (c1 << 16));\n              ++j;\n              continue;\n            }\n          }\n        }\n        // check special casing for lower table. It has one ently so instead lookup we just inline this.\n        if (c == 0x0130) {\n          // 0x0130 -> [0x0069, 0x0307]\n          store<u32>(changetype<usize>(codes) + (j << 1), (0x0307 << 16) | 0x0069);\n          ++j;\n        } else if (c == 0x03A3) { // 'Σ'\n          // Σ maps to σ but except at the end of a word where it maps to ς\n          let sigma = 0x03C3; // σ\n          if (len > 1 && isFinalSigma(changetype<usize>(this), i, len)) {\n            sigma = 0x03C2; // ς\n          }\n          store<u16>(changetype<usize>(codes) + (j << 1), sigma);\n        } else if (c - 0x24B6 <= 0x24CF - 0x24B6) {\n          // Range 0x24B6 <= c <= 0x24CF not covered by casemap and require special early handling\n          store<u16>(changetype<usize>(codes) + (j << 1), c + 26);\n        } else {\n          let code = casemap(c, 0) & 0x1FFFFF;\n          if (code < 0x10000) {\n            store<u16>(changetype<usize>(codes) + (j << 1), code);\n          } else {\n            // store as surrogare pair\n            code -= 0x10000;\n            let lo = (code >>> 10) | 0xD800;\n            let hi = (code & 0x03FF) | 0xDC00;\n            store<u32>(changetype<usize>(codes) + (j << 1), lo | (hi << 16));\n            ++j;\n          }\n        }\n      }\n    }\n    return changetype<String>(__renew(changetype<usize>(codes), j << 1));\n  }\n\n  toUpperCase(): String {\n    var len = <usize>this.length;\n    if (!len) return this;\n    var codes = changetype<String>(__new(len * 3 * 2, idof<String>()));\n    var specialsPtr = changetype<usize>(SPECIALS_UPPER);\n    var specialsLen = SPECIALS_UPPER.length;\n    var j: usize = 0;\n    for (let i: usize = 0; i < len; ++i, ++j) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\n      if (isAscii(c)) {\n        store<u16>(changetype<usize>(codes) + (j << 1), toUpper8(c));\n      } else {\n        // check and read surrogate pair\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\n            let c0 = c;\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\n            ++i;\n            if (c >= 0x20000) {\n              store<u32>(changetype<usize>(codes) + (j << 1), c0 | (c1 << 16));\n              ++j;\n              continue;\n            }\n          }\n        }\n        // Range 0x24D0 <= c <= 0x24E9 not covered by casemap and require special early handling\n        if (c - 0x24D0 <= 0x24E9 - 0x24D0) {\n          // monkey patch\n          store<u16>(changetype<usize>(codes) + (j << 1), c - 26);\n        } else {\n          let index: usize = -1;\n          // Fast range check. See first and last rows in specialsUpper table\n          if (c - 0x00DF <= 0xFB17 - 0x00DF) {\n            index = <usize>bsearch(c, specialsPtr, specialsLen);\n          }\n          if (~index) {\n            // load next 3 code points from row with `index` offset for specialsUpper table\n            let ab = load<u32>(specialsPtr + (index << 1), 2);\n            let cc = load<u16>(specialsPtr + (index << 1), 6);\n            store<u32>(changetype<usize>(codes) + (j << 1), ab, 0);\n            store<u16>(changetype<usize>(codes) + (j << 1), cc, 4);\n            j += 1 + usize(cc != 0);\n          } else {\n            let code = casemap(c, 1) & 0x1FFFFF;\n            if (code < 0x10000) {\n              store<u16>(changetype<usize>(codes) + (j << 1), code);\n            } else {\n              // store as surrogare pair\n              code -= 0x10000;\n              let lo = (code >>> 10) | 0xD800;\n              let hi = (code & 0x03FF) | 0xDC00;\n              store<u32>(changetype<usize>(codes) + (j << 1), lo | (hi << 16));\n              ++j;\n            }\n          }\n        }\n      }\n    }\n    return changetype<String>(__renew(changetype<usize>(codes), j << 1));\n  }\n\n  toString(): String {\n    return this;\n  }\n}\n\n// @ts-ignore: nolib\nexport type string = String;\n\nexport function parseInt(str: string, radix: i32 = 0): f64 {\n  return strtol<f64>(str, radix);\n}\n\nexport function parseFloat(str: string): f64 {\n  return strtod(str);\n}\n\n// Encoding helpers\nexport namespace String {\n\n  export namespace UTF8 {\n\n    export const enum ErrorMode {\n      WTF8,\n      REPLACE,\n      ERROR\n    }\n\n    export function byteLength(str: string, nullTerminated: bool = false): i32 {\n      var strOff = changetype<usize>(str);\n      var strEnd = strOff + <usize>changetype<OBJECT>(changetype<usize>(str) - TOTAL_OVERHEAD).rtSize;\n      var bufLen = i32(nullTerminated);\n      while (strOff < strEnd) {\n        let c1 = <u32>load<u16>(strOff);\n        if (c1 < 128) {\n          // @ts-ignore: cast\n          if (nullTerminated & !c1) break;\n          bufLen += 1;\n        } else if (c1 < 2048) {\n          bufLen += 2;\n        } else {\n          if ((c1 & 0xFC00) == 0xD800 && strOff + 2 < strEnd) {\n            if ((<u32>load<u16>(strOff, 2) & 0xFC00) == 0xDC00) {\n              bufLen += 4; strOff += 4;\n              continue;\n            }\n          }\n          bufLen += 3;\n        }\n        strOff += 2;\n      }\n      return bufLen;\n    }\n\n    export function encode(str: string, nullTerminated: bool = false, errorMode: ErrorMode = ErrorMode.WTF8): ArrayBuffer {\n      var buf = changetype<ArrayBuffer>(__new(<usize>byteLength(str, nullTerminated), idof<ArrayBuffer>()));\n      encodeUnsafe(changetype<usize>(str), str.length, changetype<usize>(buf), nullTerminated, errorMode);\n      return buf;\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function encodeUnsafe(str: usize, len: i32, buf: usize, nullTerminated: bool = false, errorMode: ErrorMode = ErrorMode.WTF8): usize {\n      var strEnd = str + (<usize>len << 1);\n      var bufOff = buf;\n      while (str < strEnd) {\n        let c1 = <u32>load<u16>(str);\n        if (c1 < 128) {\n          store<u8>(bufOff, c1);\n          bufOff++;\n          // @ts-ignore: cast\n          if (nullTerminated & !c1) return bufOff - buf;\n        } else if (c1 < 2048) {\n          let b0 = c1 >> 6 | 192;\n          let b1 = c1 & 63 | 128;\n          store<u16>(bufOff, b1 << 8 | b0);\n          bufOff += 2;\n        } else {\n          // D800: 11011 0 0000000000 Lead\n          // DBFF: 11011 0 1111111111\n          // DC00: 11011 1 0000000000 Trail\n          // DFFF: 11011 1 1111111111\n          // F800: 11111 0 0000000000 Mask\n          // FC00: 11111 1 0000000000\n          if ((c1 & 0xF800) == 0xD800) {\n            if (c1 < 0xDC00 && str + 2 < strEnd) {\n              let c2 = <u32>load<u16>(str, 2);\n              if ((c2 & 0xFC00) == 0xDC00) {\n                c1 = 0x10000 + ((c1 & 0x03FF) << 10) | (c2 & 0x03FF);\n                let b0 = c1 >> 18 | 240;\n                let b1 = c1 >> 12 & 63 | 128;\n                let b2 = c1 >> 6  & 63 | 128;\n                let b3 = c1       & 63 | 128;\n                store<u32>(bufOff, b3 << 24 | b2 << 16 | b1 << 8 | b0);\n                bufOff += 4; str += 4;\n                continue;\n              }\n            }\n            if (errorMode != ErrorMode.WTF8) { // unlikely\n              if (errorMode == ErrorMode.ERROR) throw new Error(E_UNPAIRED_SURROGATE);\n              c1 = 0xFFFD;\n            }\n          }\n          let b0 = c1 >> 12 | 224;\n          let b1 = c1 >> 6  & 63 | 128;\n          let b2 = c1       & 63 | 128;\n          store<u16>(bufOff, b1 << 8 | b0);\n          store<u8>(bufOff, b2, 2);\n          bufOff += 3;\n        }\n        str += 2;\n      }\n      if (nullTerminated) {\n        store<u8>(bufOff++, 0);\n      }\n      return bufOff - buf;\n    }\n\n    export function decode(buf: ArrayBuffer, nullTerminated: bool = false): String {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength, nullTerminated);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize, nullTerminated: bool = false): String {\n      var bufOff = buf;\n      var bufEnd = buf + len;\n      assert(bufEnd >= bufOff); // guard wraparound\n      var str = changetype<String>(__new(len << 1, idof<String>())); // max is one u16 char per u8 byte\n      var strOff = changetype<usize>(str);\n      while (bufOff < bufEnd) {\n        let u0 = <u32>load<u8>(bufOff); ++bufOff;\n        if (!(u0 & 128)) {\n          // @ts-ignore: cast\n          if (nullTerminated & !u0) break;\n          store<u16>(strOff, u0);\n        } else {\n          if (bufEnd == bufOff) break;\n          let u1 = <u32>load<u8>(bufOff) & 63; ++bufOff;\n          if ((u0 & 224) == 192) {\n            store<u16>(strOff, (u0 & 31) << 6 | u1);\n          } else {\n            if (bufEnd == bufOff) break;\n            let u2 = <u32>load<u8>(bufOff) & 63; ++bufOff;\n            if ((u0 & 240) == 224) {\n              u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n            } else {\n              if (bufEnd == bufOff) break;\n              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | <u32>load<u8>(bufOff) & 63;\n              ++bufOff;\n            }\n            if (u0 < 0x10000) {\n              store<u16>(strOff, u0);\n            } else {\n              u0 -= 0x10000;\n              let lo = u0 >> 10 | 0xD800;\n              let hi = (u0 & 0x03FF) | 0xDC00;\n              store<u32>(strOff, lo | (hi << 16));\n              strOff += 2;\n            }\n          }\n        }\n        strOff += 2;\n      }\n      return changetype<String>(__renew(changetype<usize>(str), strOff - changetype<usize>(str)));\n    }\n  }\n\n  export namespace UTF16 {\n\n    export function byteLength(str: string): i32 {\n      return changetype<OBJECT>(changetype<usize>(str) - TOTAL_OVERHEAD).rtSize;\n    }\n\n    export function encode(str: string): ArrayBuffer {\n      var buf = changetype<ArrayBuffer>(__new(<usize>byteLength(str), idof<ArrayBuffer>()));\n      encodeUnsafe(changetype<usize>(str), str.length, changetype<usize>(buf));\n      return buf;\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function encodeUnsafe(str: usize, len: i32, buf: usize): usize {\n      var size = <usize>len << 1;\n      memory.copy(buf, changetype<usize>(str), size);\n      return size;\n    }\n\n    export function decode(buf: ArrayBuffer): String {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize): String {\n      var str = changetype<String>(__new(len &= ~1, idof<String>()));\n      memory.copy(changetype<usize>(str), buf, len);\n      return str;\n    }\n  }\n}\n\nexport class TemplateStringsArray extends Array<string> {\n  readonly raw: string[];\n}\n","// Common error messages for use across the standard library. Keeping error messages compact\n// and reusing them where possible ensures minimal static data in binaries.\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INDEXOUTOFRANGE: string = \"Index out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_VALUEOUTOFRANGE: string = \"Value out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDLENGTH: string = \"Invalid length\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ILLEGALGENTYPE: string = \"Illegal generic type\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_EMPTYARRAY: string = \"Array is empty\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_HOLEYARRAY: string = \"Element type must be nullable if array is holey\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOTIMPLEMENTED: string = \"Not implemented\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_KEYNOTFOUND: string = \"Key does not exist\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALLOCATION_TOO_LARGE: string = \"Allocation too large\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALREADY_PINNED: string = \"Object already pinned\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOT_PINNED: string = \"Object is not pinned\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_URI_MALFORMED: string = \"URI malformed\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDDATE: string = \"Invalid Date\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_UNPAIRED_SURROGATE: string = \"Unpaired surrogate\";\n","import { Typeinfo, TypeinfoFlags } from \"./shared/typeinfo\";\nimport { E_INDEXOUTOFRANGE } from \"./util/error\";\nimport { OBJECT, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { ArrayBufferView } from \"./arraybuffer\";\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __rtti_base: usize;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_globals(cookie: u32): void;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_members(ref: usize, cookie: u32): void;\n\n// @ts-ignore: decorator\n@unsafe\nexport function __typeinfo(id: u32): TypeinfoFlags {\n  var ptr = __rtti_base;\n  if (id > load<u32>(ptr)) throw new Error(E_INDEXOUTOFRANGE);\n  return changetype<Typeinfo>(ptr + sizeof<u32>() + id * offsetof<Typeinfo>()).flags;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __instanceof(ptr: usize, classId: u32): bool { // keyword\n  var id = changetype<OBJECT>(ptr - TOTAL_OVERHEAD).rtId;\n  var rttiBase = __rtti_base;\n  if (id <= load<u32>(rttiBase)) {\n    do if (id == classId) return true;\n    while (id = changetype<Typeinfo>(rttiBase + sizeof<u32>() + id * offsetof<Typeinfo>()).base);\n  }\n  return false;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __newBuffer(size: usize, id: u32, data: usize = 0): usize {\n  var buffer = __new(size, id);\n  if (data) memory.copy(buffer, data, size);\n  return buffer;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __newArray(length: i32, alignLog2: usize, id: u32, data: usize = 0): usize {\n  var bufferSize = <usize>length << alignLog2;\n  // make sure `buffer` is tracked by the shadow stack\n  var buffer = changetype<ArrayBuffer>(__newBuffer(bufferSize, idof<ArrayBuffer>(), data));\n  // ...since allocating the array may trigger GC steps\n  var array = __new(offsetof<i32[]>(), id);\n  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>(\"buffer\"));\n  __link(array, changetype<usize>(buffer), false);\n  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>(\"dataStart\"));\n  store<i32>(array, bufferSize, offsetof<ArrayBufferView>(\"byteLength\"));\n  store<i32>(array, length, offsetof<i32[]>(\"length_\"));\n  return array;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nfunction __tostack(ptr: usize): usize { // eslint-disable-line\n  return ptr;\n}\n\n// These are provided by the respective implementation, included as another entry file by asc:\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __alloc(size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __realloc(ptr: usize, size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __free(ptr: usize): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __new(size: usize, id: u32): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __renew(ptr: usize, size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __collect(): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __visit(ptr: usize, cookie: u32): void;\n","import { memcmp, memmove, memset } from \"./util/memory\";\nimport { E_NOTIMPLEMENTED } from \"./util/error\";\n\n/** Memory manager interface. */\nexport namespace memory {\n\n  /** Gets the size of the memory in pages. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function size(): i32;\n\n  /** Grows the memory by the given size in pages and returns the previous size in pages. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function grow(pages: i32): i32;\n\n  /** Fills a section in memory with the specified byte value. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function fill(dst: usize, c: u8, n: usize): void {\n    memset(dst, c, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Copies a section of memory to another. Has move semantics. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function copy(dst: usize, src: usize, n: usize): void {\n    memmove(dst, src, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Initializes a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Drops a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function drop(segmentIndex: u32): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Repeats a section of memory at a specific address. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function repeat(dst: usize, src: usize, srcLength: usize, count: usize): void {\n    var index: usize = 0;\n    var total = srcLength * count;\n    while (index < total) {\n      memory.copy(dst + index, src, srcLength);\n      index += srcLength;\n    }\n  }\n\n  /** Compares a section of memory to another. */\n  // @ts-ignore: decorator\n  @inline\n  export function compare(vl: usize, vr: usize, n: usize): i32 {\n    return memcmp(vl, vr, n);\n  }\n\n  /** Gets a pointer to a static chunk of memory of the given size. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function data<T>(size: T, align?: i32): usize;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __data_end: usize;\n\n// @ts-ignore: decorator\n@builtin\nexport declare var __stack_pointer: usize;\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __heap_base: usize;\n\n/** Heap memory interface. */\nexport namespace heap {\n\n  /** Allocates a chunk of memory of at least the specified size. */\n  // @ts-ignore: decorator\n  @unsafe export function alloc(size: usize): usize {\n    return __alloc(size);\n  }\n\n  /** Reallocates a chunk of memory to have at least the specified size. */\n  // @ts-ignore: decorator\n  @unsafe export function realloc(ptr: usize, size: usize): usize {\n    return __realloc(ptr, size);\n  }\n\n  /** Frees a chunk of memory. Does hardly anything (most recent block only) with the stub runtime. */\n  // @ts-ignore: decorator\n  @unsafe export function free(ptr: usize): void {\n    __free(ptr);\n  }\n\n  /** Dangerously resets the entire heap. Specific to the stub runtime. */\n  // @ts-ignore: decorator\n  @unsafe export function reset(): void {\n    if (isDefined(__reset)) {\n      __reset();\n    } else {\n      throw new Error(E_NOTIMPLEMENTED);\n    }\n  }\n}\n","export function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\n  var w: u32, x: u32;\n\n  // copy 1 byte each until src is aligned to 4 bytes\n  while (n && (src & 3)) {\n    store<u8>(dest++, load<u8>(src++));\n    n--;\n  }\n\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\n  if ((dest & 3) == 0) {\n    while (n >= 16) {\n      store<u32>(dest     , load<u32>(src     ));\n      store<u32>(dest +  4, load<u32>(src +  4));\n      store<u32>(dest +  8, load<u32>(src +  8));\n      store<u32>(dest + 12, load<u32>(src + 12));\n      src += 16; dest += 16; n -= 16;\n    }\n    if (n & 8) {\n      store<u32>(dest    , load<u32>(src    ));\n      store<u32>(dest + 4, load<u32>(src + 4));\n      dest += 8; src += 8;\n    }\n    if (n & 4) {\n      store<u32>(dest, load<u32>(src));\n      dest += 4; src += 4;\n    }\n    if (n & 2) { // drop to 2 bytes each\n      store<u16>(dest, load<u16>(src));\n      dest += 2; src += 2;\n    }\n    if (n & 1) { // drop to 1 byte\n      store<u8>(dest++, load<u8>(src++));\n    }\n    return;\n  }\n\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\n  if (n >= 32) {\n    switch (<u32>dest & 3) {\n      // known to be != 0\n      case 1: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 3;\n        while (n >= 17) {\n          x = load<u32>(src + 1);\n          store<u32>(dest, w >> 24 | x << 8);\n          w = load<u32>(src + 5);\n          store<u32>(dest + 4, x >> 24 | w << 8);\n          x = load<u32>(src + 9);\n          store<u32>(dest + 8, w >> 24 | x << 8);\n          w = load<u32>(src + 13);\n          store<u32>(dest + 12, x >> 24 | w << 8);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 2: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 2;\n        while (n >= 18) {\n          x = load<u32>(src + 2);\n          store<u32>(dest, w >> 16 | x << 16);\n          w = load<u32>(src + 6);\n          store<u32>(dest + 4, x >> 16 | w << 16);\n          x = load<u32>(src + 10);\n          store<u32>(dest + 8, w >> 16 | x << 16);\n          w = load<u32>(src + 14);\n          store<u32>(dest + 12, x >> 16 | w << 16);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 3: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        n -= 1;\n        while (n >= 19) {\n          x = load<u32>(src + 3);\n          store<u32>(dest, w >> 8 | x << 24);\n          w = load<u32>(src + 7);\n          store<u32>(dest + 4, x >> 8 | w << 24);\n          x = load<u32>(src + 11);\n          store<u32>(dest + 8, w >> 8 | x << 24);\n          w = load<u32>(src + 15);\n          store<u32>(dest + 12, x >> 8 | w << 24);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n    }\n  }\n\n  // copy remaining bytes one by one\n  if (n & 16) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 8) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 4) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 2) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 1) {\n    store<u8>(dest++, load<u8>(src++));\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n  if (dest === src) return;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (src - dest - n <= -(n << 1)) {\n      memcpy(dest, src, n);\n      return;\n    }\n  }\n  if (dest < src) {\n    if (ASC_SHRINK_LEVEL < 2) {\n      if ((src & 7) == (dest & 7)) {\n        while (dest & 7) {\n          if (!n) return;\n          --n;\n          store<u8>(dest++, load<u8>(src++));\n        }\n        while (n >= 8) {\n          store<u64>(dest, load<u64>(src));\n          n    -= 8;\n          dest += 8;\n          src  += 8;\n        }\n      }\n    }\n    while (n) {\n      store<u8>(dest++, load<u8>(src++));\n      --n;\n    }\n  } else {\n    if (ASC_SHRINK_LEVEL < 2) {\n      if ((src & 7) == (dest & 7)) {\n        while ((dest + n) & 7) {\n          if (!n) return;\n          store<u8>(dest + --n, load<u8>(src + n));\n        }\n        while (n >= 8) {\n          n -= 8;\n          store<u64>(dest + n, load<u64>(src + n));\n        }\n      }\n    }\n    while (n) {\n      store<u8>(dest + --n, load<u8>(src + n));\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n  if (ASC_SHRINK_LEVEL > 1) {\n    while (n) {\n      store<u8>(dest++, c);\n      --n;\n    }\n  } else {\n    // fill head and tail with minimal branching\n    if (!n) return;\n    let dend = dest + n;\n    store<u8>(dest, c);\n    store<u8>(dend - 1, c);\n    if (n <= 2) return;\n    store<u8>(dest, c, 1);\n    store<u8>(dest, c, 2);\n    store<u8>(dend - 2, c);\n    store<u8>(dend - 3, c);\n    if (n <= 6) return;\n    store<u8>(dest, c, 3);\n    store<u8>(dend - 4, c);\n    if (n <= 8) return;\n\n    // advance pointer to align it at 4-byte boundary\n    let k: usize = -dest & 3;\n    dest += k;\n    n -= k;\n    n &= -4;\n\n    let c32: u32 = <u32>-1 / 255 * c;\n\n    // fill head/tail up to 28 bytes each in preparation\n    dend = dest + n;\n    store<u32>(dest, c32);\n    store<u32>(dend - 4, c32);\n    if (n <= 8) return;\n    store<u32>(dest, c32, 4);\n    store<u32>(dest, c32, 8);\n    store<u32>(dend - 12, c32);\n    store<u32>(dend - 8, c32);\n    if (n <= 24) return;\n    store<u32>(dest, c32, 12);\n    store<u32>(dest, c32, 16);\n    store<u32>(dest, c32, 20);\n    store<u32>(dest, c32, 24);\n    store<u32>(dend - 28, c32);\n    store<u32>(dend - 24, c32);\n    store<u32>(dend - 20, c32);\n    store<u32>(dend - 16, c32);\n\n    // align to a multiple of 8\n    k = 24 + (dest & 4);\n    dest += k;\n    n -= k;\n\n    // copy 32 bytes each\n    let c64: u64 = <u64>c32 | (<u64>c32 << 32);\n    while (n >= 32) {\n      store<u64>(dest, c64);\n      store<u64>(dest, c64, 8);\n      store<u64>(dest, c64, 16);\n      store<u64>(dest, c64, 24);\n      n -= 32;\n      dest += 32;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 {\n  if (vl == vr) return 0;\n  if (ASC_SHRINK_LEVEL < 2) {\n    if ((vl & 7) == (vr & 7)) {\n      while (vl & 7) {\n        if (!n) return 0;\n        let a = <i32>load<u8>(vl);\n        let b = <i32>load<u8>(vr);\n        if (a != b) return a - b;\n        n--; vl++; vr++;\n      }\n      while (n >= 8) {\n        if (load<u64>(vl) != load<u64>(vr)) break;\n        vl += 8;\n        vr += 8;\n        n  -= 8;\n      }\n    }\n  }\n  while (n--) {\n    let a = <i32>load<u8>(vl);\n    let b = <i32>load<u8>(vr);\n    if (a != b) return a - b;\n    vl++; vr++;\n  }\n  return 0;\n}\n","import { Writer } from \"../Writer\";\nimport { FixedSizer } from \"./FixedSizer\";\n\n/**\n * @internal\n *\n * Wire format writer using `Uint8Array`\n */\n@final\nexport class FixedWriter extends Writer {\n  /**\n   * Related sizer\n   */\n  readonly sizer: FixedSizer;\n\n  /**\n   * Current pointer.\n   */\n  private ptr: usize;\n\n  /**\n   * Fixed buffer.\n   */\n  private buf: Uint8Array;\n\n  /**\n   * Index in varlen array from sizer.\n   */\n  private varlenidx: i32;\n\n  constructor() {\n    super();\n    this.sizer = new FixedSizer();\n    this.buf = new Uint8Array(this.sizer.len);\n    this.ptr = this.buf.dataStart;\n    this.varlenidx = 0;\n  }\n\n  @inline\n  uint32(value: u32): void {\n    this.varint<u32>(value);\n  }\n\n  @inline\n  int32(value: i32): void {\n    if (value < 0) {\n      this.int64(value);\n    } else {\n      this.varint<u32>(value);\n    }\n  }\n\n  @inline\n  sint32(value: i32): void {\n    this.varint<u32>((value << 1) ^ (value >> 31));\n  }\n\n  @inline\n  uint64(value: u64): void {\n    this.varint<u64>(value);\n  }\n\n  @inline\n  int64(value: i64): void {\n    this.varint<u64>(value);\n  }\n\n  @inline\n  sint64(value: i64): void {\n    this.varint<u64>((value << 1) ^ (value >> 63));\n  }\n\n  @inline\n  bool(value: bool): void {\n    this.fixed<u8>(value ? 1 : 0);\n  }\n\n  @inline\n  fixed32(value: u32): void {\n    this.fixed<u32>(value);\n  }\n\n  @inline\n  sfixed32(value: i32): void {\n    this.fixed<u32>(value);\n  }\n\n  @inline\n  fixed64(value: u64): void {\n    this.fixed<u64>(value);\n  }\n\n  @inline\n  sfixed64(value: i64): void {\n    this.fixed<u64>(value);\n  }\n\n  @inline\n  float(value: f32): void {\n    this.fixed<f32>(value);\n  }\n\n  @inline\n  double(value: f64): void {\n    this.fixed<f64>(value);\n  }\n\n  bytes(value: Uint8Array): void {\n    this.uint32(value.byteLength);\n    memory.copy(this.ptr, value.dataStart, value.byteLength);\n    this.ptr += value.byteLength;\n  }\n\n  string(value: string): void {\n    const len = this.varlen(); // use precomputed length\n    this.uint32(len);\n    String.UTF8.encodeUnsafe(changetype<usize>(value), value.length, this.ptr);\n    this.ptr += len;\n  }\n\n  @inline\n  fork(): void {\n    this.uint32(this.varlen()); // use precomputed length\n  }\n\n  @inline\n  ldelim(): void {\n    // nothing to do - all dirty work done by sizer\n  }\n\n  finish(): Uint8Array {\n    return this.buf;\n  }\n\n  reset(): void {\n    this.buf = new Uint8Array(this.sizer.len);\n    this.ptr = this.buf.dataStart;\n    this.varlenidx = 0;\n  }\n\n  @inline\n  private varint<T extends number>(val: T): void {\n    while (val > 0x7f) {\n      store<u8>(this.ptr++, (val & 0x7f) | 0x80);\n      val = <T>(val >>> 7);\n    }\n    store<u8>(this.ptr++, val);\n  }\n\n  @inline\n  private fixed<T extends number>(val: T): void {\n    store<T>(this.ptr, val);\n    this.ptr += sizeof<T>();\n  }\n\n  @inline\n  private varlen(): u32 {\n    return this.varlenidx >= this.sizer.varlen.length\n      ? 0\n      : this.sizer.varlen[this.varlenidx++];\n  }\n}\n","import { Writer } from \"../Writer\";\n\n/**\n * @internal\n */\n@final\nexport class FixedSizer extends Writer {\n  /**\n   * Total length.\n   */\n  len: u32;\n\n  /**\n   * Position stack.\n   */\n  readonly pos: Array<u32>;\n\n  /**\n   * Variable length list.\n   */\n  readonly varlen: Array<i32>;\n\n  /**\n   * Variable length index stack.\n   */\n  readonly varlenidx: Array<i32>;\n\n  constructor() {\n    super();\n    this.len = 0;\n    this.pos = [];\n    this.varlen = [];\n    this.varlenidx = [];\n  }\n\n  @inline\n  uint32(value: u32): void {\n    this.varint32(value);\n  }\n\n  @inline\n  int32(value: i32): void {\n    if (value < 0) {\n      // 10 bytes to encode negative number\n      this.len += 10;\n    } else {\n      this.varint32(value);\n    }\n  }\n\n  @inline\n  sint32(value: i32): void {\n    this.varint32((value << 1) ^ (value >> 31));\n  }\n\n  @inline\n  uint64(value: u64): void {\n    this.varint64(value);\n  }\n\n  @inline\n  int64(value: i64): void {\n    this.varint64(value);\n  }\n\n  @inline\n  sint64(value: i64): void {\n    this.varint64((value << 1) ^ (value >> 63));\n  }\n\n  @inline\n  bool(value: bool): void {\n    this.len += 1;\n  }\n\n  @inline\n  fixed32(value: u32): void {\n    this.len += 4;\n  }\n\n  @inline\n  sfixed32(value: i32): void {\n    this.len += 4;\n  }\n\n  @inline\n  fixed64(value: u64): void {\n    this.len += 8;\n  }\n\n  @inline\n  sfixed64(value: i64): void {\n    this.len += 8;\n  }\n\n  @inline\n  float(value: f32): void {\n    this.len += 4;\n  }\n\n  @inline\n  double(value: f64): void {\n    this.len += 8;\n  }\n\n  bytes(value: Uint8Array): void {\n    this.uint32(value.byteLength);\n    this.len += value.byteLength;\n  }\n\n  string(value: string): void {\n    const len = String.UTF8.byteLength(value);\n    this.varlen.push(len);\n    this.uint32(len);\n    this.len += len;\n  }\n\n  @inline\n  fork(): void {\n    this.pos.push(this.len); // save current position\n    this.varlenidx.push(this.varlen.length); // save current index in varlen array\n    this.varlen.push(0); // add 0 length to varlen array (to be updated in ldelim())\n  }\n\n  ldelim(): void {\n    assert(\n      this.pos.length && this.varlenidx.length,\n      \"Missing fork() before ldelim() call.\"\n    );\n\n    const endPos = this.len; // current position is end position\n    const startPos = this.pos.pop(); // get start position from stack\n    const idx = this.varlenidx.pop(); // get varlen index from stack\n    const len = endPos - startPos; // calculate length\n\n    this.varlen[idx] = len; // update variable length\n    this.uint32(len); // add uint32 that should be called in fork()\n  }\n\n  reset(): void {\n    this.len = 0;\n    // re-use arrays\n    this.pos.length = 0;\n    this.varlen.length = 0;\n    this.varlenidx.length = 0;\n  }\n\n  @inline\n  private varint32(value: u32): void {\n    this.len +=\n      value < 0\n        ? 10 // 10 bits with leading 1's\n        : value < 0x80\n        ? 1\n        : value < 0x4000\n        ? 2\n        : value < 0x200000\n        ? 3\n        : value < 0x10000000\n        ? 4\n        : 5;\n  }\n\n  @inline\n  private varint64(value: u64): void {\n    this.len +=\n      value < 0x80\n        ? 1\n        : value < 0x4000\n        ? 2\n        : value < 0x200000\n        ? 3\n        : value < 0x10000000\n        ? 4\n        : value < 0x800000000\n        ? 5\n        : value < 0x40000000000\n        ? 6\n        : value < 0x2000000000000\n        ? 7\n        : value < 0x100000000000000\n        ? 8\n        : value < 0x8000000000000000\n        ? 9\n        : 10;\n  }\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { Runtime } from \"shared/runtime\";\nimport { idof } from \"./builtins\";\nimport { E_INVALIDLENGTH } from \"./util/error\";\n\nexport abstract class ArrayBufferView {\n\n  readonly buffer: ArrayBuffer;\n  @unsafe readonly dataStart: usize;\n  readonly byteLength: i32;\n\n  get byteOffset(): i32 {\n    return <i32>(this.dataStart - changetype<usize>(this.buffer));\n  }\n\n  protected constructor(length: i32, alignLog2: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    var buffer = changetype<ArrayBuffer>(__new(length = length << alignLog2, idof<ArrayBuffer>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(buffer), 0, <usize>length);\n    }\n    this.buffer = buffer; // links\n    this.dataStart = changetype<usize>(buffer);\n    this.byteLength = length;\n  }\n}\n\n@final export class ArrayBuffer {\n\n  static isView<T>(value: T): bool {\n    if (isNullable<T>()) {\n      if (value === null) return false;\n    }\n    if (value instanceof Int8Array) return true;\n    if (value instanceof Uint8Array) return true;\n    if (value instanceof Uint8ClampedArray) return true;\n    if (value instanceof Int16Array) return true;\n    if (value instanceof Uint16Array) return true;\n    if (value instanceof Int32Array) return true;\n    if (value instanceof Uint32Array) return true;\n    if (value instanceof Int64Array) return true;\n    if (value instanceof Uint64Array) return true;\n    if (value instanceof Float32Array) return true;\n    if (value instanceof Float64Array) return true;\n    if (value instanceof DataView) return true;\n    return false;\n  }\n\n  constructor(length: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE) throw new RangeError(E_INVALIDLENGTH);\n    var buffer = changetype<ArrayBuffer>(__new(<usize>length, idof<ArrayBuffer>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(buffer), 0, <usize>length);\n    }\n    return buffer;\n  }\n\n  get byteLength(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;\n  }\n\n  slice(begin: i32 = 0, end: i32 = BLOCK_MAXSIZE): ArrayBuffer {\n    var length = this.byteLength;\n    begin = begin < 0 ? max(length + begin, 0) : min(begin, length);\n    end   = end   < 0 ? max(length + end  , 0) : min(end  , length);\n    var outSize = <usize>max(end - begin, 0);\n    var out = changetype<ArrayBuffer>(__new(outSize, idof<ArrayBuffer>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + <usize>begin, outSize);\n    return out;\n  }\n\n  toString(): string {\n    return \"[object ArrayBuffer]\";\n  }\n}\n","import { COMPARATOR, SORT } from \"./util/sort\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_NOTIMPLEMENTED } from \"./util/error\";\nimport { joinIntegerArray, joinFloatArray } from \"./util/string\";\nimport { REVERSE } from \"./util/bytes\";\nimport { idof } from \"./builtins\";\nimport { ArrayBufferView } from \"./arraybuffer\";\n\nexport class Int8Array extends ArrayBufferView {\n  [key: number]: i8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i8>();\n\n  constructor(length: i32) {\n    super(length, alignof<i8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i8 {\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<i8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i8>(this.dataStart + <usize>index, value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<i8>): void {\n    store<i8>(this.dataStart + <usize>index, value);\n  }\n\n  at(index: i32): i8 {\n    var len = this.byteLength;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  includes(searchElement: i8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return FILL<Int8Array, i8>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i8, b: i8) => i32 = COMPARATOR<i8>()): Int8Array {\n    SORT<i8>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return SLICE<Int8Array, i8>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return SUBARRAY<Int8Array, i8>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int8Array {\n    return COPY_WITHIN<Int8Array, i8>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int8Array, i8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int8Array, i8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i8, index: i32, self: Int8Array) => i8): Int8Array {\n    return MAP<Int8Array, i8>(this, fn);\n  }\n\n  filter(fn: (value: i8, index: i32, self: Int8Array) => bool): Int8Array {\n    return FILTER<Int8Array, i8>(this, fn);\n  }\n\n  findIndex(fn: (value: i8, index: i32, self: Int8Array) => bool): i32 {\n    return FIND_INDEX<Int8Array, i8>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i8, index: i32, self: Int8Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int8Array, i8>(this, fn);\n  }\n\n  some(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\n    return SOME<Int8Array, i8>(this, fn);\n  }\n\n  every(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\n    return EVERY<Int8Array, i8>(this, fn);\n  }\n\n  forEach(fn: (value: i8, index: i32, self: Int8Array) => void): void {\n    FOREACH<Int8Array, i8>(this, fn);\n  }\n\n  reverse(): this {\n    REVERSE<u8>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i8>(this.dataStart, this.length, separator);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Int8Array, i8, U, valueof<U>>(this, source, offset);\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int8Array {\n    return WRAP<Int8Array, i8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint8Array extends ArrayBufferView {\n  [key: number]: u8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u8>();\n\n  constructor(length: i32) {\n    super(length, alignof<u8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u8 {\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u8>(this.dataStart + <usize>index, value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u8>): void {\n    store<u8>(this.dataStart + <usize>index, value);\n  }\n\n  at(index: i32): u8 {\n    var len = this.byteLength;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return FILL<Uint8Array, u8>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8Array {\n    SORT<u8>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return SLICE<Uint8Array, u8>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return SUBARRAY<Uint8Array, u8>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return COPY_WITHIN<Uint8Array, u8>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint8Array, u8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint8Array, u8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u8, index: i32, self: Uint8Array) => u8): Uint8Array {\n    return MAP<Uint8Array, u8>(this, fn);\n  }\n\n  filter(fn: (value: u8, index: i32, self: Uint8Array) => bool): Uint8Array {\n    return FILTER<Uint8Array, u8>(this, fn);\n  }\n\n  findIndex(fn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {\n    return FIND_INDEX<Uint8Array, u8>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint8Array, u8>(this, fn);\n  }\n\n  some(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\n    return SOME<Uint8Array, u8>(this, fn);\n  }\n\n  every(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\n    return EVERY<Uint8Array, u8>(this, fn);\n  }\n\n  forEach(fn: (value: u8, index: i32, self: Uint8Array) => void): void {\n    FOREACH<Uint8Array, u8>(this, fn);\n  }\n\n  reverse(): this {\n    REVERSE<u8>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u8>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Uint8Array, u8, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8Array {\n    return WRAP<Uint8Array, u8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint8ClampedArray extends ArrayBufferView {\n  [key: number]: u8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u8>();\n\n  constructor(length: i32) {\n    super(length, alignof<u8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u8 {\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u8>): void {\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\n  }\n\n  at(index: i32): u8 {\n    var len = this.byteLength;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return FILL<Uint8ClampedArray, u8>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8ClampedArray {\n    SORT<u8>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return SLICE<Uint8ClampedArray, u8>(this, begin, end);\n  }\n\n  subarray(start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return SUBARRAY<Uint8ClampedArray, u8>(this, start, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return COPY_WITHIN<Uint8ClampedArray, u8>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint8ClampedArray, u8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint8ClampedArray, u8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u8, index: i32, self: Uint8ClampedArray) => u8): Uint8ClampedArray {\n    return MAP<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  filter(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): Uint8ClampedArray {\n    return FILTER<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  findIndex(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {\n    return FIND_INDEX<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {\n    return FIND_LAST_INDEX<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  some(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\n    return SOME<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  every(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\n    return EVERY<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  forEach(fn: (value: u8, index: i32, self: Uint8ClampedArray) => void): void {\n    FOREACH<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  reverse(): this {\n    REVERSE<u8>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u8>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Uint8ClampedArray, u8, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8ClampedArray {\n    return WRAP<Uint8ClampedArray, u8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int16Array extends ArrayBufferView {\n  [key: number]: i16;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i16>();\n\n  constructor(length: i32) {\n    super(length, alignof<i16>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i16>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i16 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i16 {\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<i16>): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<i16>): void {\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\n  }\n\n  at(index: i32): i16 {\n    var len = this.byteLength >>> alignof<i16>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  includes(searchElement: i16, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i16, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i16, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return FILL<Int16Array, i16>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i16, b: i16) => i32 = COMPARATOR<i16>()): Int16Array {\n    SORT<i16>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return SLICE<Int16Array, i16>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return SUBARRAY<Int16Array, i16>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int16Array {\n    return COPY_WITHIN<Int16Array, i16>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int16Array, i16, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int16Array, i16, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i16, index: i32, self: Int16Array) => i16): Int16Array {\n    return MAP<Int16Array, i16>(this, fn);\n  }\n\n  filter(fn: (value: i16, index: i32, self: Int16Array) => bool): Int16Array {\n    return FILTER<Int16Array, i16>(this, fn);\n  }\n\n  findIndex(fn: (value: i16, index: i32, self: Int16Array) => bool): i32 {\n    return FIND_INDEX<Int16Array, i16>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i16, index: i32, self: Int16Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int16Array, i16>(this, fn);\n  }\n\n  some(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\n    return SOME<Int16Array, i16>(this, fn);\n  }\n\n  every(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\n    return EVERY<Int16Array, i16>(this, fn);\n  }\n\n  forEach(fn: (value: i16, index: i32, self: Int16Array) => void): void {\n    FOREACH<Int16Array, i16>(this, fn);\n  }\n\n  reverse(): this {\n    REVERSE<u16>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i16>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Int16Array, i16, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int16Array {\n    return WRAP<Int16Array, i16>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint16Array extends ArrayBufferView {\n  [key: number]: u16;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u16>();\n\n  constructor(length: i32) {\n    super(length, alignof<u16>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u16>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u16 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u16 {\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u16>): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u16>): void {\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\n  }\n\n  at(index: i32): u16 {\n    var len = this.byteLength >>> alignof<u16>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  includes(searchElement: u16, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u16, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u16, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return FILL<Uint16Array, u16>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u16, b: u16) => i32 = COMPARATOR<u16>()): Uint16Array {\n    SORT<u16>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return SLICE<Uint16Array, u16>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return SUBARRAY<Uint16Array, u16>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return COPY_WITHIN<Uint16Array, u16>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint16Array, u16, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint16Array, u16, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u16, index: i32, self: Uint16Array) => u16): Uint16Array {\n    return MAP<Uint16Array, u16>(this, fn);\n  }\n\n  filter(fn: (value: u16, index: i32, self: Uint16Array) => bool): Uint16Array {\n    return FILTER<Uint16Array, u16>(this, fn);\n  }\n\n  findIndex(fn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {\n    return FIND_INDEX<Uint16Array, u16>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint16Array, u16>(this, fn);\n  }\n\n  some(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\n    return SOME<Uint16Array, u16>(this, fn);\n  }\n\n  every(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\n    return EVERY<Uint16Array, u16>(this, fn);\n  }\n\n  forEach(fn: (value: u16, index: i32, self: Uint16Array) => void): void {\n    FOREACH<Uint16Array, u16>(this, fn);\n  }\n\n  reverse(): this {\n    REVERSE<u16>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u16>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Uint16Array, u16, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint16Array {\n    return WRAP<Uint16Array, u16>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int32Array extends ArrayBufferView {\n  [key: number]: i32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i32>();\n\n  constructor(length: i32) {\n    super(length, alignof<i32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i32 {\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: i32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: i32): void {\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\n  }\n\n  at(index: i32): i32 {\n    var len = this.byteLength >>> alignof<i32>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  includes(searchElement: i32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return FILL<Int32Array, i32>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i32, b: i32) => i32 = COMPARATOR<i32>()): Int32Array {\n    SORT<i32>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return SLICE<Int32Array, i32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return SUBARRAY<Int32Array, i32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int32Array {\n    return COPY_WITHIN<Int32Array, i32>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int32Array, i32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int32Array, i32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i32, index: i32, self: Int32Array) => i32): Int32Array {\n    return MAP<Int32Array, i32>(this, fn);\n  }\n\n  filter(fn: (value: i32, index: i32, self: Int32Array) => bool): Int32Array {\n    return FILTER<Int32Array, i32>(this, fn);\n  }\n\n  findIndex(fn: (value: i32, index: i32, self: Int32Array) => bool): i32 {\n    return FIND_INDEX<Int32Array, i32>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i32, index: i32, self: Int32Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int32Array, i32>(this, fn);\n  }\n\n  some(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\n    return SOME<Int32Array, i32>(this, fn);\n  }\n\n  every(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\n    return EVERY<Int32Array, i32>(this, fn);\n  }\n\n  forEach(fn: (value: i32, index: i32, self: Int32Array) => void): void {\n    FOREACH<Int32Array, i32>(this, fn);\n  }\n\n  reverse(): this {\n    REVERSE<u32>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Int32Array, i32, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int32Array {\n    return WRAP<Int32Array, i32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint32Array extends ArrayBufferView {\n  [key: number]: u32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u32>();\n\n  constructor(length: i32) {\n    super(length, alignof<u32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u32 {\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: u32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: u32): void {\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\n  }\n\n  at(index: i32): u32 {\n    var len = this.byteLength >>> alignof<u32>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  includes(searchElement: u32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return FILL<Uint32Array, u32>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u32, b: u32) => i32 = COMPARATOR<u32>()): Uint32Array {\n    SORT<u32>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return SLICE<Uint32Array, u32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return SUBARRAY<Uint32Array, u32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return COPY_WITHIN<Uint32Array, u32>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint32Array, u32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint32Array, u32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u32, index: i32, self: Uint32Array) => u32): Uint32Array {\n    return MAP<Uint32Array, u32>(this, fn);\n  }\n\n  filter(fn: (value: u32, index: i32, self: Uint32Array) => bool): Uint32Array {\n    return FILTER<Uint32Array, u32>(this, fn);\n  }\n\n  findIndex(fn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {\n    return FIND_INDEX<Uint32Array, u32>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint32Array, u32>(this, fn);\n  }\n\n  some(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\n    return SOME<Uint32Array, u32>(this, fn);\n  }\n\n  every(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\n    return EVERY<Uint32Array, u32>(this, fn);\n  }\n\n  forEach(fn: (value: u32, index: i32, self: Uint32Array) => void): void {\n    FOREACH<Uint32Array, u32>(this, fn);\n  }\n\n  reverse(): this {\n    REVERSE<u32>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Uint32Array, u32, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint32Array {\n    return WRAP<Uint32Array, u32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int64Array extends ArrayBufferView {\n  [key: number]: i64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i64>();\n\n  constructor(length: i32) {\n    super(length, alignof<i64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i64 {\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: i64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: i64): void {\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\n  }\n\n  at(index: i32): i64 {\n    var len = this.byteLength >>> alignof<i64>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  includes(searchElement: i64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return FILL<Int64Array, i64>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i64, b: i64) => i32 = COMPARATOR<i64>()): Int64Array {\n    SORT<i64>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return SLICE<Int64Array, i64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return SUBARRAY<Int64Array, i64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int64Array {\n    return COPY_WITHIN<Int64Array, i64>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int64Array, i64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int64Array, i64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i64, index: i32, self: Int64Array) => i64): Int64Array {\n    return MAP<Int64Array, i64>(this, fn);\n  }\n\n  filter(fn: (value: i64, index: i32, self: Int64Array) => bool): Int64Array {\n    return FILTER<Int64Array, i64>(this, fn);\n  }\n\n  findIndex(fn: (value: i64, index: i32, self: Int64Array) => bool): i32 {\n    return FIND_INDEX<Int64Array, i64>(this, fn);\n  }\n\n  findLastIndex(fn: (value: i64, index: i32, self: Int64Array) => bool): i32 {\n    return FIND_LAST_INDEX<Int64Array, i64>(this, fn);\n  }\n\n  some(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\n    return SOME<Int64Array, i64>(this, fn);\n  }\n\n  every(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\n    return EVERY<Int64Array, i64>(this, fn);\n  }\n\n  forEach(fn: (value: i64, index: i32, self: Int64Array) => void): void {\n    FOREACH<Int64Array, i64>(this, fn);\n  }\n\n  reverse(): this {\n    REVERSE<u64>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Int64Array, i64, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int64Array {\n    return WRAP<Int64Array, i64>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint64Array extends ArrayBufferView {\n  [key: number]: u64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u64>();\n\n  constructor(length: i32) {\n    super(length, alignof<u64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u64 {\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: u64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: u64): void {\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\n  }\n\n  at(index: i32): u64 {\n    var len = this.byteLength >>> alignof<u64>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  includes(searchElement: u64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return FILL<Uint64Array, u64>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u64, b: u64) => i32 = COMPARATOR<u64>()): Uint64Array {\n    SORT<u64>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return SLICE<Uint64Array, u64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return SUBARRAY<Uint64Array, u64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return COPY_WITHIN<Uint64Array, u64>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint64Array, u64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint64Array, u64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u64, index: i32, self: Uint64Array) => u64): Uint64Array {\n    return MAP<Uint64Array, u64>(this, fn);\n  }\n\n  filter(fn: (value: u64, index: i32, self: Uint64Array) => bool): Uint64Array {\n    return FILTER<Uint64Array, u64>(this, fn);\n  }\n\n  findIndex(fn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {\n    return FIND_INDEX<Uint64Array, u64>(this, fn);\n  }\n\n  findLastIndex(fn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {\n    return FIND_LAST_INDEX<Uint64Array, u64>(this, fn);\n  }\n\n  some(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\n    return SOME<Uint64Array, u64>(this, fn);\n  }\n\n  every(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\n    return EVERY<Uint64Array, u64>(this, fn);\n  }\n\n  forEach(fn: (value: u64, index: i32, self: Uint64Array) => void): void {\n    FOREACH<Uint64Array, u64>(this, fn);\n  }\n\n  reverse(): this {\n    REVERSE<u64>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Uint64Array, u64, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint64Array {\n    return WRAP<Uint64Array, u64>(buffer, byteOffset, length);\n  }\n}\n\nexport class Float32Array extends ArrayBufferView {\n  [key: number]: f32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<f32>();\n\n  constructor(length: i32) {\n    super(length, alignof<f32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<f32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): f32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): f32 {\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: f32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: f32): void {\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\n  }\n\n  at(index: i32): f32 {\n    var len = this.byteLength >>> alignof<f32>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  includes(searchElement: f32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: f32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: f32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: f32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return FILL<Float32Array, f32>(this, value, start, end);\n  }\n\n  sort(comparator: (a: f32, b: f32) => i32 = COMPARATOR<f32>()): Float32Array {\n    SORT<f32>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return SLICE<Float32Array, f32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return SUBARRAY<Float32Array, f32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float32Array {\n    return COPY_WITHIN<Float32Array, f32>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Float32Array, f32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Float32Array, f32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: f32, index: i32, self: Float32Array) => f32): Float32Array {\n    return MAP<Float32Array, f32>(this, fn);\n  }\n\n  filter(fn: (value: f32, index: i32, self: Float32Array) => bool): Float32Array {\n    return FILTER<Float32Array, f32>(this, fn);\n  }\n\n  findIndex(fn: (value: f32, index: i32, self: Float32Array) => bool): i32 {\n    return FIND_INDEX<Float32Array, f32>(this, fn);\n  }\n\n  findLastIndex(fn: (value: f32, index: i32, self: Float32Array) => bool): i32 {\n    return FIND_LAST_INDEX<Float32Array, f32>(this, fn);\n  }\n\n  some(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\n    return SOME<Float32Array, f32>(this, fn);\n  }\n\n  every(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\n    return EVERY<Float32Array, f32>(this, fn);\n  }\n\n  forEach(fn: (value: f32, index: i32, self: Float32Array) => void): void {\n    FOREACH<Float32Array, f32>(this, fn);\n  }\n\n  reverse(): this {\n    REVERSE<f32>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinFloatArray<f32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Float32Array, f32, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float32Array {\n    return WRAP<Float32Array, f32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Float64Array extends ArrayBufferView {\n  [key: number]: f64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<f64>();\n\n  constructor(length: i32) {\n    super(length, alignof<f64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<f64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): f64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): f64 {\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: f64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: f64): void {\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\n  }\n\n  at(index: i32): f64 {\n    var len = this.byteLength >>> alignof<f64>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  includes(searchElement: f64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: f64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: f64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: f64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return FILL<Float64Array, f64>(this, value, start, end);\n  }\n\n  sort(comparator: (a: f64, b: f64) => i32 = COMPARATOR<f64>()): Float64Array {\n    SORT<f64>(this.dataStart, this.length, comparator);\n    return this;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return SLICE<Float64Array, f64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return SUBARRAY<Float64Array, f64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float64Array {\n    return COPY_WITHIN<Float64Array, f64>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Float64Array, f64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Float64Array, f64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: f64, index: i32, self: Float64Array) => f64): Float64Array {\n    return MAP<Float64Array, f64>(this, fn);\n  }\n\n  filter(fn: (value: f64, index: i32, self: Float64Array) => bool): Float64Array {\n    return FILTER<Float64Array, f64>(this, fn);\n  }\n\n  findIndex(fn: (value: f64, index: i32, self: Float64Array) => bool): i32 {\n    return FIND_INDEX<Float64Array, f64>(this, fn);\n  }\n\n  findLastIndex(fn: (value: f64, index: i32, self: Float64Array) => bool): i32 {\n    return FIND_LAST_INDEX<Float64Array, f64>(this, fn);\n  }\n\n  some(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\n    return SOME<Float64Array, f64>(this, fn);\n  }\n\n  every(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\n    return EVERY<Float64Array, f64>(this, fn);\n  }\n\n  forEach(fn: (value: f64, index: i32, self: Float64Array) => void): void {\n    FOREACH<Float64Array, f64>(this, fn);\n  }\n\n  reverse(): this {\n    REVERSE<f64>(this.dataStart, this.length);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    return joinFloatArray<f64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Float64Array, f64, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float64Array {\n    return WRAP<Float64Array, f64>(buffer, byteOffset, length);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FILL<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  value: native<T>,\n  start: i32,\n  end: i32\n): TArray {\n  var ptr = array.dataStart;\n  var len = array.length;\n  start = start < 0 ? max(len + start, 0) : min(start, len);\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n  if (sizeof<T>() == 1) {\n    if (start < end) memory.fill(ptr + <usize>start, <u8>value, <usize>(end - start));\n  } else {\n    for (; start < end; ++start) {\n      store<T>(ptr + (<usize>start << alignof<T>()), value);\n    }\n  }\n  return array;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SLICE<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  start: i32,\n  end: i32\n): TArray {\n  var len = array.length;\n  start  = start < 0 ? max(start + len, 0) : min(start, len);\n  end    = end   < 0 ? max(end   + len, 0) : min(end  , len);\n  len = max(end - start, 0);\n  var slice = instantiate<TArray>(len);\n  memory.copy(\n    slice.dataStart,\n    array.dataStart + (<usize>start << alignof<T>()),\n    <usize>len << alignof<T>()\n  );\n  return slice;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SUBARRAY<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  begin: i32,\n  end: i32\n): TArray {\n  var len = array.length;\n  begin = begin < 0 ? max(len + begin, 0) : min(begin, len);\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n  end   = max(end, begin);\n\n  var out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  var buf = changetype<usize>(array.buffer);\n  store<usize>(changetype<usize>(out), buf, offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), buf, false);\n  store<usize>(changetype<usize>(out), array.dataStart + (<usize>begin << alignof<T>()), offsetof<TArray>(\"dataStart\"));\n  store<u32>(changetype<usize>(out), (end - begin) << alignof<T>(), offsetof<TArray>(\"byteLength\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction COPY_WITHIN<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  target: i32,\n  start: i32,\n  end: i32\n): TArray {\n  var len = array.length;\n  var ptr = array.dataStart;\n\n  end   = min<i32>(end, len);\n  var to    = target < 0 ? max(len + target, 0) : min(target, len);\n  var from  = start < 0 ? max(len + start, 0) : min(start, len);\n  var last  = end < 0 ? max(len + end, 0) : min(end, len);\n  var count = min(last - from, len - to);\n\n  memory.copy(\n    ptr + (<usize>to << alignof<T>()),\n    ptr + (<usize>from << alignof<T>()),\n    <usize>count << alignof<T>()\n  );\n  return array;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REDUCE<TArray extends ArrayBufferView, T, TRet>(\n  array: TArray,\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  var ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    initialValue = fn(initialValue, load<T>(ptr + (<usize>i << alignof<T>())), i, array);\n  }\n  return initialValue;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REDUCE_RIGHT<TArray extends ArrayBufferView, T, TRet>(\n  array: TArray,\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  var ptr = array.dataStart;\n  for (let i = array.length - 1; i >= 0; i--) {\n    initialValue = fn(initialValue, load<T>(ptr + (<usize>i << alignof<T>())), i, array);\n  }\n  return initialValue;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction MAP<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, self: TArray) => T,\n): TArray {\n  var len = array.length;\n  var ptr = array.dataStart;\n\n  var byteLength = len << alignof<T>();\n  var out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  var buf = changetype<ArrayBuffer>(__new(byteLength, idof<ArrayBuffer>()));\n  for (let i = 0; i < len; i++) {\n    store<T>(\n      changetype<usize>(buf) + (<usize>i << alignof<T>()),\n      fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)\n    );\n  }\n  store<usize>(changetype<usize>(out), changetype<usize>(buf), offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), changetype<usize>(buf), false);\n  store<usize>(changetype<usize>(out), changetype<usize>(buf), offsetof<TArray>(\"dataStart\"));\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\"byteLength\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FILTER<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, self: TArray) => bool,\n): TArray {\n  var len = array.length;\n  var out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  var buf = changetype<ArrayBuffer>(__new(len << alignof<T>(), idof<ArrayBuffer>()));\n  var dataStart  = array.dataStart;\n  var j: usize = 0;\n  for (let i = 0; i < len; i++) {\n    let value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    if (fn(value, i, array)) {\n      store<T>(\n        changetype<usize>(buf) + (j++ << alignof<T>()),\n        value\n      );\n    }\n  }\n  // shrink output buffer\n  var byteLength = j << alignof<T>();\n  var data = __renew(changetype<usize>(buf), byteLength);\n  store<usize>(changetype<usize>(out), data, offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), data, false);\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\"byteLength\"));\n  store<usize>(changetype<usize>(out), data, offsetof<TArray>(\"dataStart\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FIND_INDEX<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): i32 {\n  var ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return i;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FIND_LAST_INDEX<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): i32 {\n  var ptr = array.dataStart;\n  for (let i = array.length - 1; i >= 0; --i) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return i;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction INCLUDES<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): bool {\n  if (isFloat<T>()) {\n    let index: isize = fromIndex;\n    let len: isize = array.length;\n    if (len == 0 || index >= len) return false;\n    if (index < 0) index = max(len + index, 0);\n    let dataStart = array.dataStart;\n    while (index < len) {\n      let elem = load<T>(dataStart + (index << alignof<T>()));\n      // @ts-ignore\n      if (elem == searchElement || isNaN(elem) & isNaN(searchElement)) return true;\n      ++index;\n    }\n    return false;\n  } else {\n    return INDEX_OF<TArray, T>(array, searchElement, fromIndex) >= 0;\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction INDEX_OF<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): i32 {\n  var index: isize = fromIndex;\n  var len: isize = array.length;\n  if (len == 0 || index >= len) return -1;\n  if (index < 0) index = max(len + index, 0);\n  var dataStart = array.dataStart;\n  while (index < len) {\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\n    ++index;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction LAST_INDEX_OF<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): i32 {\n  var index: isize = fromIndex;\n  var len: isize = array.length;\n  if (len == 0) return -1;\n  if (index < 0) index = len + index; // no need to clamp\n  else if (index >= len) index = len - 1;\n  var dataStart = array.dataStart;\n  while (index >= 0) {\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\n    --index;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SOME<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  var ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) return true;\n  }\n  return false;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction EVERY<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  var ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array)) continue;\n    return false;\n  }\n  return true;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FOREACH<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => void,\n): void {\n  var ptr = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    fn(load<T>(ptr + (<usize>i << alignof<T>())), i, array);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction WRAP<TArray extends ArrayBufferView, T>(\n  buffer: ArrayBuffer,\n  byteOffset: i32 = 0,\n  len: i32 = -1\n): TArray {\n  var byteLength: i32;\n  var bufferByteLength = buffer.byteLength;\n  const mask: u32 = sizeof<T>() - 1;\n  if (i32(<u32>byteOffset > <u32>bufferByteLength) | (byteOffset & mask)) {\n    throw new RangeError(E_INDEXOUTOFRANGE);\n  }\n  if (len < 0) {\n    if (len == -1) {\n      if (bufferByteLength & mask) {\n        throw new RangeError(E_INVALIDLENGTH);\n      }\n      byteLength = bufferByteLength - byteOffset;\n    } else {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n  } else {\n    byteLength = len << alignof<T>();\n    if (byteOffset + byteLength > bufferByteLength) {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n  }\n  var out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  store<usize>(changetype<usize>(out), changetype<usize>(buffer), offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), changetype<usize>(buffer), false);\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\"byteLength\"));\n  store<usize>(changetype<usize>(out), changetype<usize>(buffer) + <usize>byteOffset, offsetof<TArray>(\"dataStart\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SET<TArray extends ArrayBufferView, T, UArray extends ArrayBufferView, U>(\n  target: TArray,\n  source: UArray,\n  offset: i32 = 0\n): void {\n  // need to assert at compile time that U is not a reference or a function\n  if (isReference<U>()) {\n    ERROR(E_NOTIMPLEMENTED);\n  }\n\n  // Uncaught RangeError: offset is out of bounds\n  if (offset < 0) throw new RangeError(E_INDEXOUTOFRANGE);\n  if (source.length + offset > target.length) throw new RangeError(E_INDEXOUTOFRANGE);\n\n  // if the types align and match, use memory.copy() instead of manual loop\n  if (isInteger<T>() == isInteger<U>() && alignof<T>() == alignof<U>() &&\n    !(target instanceof Uint8ClampedArray && isSigned<U>())) {\n    memory.copy(\n      target.dataStart + (<usize>offset << alignof<T>()),\n      source.dataStart,\n      source.byteLength\n    );\n  } else {\n    let targetDataStart = target.dataStart + (<usize>offset << alignof<T>());\n    let sourceDataStart = source.dataStart;\n    let count = source.length;\n    for (let i = 0; i < count; i++) {\n      // if TArray is Uint8ClampedArray, then values must be clamped\n      if (target instanceof Uint8ClampedArray) {\n        if (isFloat<U>()) {\n          let value = load<U>(sourceDataStart + (<usize>i << alignof<U>()));\n          store<T>(\n            targetDataStart + (<usize>i << alignof<T>()),\n            isFinite<U>(value) ? <T>max<U>(0, min<U>(255, value)) : <T>0\n          );\n        } else {\n          let value = load<U>(sourceDataStart + (<usize>i << alignof<U>()));\n          if (!isSigned<U>()) {\n            store<T>(\n              targetDataStart + (<usize>i << alignof<T>()),\n              // @ts-ignore: cast to T is valid for numeric types here\n              min<U>(255, value)\n            );\n          } else if (sizeof<T>() <= 4) {\n            store<T>(\n              targetDataStart + (<usize>i << alignof<T>()),\n              // @ts-ignore: cast to T is valid for numeric types here\n              ~(<i32>value >> 31) & (((255 - <i32>value) >> 31) | value)\n            );\n          } else {\n            store<T>(\n              targetDataStart + (<usize>i << alignof<T>()),\n              // @ts-ignore: cast to T is valid for numeric types here\n              ~(<i64>value >> 63) & (((255 - <i64>value) >> 63) | value)\n            );\n          }\n        }\n        // if U is a float, then casting float to int must include a finite check\n      } else if (isFloat<U>() && !isFloat<T>()) {\n        let value = load<U>(sourceDataStart + (<usize>i << alignof<U>()));\n        // @ts-ignore: cast to T is valid for numeric types here\n        store<T>(targetDataStart + (<usize>i << alignof<T>()), isFinite<U>(value) ? <T>value : 0);\n      } else if (isFloat<T>() && !isFloat<U>()) {\n        // @ts-ignore: In this case the <T> conversion is required\n        store<T>(targetDataStart + (<usize>i << alignof<T>()), <T>load<U>(sourceDataStart + (<usize>i << alignof<U>())));\n      } else {\n        store<T>(targetDataStart + (<usize>i << alignof<T>()), load<U>(sourceDataStart + (<usize>i << alignof<U>())));\n      }\n    }\n  }\n}\n","import { FixedWriter } from \"./internal/FixedWriter\";\nimport { FixedReader } from \"./internal/FixedReader\";\nimport { Writer } from \"./Writer\";\nimport { Reader } from \"./Reader\";\n\n// re-use instances to reduce allocations and GC\nconst WRITER = new FixedWriter();\nconst READER = new FixedReader(new Uint8Array(0));\n\n@final\nexport class Protobuf {\n  static encode<TMessage>(\n    message: TMessage,\n    encoder: (message: TMessage, writer: Writer) => void\n  ): Uint8Array {\n    // 1st pass - calculate length\n    WRITER.sizer.reset();\n    encoder(message, WRITER.sizer);\n    // 2nd pass - write data using length from the 1st pass\n    WRITER.reset();\n    encoder(message, WRITER);\n    return WRITER.finish();\n  }\n\n  static decode<TMessage>(\n    buffer: Uint8Array,\n    decoder: (reader: Reader, length: i32) => TMessage,\n    length: i32 = -1\n  ): TMessage {\n    READER.reset(buffer);\n    return decoder(READER, length);\n  }\n}\n","import { Reader } from \"../Reader\";\nimport { WireType } from \"../WireType\";\n\n/**\n * @internal\n *\n * Wire format reader using `Uint8Array`\n */\n@final\nexport class FixedReader extends Reader {\n  /**\n   * Read buffer\n   */\n  private buf: Uint8Array;\n\n  constructor(buf: Uint8Array) {\n    super();\n    this.ptr = buf.dataStart;\n    this.end = buf.dataStart + buf.byteLength;\n    this.buf = buf;\n  }\n\n  @inline\n  uint32(): u32 {\n    return this.varint32();\n  }\n\n  @inline\n  int32(): i32 {\n    return this.varint32();\n  }\n\n  @inline\n  sint32(): i32 {\n    const value: u32 = this.varint32();\n    return (value >>> 1) ^ -(value & 1);\n  }\n\n  @inline\n  uint64(): u64 {\n    return this.varint64();\n  }\n\n  @inline\n  int64(): i64 {\n    return this.varint64();\n  }\n\n  @inline\n  sint64(): i64 {\n    const value = this.varint64();\n    return (value >>> 1) ^ -(value & 1);\n  }\n\n  @inline\n  bool(): bool {\n    return this.varint32() !== 0;\n  }\n\n  @inline\n  fixed32(): u32 {\n    return load<u32>(this.inc(4));\n  }\n\n  @inline\n  sfixed32(): i32 {\n    return this.fixed32();\n  }\n\n  @inline\n  fixed64(): u64 {\n    return load<u64>(this.inc(8));\n  }\n\n  @inline\n  sfixed64(): u64 {\n    return this.fixed64();\n  }\n\n  @inline\n  float(): f32 {\n    return load<f32>(this.inc(4));\n  }\n\n  @inline\n  double(): f64 {\n    return load<f64>(this.inc(8));\n  }\n\n  bytes(): Uint8Array {\n    const length = this.uint32();\n    const buffer = new Uint8Array(length);\n    memory.copy(buffer.dataStart, this.inc(length), length);\n    return buffer;\n  }\n\n  string(): string {\n    const bytes = this.bytes();\n    return String.UTF8.decodeUnsafe(bytes.dataStart, bytes.byteLength);\n  }\n\n  skip(length: u32): void {\n    if (length === 0) {\n      // skip varint\n      while (load<u8>(this.inc()) & 0x80);\n    } else {\n      this.inc(length);\n    }\n  }\n\n  skipType(wireType: WireType = WireType.VARINT): void {\n    switch (wireType) {\n      case WireType.VARINT:\n        this.skip(0);\n        break;\n      case WireType.FIXED_64:\n        this.skip(8);\n        break;\n      case WireType.LENGTH_DELIMITED:\n        this.skip(this.uint32());\n        break;\n      case WireType.START_GROUP:\n        while ((wireType = this.uint32() & 0x07) !== WireType.END_GROUP) {\n          this.skipType(wireType);\n        }\n        break;\n      case WireType.FIXED_32:\n        this.skip(4);\n        break;\n      default:\n        throw new Error(\"Invalid wire type \" + wireType.toString());\n    }\n  }\n\n  reset(buf: Uint8Array): void {\n    this.ptr = buf.dataStart;\n    this.end = buf.dataStart + buf.byteLength;\n    this.buf = buf;\n  }\n\n  private varint32(): u32 {\n    let loaded: u32;\n    let value: u32;\n\n    value = (loaded = load<u8>(this.inc())) & 0x7f;\n    if (loaded < 0x80) return value;\n\n    value |= ((loaded = load<u8>(this.inc())) & 0x7f) << 7;\n    if (loaded < 0x80) return value;\n\n    value |= ((loaded = load<u8>(this.inc())) & 0x7f) << 14;\n    if (loaded < 0x80) return value;\n\n    value |= ((loaded = load<u8>(this.inc())) & 0x7f) << 21;\n    if (loaded < 0x80) return value;\n\n    value |= ((loaded = load<u8>(this.inc())) & 0xf) << 28;\n    if (loaded < 0x80) return value;\n\n    // increment position until there is no continuation bit or until we read 10 bytes\n    if (load<u8>(this.inc()) < 0x80) return value;\n    if (load<u8>(this.inc()) < 0x80) return value;\n    if (load<u8>(this.inc()) < 0x80) return value;\n    if (load<u8>(this.inc()) < 0x80) return value;\n    if (load<u8>(this.inc()) < 0x80) return value;\n\n    return value;\n  }\n\n  private varint64(): u64 {\n    let loaded: u64;\n    let value: u64;\n\n    value = (loaded = load<u8>(this.inc())) & 0x7f;\n    if (loaded < 0x80) return value;\n\n    value |= ((loaded = load<u8>(this.inc())) & 0x7f) << 7;\n    if (loaded < 0x80) return value;\n\n    value |= ((loaded = load<u8>(this.inc())) & 0x7f) << 14;\n    if (loaded < 0x80) return value;\n\n    value |= ((loaded = load<u8>(this.inc())) & 0x7f) << 21;\n    if (loaded < 0x80) return value;\n\n    value |= ((loaded = load<u8>(this.inc())) & 0x7f) << 28;\n    if (loaded < 0x80) return value;\n\n    value |= ((loaded = load<u8>(this.inc())) & 0x7f) << 35;\n    if (loaded < 0x80) return value;\n\n    value |= ((loaded = load<u8>(this.inc())) & 0x7f) << 42;\n    if (loaded < 0x80) return value;\n\n    value |= ((loaded = load<u8>(this.inc())) & 0x7f) << 49;\n    if (loaded < 0x80) return value;\n\n    value |= ((loaded = load<u8>(this.inc())) & 0x7f) << 56;\n    if (loaded < 0x80) return value;\n\n    value |= (load<u8>(this.inc()) & 0x1) << 63;\n\n    return value;\n  }\n\n  @inline\n  private inc(step: u32 = 1): usize {\n    const ptr = this.ptr;\n    this.ptr += step;\n    assert(this.ptr <= this.end, \"Index out of range\");\n\n    return ptr;\n  }\n}\n","import { Writer, Reader } from \"as-proto\";\nimport { protocol } from \"../../protocol/protocol\";\n\nexport namespace governance {\n  export class proposal_record {\n    static encode(message: proposal_record, writer: Writer): void {\n      const unique_name_operations = message.operations;\n      for (let i = 0; i < unique_name_operations.length; ++i) {\n        writer.uint32(10);\n        writer.fork();\n        protocol.operation.encode(unique_name_operations[i], writer);\n        writer.ldelim();\n      }\n\n      const unique_name_operation_merkle_root = message.operation_merkle_root;\n      if (unique_name_operation_merkle_root !== null) {\n        writer.uint32(18);\n        writer.bytes(unique_name_operation_merkle_root);\n      }\n\n      if (message.vote_start_height != 0) {\n        writer.uint32(24);\n        writer.uint64(message.vote_start_height);\n      }\n\n      if (message.vote_tally != 0) {\n        writer.uint32(32);\n        writer.uint64(message.vote_tally);\n      }\n\n      if (message.vote_threshold != 0) {\n        writer.uint32(40);\n        writer.uint64(message.vote_threshold);\n      }\n\n      if (message.shall_authorize != false) {\n        writer.uint32(48);\n        writer.bool(message.shall_authorize);\n      }\n\n      if (message.updates_governance != false) {\n        writer.uint32(56);\n        writer.bool(message.updates_governance);\n      }\n\n      if (message.status != 0) {\n        writer.uint32(64);\n        writer.int32(message.status);\n      }\n\n      if (message.fee != 0) {\n        writer.uint32(72);\n        writer.uint64(message.fee);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): proposal_record {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new proposal_record();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.operations.push(\n              protocol.operation.decode(reader, reader.uint32())\n            );\n            break;\n\n          case 2:\n            message.operation_merkle_root = reader.bytes();\n            break;\n\n          case 3:\n            message.vote_start_height = reader.uint64();\n            break;\n\n          case 4:\n            message.vote_tally = reader.uint64();\n            break;\n\n          case 5:\n            message.vote_threshold = reader.uint64();\n            break;\n\n          case 6:\n            message.shall_authorize = reader.bool();\n            break;\n\n          case 7:\n            message.updates_governance = reader.bool();\n            break;\n\n          case 8:\n            message.status = reader.int32();\n            break;\n\n          case 9:\n            message.fee = reader.uint64();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    operations: Array<protocol.operation>;\n    operation_merkle_root: Uint8Array | null;\n    vote_start_height: u64;\n    vote_tally: u64;\n    vote_threshold: u64;\n    shall_authorize: bool;\n    updates_governance: bool;\n    status: proposal_status;\n    fee: u64;\n\n    constructor(\n      operations: Array<protocol.operation> = [],\n      operation_merkle_root: Uint8Array | null = null,\n      vote_start_height: u64 = 0,\n      vote_tally: u64 = 0,\n      vote_threshold: u64 = 0,\n      shall_authorize: bool = false,\n      updates_governance: bool = false,\n      status: proposal_status = 0,\n      fee: u64 = 0\n    ) {\n      this.operations = operations;\n      this.operation_merkle_root = operation_merkle_root;\n      this.vote_start_height = vote_start_height;\n      this.vote_tally = vote_tally;\n      this.vote_threshold = vote_threshold;\n      this.shall_authorize = shall_authorize;\n      this.updates_governance = updates_governance;\n      this.status = status;\n      this.fee = fee;\n    }\n  }\n\n  export class submit_proposal_arguments {\n    static encode(message: submit_proposal_arguments, writer: Writer): void {\n      const unique_name_operations = message.operations;\n      for (let i = 0; i < unique_name_operations.length; ++i) {\n        writer.uint32(10);\n        writer.fork();\n        protocol.operation.encode(unique_name_operations[i], writer);\n        writer.ldelim();\n      }\n\n      const unique_name_operation_merkle_root = message.operation_merkle_root;\n      if (unique_name_operation_merkle_root !== null) {\n        writer.uint32(18);\n        writer.bytes(unique_name_operation_merkle_root);\n      }\n\n      if (message.fee != 0) {\n        writer.uint32(24);\n        writer.uint64(message.fee);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): submit_proposal_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new submit_proposal_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.operations.push(\n              protocol.operation.decode(reader, reader.uint32())\n            );\n            break;\n\n          case 2:\n            message.operation_merkle_root = reader.bytes();\n            break;\n\n          case 3:\n            message.fee = reader.uint64();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    operations: Array<protocol.operation>;\n    operation_merkle_root: Uint8Array | null;\n    fee: u64;\n\n    constructor(\n      operations: Array<protocol.operation> = [],\n      operation_merkle_root: Uint8Array | null = null,\n      fee: u64 = 0\n    ) {\n      this.operations = operations;\n      this.operation_merkle_root = operation_merkle_root;\n      this.fee = fee;\n    }\n  }\n\n  @unmanaged\n  export class submit_proposal_result {\n    static encode(message: submit_proposal_result, writer: Writer): void {}\n\n    static decode(reader: Reader, length: i32): submit_proposal_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new submit_proposal_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    constructor() {}\n  }\n\n  export class get_proposal_by_id_arguments {\n    static encode(message: get_proposal_by_id_arguments, writer: Writer): void {\n      const unique_name_proposal_id = message.proposal_id;\n      if (unique_name_proposal_id !== null) {\n        writer.uint32(10);\n        writer.bytes(unique_name_proposal_id);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): get_proposal_by_id_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new get_proposal_by_id_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.proposal_id = reader.bytes();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    proposal_id: Uint8Array | null;\n\n    constructor(proposal_id: Uint8Array | null = null) {\n      this.proposal_id = proposal_id;\n    }\n  }\n\n  export class get_proposal_by_id_result {\n    static encode(message: get_proposal_by_id_result, writer: Writer): void {\n      const unique_name_value = message.value;\n      if (unique_name_value !== null) {\n        writer.uint32(10);\n        writer.fork();\n        proposal_record.encode(unique_name_value, writer);\n        writer.ldelim();\n      }\n    }\n\n    static decode(reader: Reader, length: i32): get_proposal_by_id_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new get_proposal_by_id_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.value = proposal_record.decode(reader, reader.uint32());\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    value: proposal_record | null;\n\n    constructor(value: proposal_record | null = null) {\n      this.value = value;\n    }\n  }\n\n  export class get_proposals_by_status_arguments {\n    static encode(\n      message: get_proposals_by_status_arguments,\n      writer: Writer\n    ): void {\n      const unique_name_start_proposal = message.start_proposal;\n      if (unique_name_start_proposal !== null) {\n        writer.uint32(10);\n        writer.bytes(unique_name_start_proposal);\n      }\n\n      if (message.limit != 0) {\n        writer.uint32(16);\n        writer.uint64(message.limit);\n      }\n\n      if (message.status != 0) {\n        writer.uint32(24);\n        writer.int32(message.status);\n      }\n    }\n\n    static decode(\n      reader: Reader,\n      length: i32\n    ): get_proposals_by_status_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new get_proposals_by_status_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.start_proposal = reader.bytes();\n            break;\n\n          case 2:\n            message.limit = reader.uint64();\n            break;\n\n          case 3:\n            message.status = reader.int32();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    start_proposal: Uint8Array | null;\n    limit: u64;\n    status: proposal_status;\n\n    constructor(\n      start_proposal: Uint8Array | null = null,\n      limit: u64 = 0,\n      status: proposal_status = 0\n    ) {\n      this.start_proposal = start_proposal;\n      this.limit = limit;\n      this.status = status;\n    }\n  }\n\n  export class get_proposals_by_status_result {\n    static encode(\n      message: get_proposals_by_status_result,\n      writer: Writer\n    ): void {\n      const unique_name_value = message.value;\n      for (let i = 0; i < unique_name_value.length; ++i) {\n        writer.uint32(10);\n        writer.fork();\n        proposal_record.encode(unique_name_value[i], writer);\n        writer.ldelim();\n      }\n    }\n\n    static decode(reader: Reader, length: i32): get_proposals_by_status_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new get_proposals_by_status_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.value.push(proposal_record.decode(reader, reader.uint32()));\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    value: Array<proposal_record>;\n\n    constructor(value: Array<proposal_record> = []) {\n      this.value = value;\n    }\n  }\n\n  export class get_proposals_arguments {\n    static encode(message: get_proposals_arguments, writer: Writer): void {\n      const unique_name_start_proposal = message.start_proposal;\n      if (unique_name_start_proposal !== null) {\n        writer.uint32(10);\n        writer.bytes(unique_name_start_proposal);\n      }\n\n      if (message.limit != 0) {\n        writer.uint32(16);\n        writer.uint64(message.limit);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): get_proposals_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new get_proposals_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.start_proposal = reader.bytes();\n            break;\n\n          case 2:\n            message.limit = reader.uint64();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    start_proposal: Uint8Array | null;\n    limit: u64;\n\n    constructor(start_proposal: Uint8Array | null = null, limit: u64 = 0) {\n      this.start_proposal = start_proposal;\n      this.limit = limit;\n    }\n  }\n\n  export class get_proposals_result {\n    static encode(message: get_proposals_result, writer: Writer): void {\n      const unique_name_value = message.value;\n      for (let i = 0; i < unique_name_value.length; ++i) {\n        writer.uint32(10);\n        writer.fork();\n        proposal_record.encode(unique_name_value[i], writer);\n        writer.ldelim();\n      }\n    }\n\n    static decode(reader: Reader, length: i32): get_proposals_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new get_proposals_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.value.push(proposal_record.decode(reader, reader.uint32()));\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    value: Array<proposal_record>;\n\n    constructor(value: Array<proposal_record> = []) {\n      this.value = value;\n    }\n  }\n\n  export class proposal_submission_event {\n    static encode(message: proposal_submission_event, writer: Writer): void {\n      const unique_name_proposal = message.proposal;\n      if (unique_name_proposal !== null) {\n        writer.uint32(10);\n        writer.fork();\n        proposal_record.encode(unique_name_proposal, writer);\n        writer.ldelim();\n      }\n    }\n\n    static decode(reader: Reader, length: i32): proposal_submission_event {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new proposal_submission_event();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.proposal = proposal_record.decode(reader, reader.uint32());\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    proposal: proposal_record | null;\n\n    constructor(proposal: proposal_record | null = null) {\n      this.proposal = proposal;\n    }\n  }\n\n  export class proposal_status_event {\n    static encode(message: proposal_status_event, writer: Writer): void {\n      const unique_name_id = message.id;\n      if (unique_name_id !== null) {\n        writer.uint32(10);\n        writer.bytes(unique_name_id);\n      }\n\n      if (message.status != 0) {\n        writer.uint32(16);\n        writer.int32(message.status);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): proposal_status_event {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new proposal_status_event();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.id = reader.bytes();\n            break;\n\n          case 2:\n            message.status = reader.int32();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    id: Uint8Array | null;\n    status: proposal_status;\n\n    constructor(id: Uint8Array | null = null, status: proposal_status = 0) {\n      this.id = id;\n      this.status = status;\n    }\n  }\n\n  export class proposal_vote_event {\n    static encode(message: proposal_vote_event, writer: Writer): void {\n      const unique_name_id = message.id;\n      if (unique_name_id !== null) {\n        writer.uint32(10);\n        writer.bytes(unique_name_id);\n      }\n\n      if (message.vote_tally != 0) {\n        writer.uint32(16);\n        writer.uint64(message.vote_tally);\n      }\n\n      if (message.vote_threshold != 0) {\n        writer.uint32(24);\n        writer.uint64(message.vote_threshold);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): proposal_vote_event {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new proposal_vote_event();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.id = reader.bytes();\n            break;\n\n          case 2:\n            message.vote_tally = reader.uint64();\n            break;\n\n          case 3:\n            message.vote_threshold = reader.uint64();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    id: Uint8Array | null;\n    vote_tally: u64;\n    vote_threshold: u64;\n\n    constructor(\n      id: Uint8Array | null = null,\n      vote_tally: u64 = 0,\n      vote_threshold: u64 = 0\n    ) {\n      this.id = id;\n      this.vote_tally = vote_tally;\n      this.vote_threshold = vote_threshold;\n    }\n  }\n\n  export enum proposal_status {\n    pending = 0,\n    active = 1,\n    approved = 2,\n    expired = 3,\n    applied = 4,\n    failed = 5,\n    reverted = 6,\n  }\n}\n","import { Writer, Reader } from \"as-proto\";\nimport { common } from \"../common\";\n\nexport namespace chain {\n  export class error_data {\n    static encode(message: error_data, writer: Writer): void {\n      const unique_name_message_2 = message.message;\n      if (unique_name_message_2 !== null) {\n        writer.uint32(10);\n        writer.string(unique_name_message_2);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): error_data {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new error_data();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.message = reader.string();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    message: string | null;\n\n    constructor(message: string | null = null) {\n      this.message = message;\n    }\n  }\n\n  export class result {\n    static encode(message: result, writer: Writer): void {\n      const unique_name_object = message.object;\n      if (unique_name_object !== null) {\n        writer.uint32(10);\n        writer.bytes(unique_name_object);\n      }\n\n      const unique_name_error = message.error;\n      if (unique_name_error !== null) {\n        writer.uint32(18);\n        writer.fork();\n        error_data.encode(unique_name_error, writer);\n        writer.ldelim();\n      }\n    }\n\n    static decode(reader: Reader, length: i32): result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.object = reader.bytes();\n            break;\n\n          case 2:\n            message.error = error_data.decode(reader, reader.uint32());\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    object: Uint8Array | null;\n    error: error_data | null;\n\n    constructor(\n      object: Uint8Array | null = null,\n      error: error_data | null = null\n    ) {\n      this.object = object;\n      this.error = error;\n    }\n  }\n\n  export class object_space {\n    static encode(message: object_space, writer: Writer): void {\n      if (message.system != false) {\n        writer.uint32(8);\n        writer.bool(message.system);\n      }\n\n      const unique_name_zone = message.zone;\n      if (unique_name_zone !== null) {\n        writer.uint32(18);\n        writer.bytes(unique_name_zone);\n      }\n\n      if (message.id != 0) {\n        writer.uint32(24);\n        writer.uint32(message.id);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): object_space {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new object_space();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.system = reader.bool();\n            break;\n\n          case 2:\n            message.zone = reader.bytes();\n            break;\n\n          case 3:\n            message.id = reader.uint32();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    system: bool;\n    zone: Uint8Array | null;\n    id: u32;\n\n    constructor(\n      system: bool = false,\n      zone: Uint8Array | null = null,\n      id: u32 = 0\n    ) {\n      this.system = system;\n      this.zone = zone;\n      this.id = id;\n    }\n  }\n\n  export class database_key {\n    static encode(message: database_key, writer: Writer): void {\n      const unique_name_space = message.space;\n      if (unique_name_space !== null) {\n        writer.uint32(10);\n        writer.fork();\n        object_space.encode(unique_name_space, writer);\n        writer.ldelim();\n      }\n\n      const unique_name_key = message.key;\n      if (unique_name_key !== null) {\n        writer.uint32(18);\n        writer.bytes(unique_name_key);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): database_key {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new database_key();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.space = object_space.decode(reader, reader.uint32());\n            break;\n\n          case 2:\n            message.key = reader.bytes();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    space: object_space | null;\n    key: Uint8Array | null;\n\n    constructor(\n      space: object_space | null = null,\n      key: Uint8Array | null = null\n    ) {\n      this.space = space;\n      this.key = key;\n    }\n  }\n\n  @unmanaged\n  export class max_account_resources {\n    static encode(message: max_account_resources, writer: Writer): void {\n      if (message.value != 0) {\n        writer.uint32(8);\n        writer.uint64(message.value);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): max_account_resources {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new max_account_resources();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.value = reader.uint64();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    value: u64;\n\n    constructor(value: u64 = 0) {\n      this.value = value;\n    }\n  }\n\n  export class head_info {\n    static encode(message: head_info, writer: Writer): void {\n      const unique_name_head_topology = message.head_topology;\n      if (unique_name_head_topology !== null) {\n        writer.uint32(10);\n        writer.fork();\n        common.block_topology.encode(unique_name_head_topology, writer);\n        writer.ldelim();\n      }\n\n      if (message.head_block_time != 0) {\n        writer.uint32(16);\n        writer.uint64(message.head_block_time);\n      }\n\n      if (message.last_irreversible_block != 0) {\n        writer.uint32(24);\n        writer.uint64(message.last_irreversible_block);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): head_info {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new head_info();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.head_topology = common.block_topology.decode(\n              reader,\n              reader.uint32()\n            );\n            break;\n\n          case 2:\n            message.head_block_time = reader.uint64();\n            break;\n\n          case 3:\n            message.last_irreversible_block = reader.uint64();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    head_topology: common.block_topology | null;\n    head_block_time: u64;\n    last_irreversible_block: u64;\n\n    constructor(\n      head_topology: common.block_topology | null = null,\n      head_block_time: u64 = 0,\n      last_irreversible_block: u64 = 0\n    ) {\n      this.head_topology = head_topology;\n      this.head_block_time = head_block_time;\n      this.last_irreversible_block = last_irreversible_block;\n    }\n  }\n\n  export class caller_data {\n    static encode(message: caller_data, writer: Writer): void {\n      const unique_name_caller = message.caller;\n      if (unique_name_caller !== null) {\n        writer.uint32(10);\n        writer.bytes(unique_name_caller);\n      }\n\n      if (message.caller_privilege != 0) {\n        writer.uint32(16);\n        writer.int32(message.caller_privilege);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): caller_data {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new caller_data();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.caller = reader.bytes();\n            break;\n\n          case 2:\n            message.caller_privilege = reader.int32();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    caller: Uint8Array | null;\n    caller_privilege: privilege;\n\n    constructor(\n      caller: Uint8Array | null = null,\n      caller_privilege: privilege = 0\n    ) {\n      this.caller = caller;\n      this.caller_privilege = caller_privilege;\n    }\n  }\n\n  export class argument_data {\n    static encode(message: argument_data, writer: Writer): void {\n      if (message.entry_point != 0) {\n        writer.uint32(8);\n        writer.uint32(message.entry_point);\n      }\n\n      const unique_name_arguments = message.arguments;\n      if (unique_name_arguments !== null) {\n        writer.uint32(18);\n        writer.bytes(unique_name_arguments);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): argument_data {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new argument_data();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.entry_point = reader.uint32();\n            break;\n\n          case 2:\n            message.arguments = reader.bytes();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    entry_point: u32;\n    arguments: Uint8Array | null;\n\n    constructor(entry_point: u32 = 0, arguments: Uint8Array | null = null) {\n      this.entry_point = entry_point;\n      this.arguments = arguments;\n    }\n  }\n\n  @unmanaged\n  export class resource_limit_data {\n    static encode(message: resource_limit_data, writer: Writer): void {\n      if (message.disk_storage_limit != 0) {\n        writer.uint32(8);\n        writer.uint64(message.disk_storage_limit);\n      }\n\n      if (message.disk_storage_cost != 0) {\n        writer.uint32(16);\n        writer.uint64(message.disk_storage_cost);\n      }\n\n      if (message.network_bandwidth_limit != 0) {\n        writer.uint32(24);\n        writer.uint64(message.network_bandwidth_limit);\n      }\n\n      if (message.network_bandwidth_cost != 0) {\n        writer.uint32(32);\n        writer.uint64(message.network_bandwidth_cost);\n      }\n\n      if (message.compute_bandwidth_limit != 0) {\n        writer.uint32(40);\n        writer.uint64(message.compute_bandwidth_limit);\n      }\n\n      if (message.compute_bandwidth_cost != 0) {\n        writer.uint32(48);\n        writer.uint64(message.compute_bandwidth_cost);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): resource_limit_data {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new resource_limit_data();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.disk_storage_limit = reader.uint64();\n            break;\n\n          case 2:\n            message.disk_storage_cost = reader.uint64();\n            break;\n\n          case 3:\n            message.network_bandwidth_limit = reader.uint64();\n            break;\n\n          case 4:\n            message.network_bandwidth_cost = reader.uint64();\n            break;\n\n          case 5:\n            message.compute_bandwidth_limit = reader.uint64();\n            break;\n\n          case 6:\n            message.compute_bandwidth_cost = reader.uint64();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    disk_storage_limit: u64;\n    disk_storage_cost: u64;\n    network_bandwidth_limit: u64;\n    network_bandwidth_cost: u64;\n    compute_bandwidth_limit: u64;\n    compute_bandwidth_cost: u64;\n\n    constructor(\n      disk_storage_limit: u64 = 0,\n      disk_storage_cost: u64 = 0,\n      network_bandwidth_limit: u64 = 0,\n      network_bandwidth_cost: u64 = 0,\n      compute_bandwidth_limit: u64 = 0,\n      compute_bandwidth_cost: u64 = 0\n    ) {\n      this.disk_storage_limit = disk_storage_limit;\n      this.disk_storage_cost = disk_storage_cost;\n      this.network_bandwidth_limit = network_bandwidth_limit;\n      this.network_bandwidth_cost = network_bandwidth_cost;\n      this.compute_bandwidth_limit = compute_bandwidth_limit;\n      this.compute_bandwidth_cost = compute_bandwidth_cost;\n    }\n  }\n\n  export class contract_metadata_object {\n    static encode(message: contract_metadata_object, writer: Writer): void {\n      const unique_name_hash = message.hash;\n      if (unique_name_hash !== null) {\n        writer.uint32(10);\n        writer.bytes(unique_name_hash);\n      }\n\n      if (message.system != false) {\n        writer.uint32(16);\n        writer.bool(message.system);\n      }\n\n      if (message.authorizes_call_contract != false) {\n        writer.uint32(24);\n        writer.bool(message.authorizes_call_contract);\n      }\n\n      if (message.authorizes_transaction_application != false) {\n        writer.uint32(32);\n        writer.bool(message.authorizes_transaction_application);\n      }\n\n      if (message.authorizes_upload_contract != false) {\n        writer.uint32(40);\n        writer.bool(message.authorizes_upload_contract);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): contract_metadata_object {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new contract_metadata_object();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.hash = reader.bytes();\n            break;\n\n          case 2:\n            message.system = reader.bool();\n            break;\n\n          case 3:\n            message.authorizes_call_contract = reader.bool();\n            break;\n\n          case 4:\n            message.authorizes_transaction_application = reader.bool();\n            break;\n\n          case 5:\n            message.authorizes_upload_contract = reader.bool();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    hash: Uint8Array | null;\n    system: bool;\n    authorizes_call_contract: bool;\n    authorizes_transaction_application: bool;\n    authorizes_upload_contract: bool;\n\n    constructor(\n      hash: Uint8Array | null = null,\n      system: bool = false,\n      authorizes_call_contract: bool = false,\n      authorizes_transaction_application: bool = false,\n      authorizes_upload_contract: bool = false\n    ) {\n      this.hash = hash;\n      this.system = system;\n      this.authorizes_call_contract = authorizes_call_contract;\n      this.authorizes_transaction_application =\n        authorizes_transaction_application;\n      this.authorizes_upload_contract = authorizes_upload_contract;\n    }\n  }\n\n  export class compute_bandwidth_entry {\n    static encode(message: compute_bandwidth_entry, writer: Writer): void {\n      const unique_name_name = message.name;\n      if (unique_name_name !== null) {\n        writer.uint32(10);\n        writer.string(unique_name_name);\n      }\n\n      if (message.compute != 0) {\n        writer.uint32(16);\n        writer.uint64(message.compute);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): compute_bandwidth_entry {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new compute_bandwidth_entry();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.name = reader.string();\n            break;\n\n          case 2:\n            message.compute = reader.uint64();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    name: string | null;\n    compute: u64;\n\n    constructor(name: string | null = null, compute: u64 = 0) {\n      this.name = name;\n      this.compute = compute;\n    }\n  }\n\n  export class compute_bandwidth_registry {\n    static encode(message: compute_bandwidth_registry, writer: Writer): void {\n      const unique_name_entries = message.entries;\n      for (let i = 0; i < unique_name_entries.length; ++i) {\n        writer.uint32(10);\n        writer.fork();\n        compute_bandwidth_entry.encode(unique_name_entries[i], writer);\n        writer.ldelim();\n      }\n    }\n\n    static decode(reader: Reader, length: i32): compute_bandwidth_registry {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new compute_bandwidth_registry();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.entries.push(\n              compute_bandwidth_entry.decode(reader, reader.uint32())\n            );\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    entries: Array<compute_bandwidth_entry>;\n\n    constructor(entries: Array<compute_bandwidth_entry> = []) {\n      this.entries = entries;\n    }\n  }\n\n  export class genesis_entry {\n    static encode(message: genesis_entry, writer: Writer): void {\n      const unique_name_space = message.space;\n      if (unique_name_space !== null) {\n        writer.uint32(10);\n        writer.fork();\n        object_space.encode(unique_name_space, writer);\n        writer.ldelim();\n      }\n\n      const unique_name_key = message.key;\n      if (unique_name_key !== null) {\n        writer.uint32(18);\n        writer.bytes(unique_name_key);\n      }\n\n      const unique_name_value = message.value;\n      if (unique_name_value !== null) {\n        writer.uint32(26);\n        writer.bytes(unique_name_value);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): genesis_entry {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new genesis_entry();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.space = object_space.decode(reader, reader.uint32());\n            break;\n\n          case 2:\n            message.key = reader.bytes();\n            break;\n\n          case 3:\n            message.value = reader.bytes();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    space: object_space | null;\n    key: Uint8Array | null;\n    value: Uint8Array | null;\n\n    constructor(\n      space: object_space | null = null,\n      key: Uint8Array | null = null,\n      value: Uint8Array | null = null\n    ) {\n      this.space = space;\n      this.key = key;\n      this.value = value;\n    }\n  }\n\n  export class genesis_data {\n    static encode(message: genesis_data, writer: Writer): void {\n      const unique_name_entries = message.entries;\n      for (let i = 0; i < unique_name_entries.length; ++i) {\n        writer.uint32(10);\n        writer.fork();\n        genesis_entry.encode(unique_name_entries[i], writer);\n        writer.ldelim();\n      }\n    }\n\n    static decode(reader: Reader, length: i32): genesis_data {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new genesis_data();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.entries.push(genesis_entry.decode(reader, reader.uint32()));\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    entries: Array<genesis_entry>;\n\n    constructor(entries: Array<genesis_entry> = []) {\n      this.entries = entries;\n    }\n  }\n\n  export enum privilege {\n    kernel_mode = 0,\n    user_mode = 1,\n  }\n\n  export enum dsa {\n    ecdsa_secp256k1 = 0,\n  }\n}\n","export namespace options {\n  export enum bytes_type {\n    BASE64 = 0,\n    BASE58 = 1,\n    HEX = 2,\n    BLOCK_ID = 3,\n    TRANSACTION_ID = 4,\n    CONTRACT_ID = 5,\n    ADDRESS = 6,\n  }\n}\n","export namespace error {\n  export enum error_code {\n    success = 0,\n    reversion = 1,\n    internal_error = 100,\n    system_authorization_failure = 101,\n    invalid_contract = 102,\n    insufficient_privileges = 103,\n    insufficient_rc = 104,\n    insufficient_return_buffer = 105,\n    unknown_thunk = 106,\n    unknown_operation = 107,\n    read_only_context = 108,\n    failure = -1,\n    field_not_found = -100,\n    unknown_hash_code = -101,\n    unknown_dsa = -102,\n    unknown_system_call = -103,\n    operation_not_found = -104,\n    authorization_failure = -200,\n    invalid_nonce = -201,\n    invalid_signature = -202,\n    malformed_block = -203,\n    malformed_transaction = -204,\n    block_resource_failure = -205,\n    unknown_backend = -1000,\n    unexpected_state = -1001,\n    missing_required_arguments = -1002,\n    unknown_previous_block = -1003,\n    unexpected_height = -1004,\n    block_state_error = -1005,\n    state_merkle_mismatch = -1006,\n    unexpected_receipt = -1007,\n    rpc_failure = -1008,\n    pending_state_error = -1009,\n    timestamp_out_of_bounds = -1010,\n    indexer_failure = -1011,\n    network_bandwidth_limit_exceeded = -1012,\n    compute_bandwidth_limit_exceeded = -1013,\n    disk_storage_limit_exceeded = -1014,\n  }\n}\n","import { Writer, Reader } from \"as-proto\";\n\nexport namespace authority {\n  export class call_data {\n    static encode(message: call_data, writer: Writer): void {\n      const unique_name_contract_id = message.contract_id;\n      if (unique_name_contract_id !== null) {\n        writer.uint32(10);\n        writer.bytes(unique_name_contract_id);\n      }\n\n      if (message.entry_point != 0) {\n        writer.uint32(16);\n        writer.uint32(message.entry_point);\n      }\n\n      const unique_name_caller = message.caller;\n      if (unique_name_caller !== null) {\n        writer.uint32(26);\n        writer.bytes(unique_name_caller);\n      }\n\n      const unique_name_data = message.data;\n      if (unique_name_data !== null) {\n        writer.uint32(34);\n        writer.bytes(unique_name_data);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): call_data {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new call_data();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.contract_id = reader.bytes();\n            break;\n\n          case 2:\n            message.entry_point = reader.uint32();\n            break;\n\n          case 3:\n            message.caller = reader.bytes();\n            break;\n\n          case 4:\n            message.data = reader.bytes();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    contract_id: Uint8Array | null;\n    entry_point: u32;\n    caller: Uint8Array | null;\n    data: Uint8Array | null;\n\n    constructor(\n      contract_id: Uint8Array | null = null,\n      entry_point: u32 = 0,\n      caller: Uint8Array | null = null,\n      data: Uint8Array | null = null\n    ) {\n      this.contract_id = contract_id;\n      this.entry_point = entry_point;\n      this.caller = caller;\n      this.data = data;\n    }\n  }\n\n  export class authorize_arguments {\n    static encode(message: authorize_arguments, writer: Writer): void {\n      if (message.type != 0) {\n        writer.uint32(8);\n        writer.int32(message.type);\n      }\n\n      const unique_name_call = message.call;\n      if (unique_name_call !== null) {\n        writer.uint32(18);\n        writer.fork();\n        call_data.encode(unique_name_call, writer);\n        writer.ldelim();\n      }\n    }\n\n    static decode(reader: Reader, length: i32): authorize_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new authorize_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.type = reader.int32();\n            break;\n\n          case 2:\n            message.call = call_data.decode(reader, reader.uint32());\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    type: authorization_type;\n    call: call_data | null;\n\n    constructor(type: authorization_type = 0, call: call_data | null = null) {\n      this.type = type;\n      this.call = call;\n    }\n  }\n\n  @unmanaged\n  export class authorize_result {\n    static encode(message: authorize_result, writer: Writer): void {\n      if (message.value != false) {\n        writer.uint32(8);\n        writer.bool(message.value);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): authorize_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new authorize_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.value = reader.bool();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    value: bool;\n\n    constructor(value: bool = false) {\n      this.value = value;\n    }\n  }\n\n  export enum authorization_type {\n    contract_call = 0,\n    transaction_application = 1,\n    contract_upload = 2,\n  }\n}\n","export namespace system_call_ids {\n  export enum system_call_id {\n    nop = 0,\n    get_head_info = 1,\n    apply_block = 2,\n    apply_transaction = 3,\n    apply_upload_contract_operation = 4,\n    apply_call_contract_operation = 5,\n    apply_set_system_call_operation = 6,\n    apply_set_system_contract_operation = 7,\n    pre_block_callback = 8,\n    post_block_callback = 9,\n    pre_transaction_callback = 10,\n    post_transaction_callback = 11,\n    get_chain_id = 12,\n    process_block_signature = 101,\n    get_transaction = 102,\n    get_transaction_field = 103,\n    get_block = 104,\n    get_block_field = 105,\n    get_last_irreversible_block = 106,\n    get_account_nonce = 107,\n    verify_account_nonce = 108,\n    set_account_nonce = 109,\n    check_system_authority = 110,\n    get_operation = 111,\n    get_account_rc = 201,\n    consume_account_rc = 202,\n    get_resource_limits = 203,\n    consume_block_resources = 204,\n    put_object = 301,\n    remove_object = 302,\n    get_object = 303,\n    get_next_object = 304,\n    get_prev_object = 305,\n    log = 401,\n    event = 402,\n    hash = 501,\n    recover_public_key = 502,\n    verify_merkle_root = 503,\n    verify_signature = 504,\n    verify_vrf_proof = 505,\n    call = 601,\n    exit = 602,\n    get_arguments = 603,\n    get_contract_id = 604,\n    get_caller = 605,\n    check_authority = 606,\n  }\n}\n","export namespace object_spaces {\n  export enum system_space_id {\n    metadata = 0,\n    system_call_dispatch = 1,\n    contract_bytecode = 2,\n    contract_metadata = 3,\n    transaction_nonce = 4,\n  }\n}\n","import { System } from \"..\";\n\nexport namespace Crypto {\n  export const DEFAULT_PREFIX: u8 = 0x00;\n\n  export enum multicodec {\n    sha1 = 0x11,\n    sha2_256 = 0x12,\n    sha2_512 = 0x13,\n    keccak_256 = 0x1b,\n    ripemd_160 = 0x1053,\n  }\n\n  class Buffer {\n    buffer: Uint8Array;\n    ptr: usize;\n    len: i32;\n\n    constructor(buf: Uint8Array) {\n      this.buffer = buf;\n      this.len = 0;\n      this.ptr = this.buffer.dataStart;\n    }\n\n    pop(): u8 {\n      this.len--;\n      return load<u8>(this.ptr++);\n    }\n\n    push(val: u8): void {\n      this.len++;\n      store<u8>(this.ptr++, val);\n    }\n\n    getData(): Uint8Array {\n      let bytes = new Uint8Array(this.len);\n      memory.copy(bytes.dataStart, this.buffer.dataStart, this.len);\n      return bytes;\n    }\n  }\n\n  export class UnsignedVarint {\n    value: u64;\n\n    constructor(v: u64 = 0) {\n      this.value = v;\n    }\n\n    toBinary(buf: Buffer): void {\n      let n: u64 = this.value;\n\n      while (true) {\n        buf.push(<u8>(n & 0x7F));\n\n        if (n <= 0x7F)\n          break;\n\n        buf.buffer[<u32>(buf.ptr - 1)] |= 0x80;\n        n = (n >> 7);\n      }\n    }\n\n    fromBinary(buf: Buffer): void {\n      this.value = 0;\n      let data: u8 = 0;\n      let i: u32 = 0;\n\n      do {\n        data = buf.pop();\n\n        this.value |= (data & 0x7f) << <u8>i;\n        i += 7;\n      } while (data & 0x80);\n    }\n  }\n\n  export class Multihash {\n    code: u64 = 0;\n    digest: Uint8Array;\n\n    constructor() {\n      this.code = 0;\n      this.digest = new Uint8Array(0);\n    }\n\n    deserialize(buf: Uint8Array): void {\n      const rb = new Buffer(buf);\n\n      const mhCode = new UnsignedVarint();\n      mhCode.fromBinary(rb);\n      const mhSize = new UnsignedVarint();\n      mhSize.fromBinary(rb);\n      this.digest = new Uint8Array(<i32>mhSize.value);\n\n      for (let i: u64 = 0; i < mhSize.value; i++ )\n      {\n        this.digest[<i32>i] = rb.pop();\n      }\n\n      this.code = mhCode.value;\n    }\n\n    serialize(): Uint8Array {\n      const wb = new Buffer(new Uint8Array(532));\n\n      const mhCode = new UnsignedVarint(this.code);\n      mhCode.toBinary(wb);\n      const mhSize = new UnsignedVarint(this.digest.byteLength);\n      mhSize.toBinary(wb);\n\n      for (let i: u64 = 0; i < <u64>this.digest.byteLength; i++ )\n      {\n        wb.push(this.digest[<i32>i]);\n      }\n\n      return wb.getData();\n    }\n  }\n\n  /**\n    * Decodes an address from a public key.\n    * @param pubKey public key as a Uint8Array.\n    * @param prefix address prefix\n    * @returns Uint8Array\n    * @example\n    * ```ts\n    * const recoveredKey = System.recoverPublicKey(signatureData, digest!);\n    * const addr = Crypto.addressFromPublicKey(recoveredKey!);\n    * System.log('recoveredKey (b58): ' + Base58.encode(addr));\n    * ```\n    */\n  export function addressFromPublicKey(pubKey: Uint8Array, prefix: u8 = DEFAULT_PREFIX): Uint8Array {\n    // Address is:\n    // 1 byte prefix\n    // 20 byte ripemd\n    // 4 byte checksum\n\n    const sha256 = new Multihash();\n    const ripemd160 = new Multihash();\n\n    sha256.deserialize(System.hash(multicodec.sha2_256, pubKey)!);\n    ripemd160.deserialize(System.hash(multicodec.ripemd_160, sha256.digest)!);\n\n    let tmpAddr = new Uint8Array(ripemd160.digest.byteLength + 1);\n    tmpAddr[0] = prefix;\n    memory.copy(tmpAddr.dataStart + 1, ripemd160.digest.dataStart, ripemd160.digest.byteLength);\n \n    sha256.deserialize(System.hash(multicodec.sha2_256, tmpAddr)!);\n    sha256.deserialize(System.hash(multicodec.sha2_256, sha256.digest)!);\n\n    let address = new Uint8Array(tmpAddr.byteLength + 4);\n    memory.copy(address.dataStart, tmpAddr.dataStart, tmpAddr.byteLength);\n    memory.copy(address.dataStart + address.byteLength - 4, sha256.digest.dataStart, 4);\n    return address;\n  }\n}","import { Protobuf } from \"as-proto\";\nimport { System } from \"../systemCalls\";\nimport { system_calls, chain, protocol, authority, value } from '@koinos/proto-as';\nimport { StringBytes } from \"./stringBytes\";\n\n\nexport namespace MockVM {\n  export const METADATA_SPACE = new chain.object_space(true, null, 0);\n\n  export class MockAuthority {\n    autorization_type: authority.authorization_type;\n    account: Uint8Array;\n    authorized: bool;\n\n    constructor(autorization_type: authority.authorization_type, account: Uint8Array, authorized: bool) {\n      this.autorization_type = autorization_type;\n      this.account = account;\n      this.authorized = authorized;\n    }\n  }\n\n  /**\n    * Set entry point that will be used when calling System.getEntryPoint()\n    * @param { u32 } entryPoint entry point to set\n    * @example\n    * ```ts\n    * MockVM.setEntryPoint(0xc3ab8ff1);\n    *\n    * const entryPoint = System.getEntryPoint();\n    * System.log('entryPoint: ' + entryPoint.toString());\n    * ```\n    */\n  export function setEntryPoint(entryPoint: u32): void {\n    const entryPointObj = new value.value_type();\n    entryPointObj.int32_value = entryPoint;\n\n    System.putObject(METADATA_SPACE, 'entry_point', entryPointObj, value.value_type.encode);\n  }\n\n  /**\n    * Set contract arguments that will be used when calling System.getContractArguments()\n    * @param { Uint8Array } contractArguments contract arguments to set\n    * @example\n    * ```ts\n    * let contractArguments = StringBytes.stringToBytes('myArgs');\n    * MockVM.setContractArguments(contractArguments);\n    *\n    * contractArguments = System.getContractArguments();\n    * System.log('contractArguments: ' + (StringBytes.bytesToString(contractArguments)!));\n    * ```\n    */\n  export function setContractArguments(contractArguments: Uint8Array): void {\n    System.putBytes(METADATA_SPACE, 'contract_arguments', contractArguments);\n  }\n\n  /**\n    * Set contract id that will be used when calling System.getContractArguments()\n    * @param { Uint8Array } contractId contract id to set\n    * @example\n    * ```ts\n    * let contractId = Base58.decode('1DQzuCcTKacbs9GGScRTU1Hc8BsyARTPqe');\n    * MockVM.setContractId(contractId);\n    *\n    * contractId = System.getContractId();\n    * System.log('contractId: ' + Base58.encode(contractId));\n    * ```\n    */\n  export function setContractId(contractId: Uint8Array): void {\n    System.putBytes(METADATA_SPACE, 'contract_id', contractId);\n  }\n\n  export function setChainId(chainId: Uint8Array): void {\n    System.putBytes(METADATA_SPACE, 'chain_id', chainId);\n  }\n\n  /**\n    * Set head info that will be used when calling System.getHeadInfo()\n    * @param { chain.head_info } headInfo head info to set\n    * @example\n    * ```ts\n    * let headInfo = new chain.head_info();\n    * headInfo.head_block_time = 123456789;\n    * headInfo.last_irreversible_block = 3;\n    *\n    * MockVM.setHeadInfo(headInfo);\n    *\n    * headInfo = System.getHeadInfo();\n    * System.log('headInfo.head_block_time: ' + headInfo.head_block_time.toString());\n    * ```\n    */\n  export function setHeadInfo(headInfo: chain.head_info): void {\n    System.putObject(METADATA_SPACE, 'head_info', headInfo, chain.head_info.encode);\n  }\n\n  /**\n    * Set entry point that will be used when calling System.getEntryPoint()\n    * @param { u64 } lastIrreversibleBlock last irreversible block height to set\n    * @example\n    * ```ts\n    * MockVM.setLastIrreversibleBlock(987654321);\n    *\n    * const lastIrreversibleBlock = System.getLastIrreversibleBlock();\n    * System.log('lastIrreversibleBlock: ' + lastIrreversibleBlock.toString());\n    * ```\n    */\n  export function setLastIrreversibleBlock(lastIrreversibleBlock: u64): void {\n    const lastIrreversibleBlockObj = new value.value_type();\n    lastIrreversibleBlockObj.uint64_value = lastIrreversibleBlock;\n\n    System.putObject(METADATA_SPACE, 'last_irreversible_block', lastIrreversibleBlockObj, value.value_type.encode);\n  }\n\n  /**\n    * Set caller data that will be used when calling System.getCaller()\n    * @param { chain.caller_data } callerData caller data to set\n    * @example\n    * ```ts\n    * let callerData = new chain.caller_data(Base58.decode('1DQzuCcTKacbs9GGScRTU1Hc8BsyARTPqe'), chain.privilege.user_mode);\n    *\n    * MockVM.setCaller(callerData);\n    *\n    * callerData = System.getCaller();\n    *\n    * System.log('callerData.caller_privilege: ' + callerData.caller_privilege.toString());\n    * if (callerData.caller) {\n    *   System.log('callerData.caller (b58): ' + Base58.encode(callerData.caller!));\n    * }\n    * ```\n    */\n  export function setCaller(callerData: chain.caller_data): void {\n    System.putObject(METADATA_SPACE, 'caller', callerData, chain.caller_data.encode);\n  }\n\n  /**\n    * Set transaction that will be used when calling System.getTransaction() and System.getTransactionField(...)\n    * @param { protocol.transaction } transaction transaction to set\n    * @example\n    * ```ts\n    * let transaction = new protocol.transaction();\n    * transaction.id = StringBytes.stringToBytes(\"0x12345\");\n    *\n    * MockVM.setTransaction(transaction);\n    *\n    * transaction = System.getTransaction();\n    *\n    * System.log(\"transaction.id: \" + (StringBytes.bytesToString((transaction.id)!)!));\n    *\n    * let txField = System.getTransactionField('id');\n    * if (txField) {\n    *   System.log(\"transaction.id: \" + (StringBytes.bytesToString((txField.bytes_value) as Uint8Array) as string));\n    * }\n    * ```\n    */\n  export function setTransaction(transaction: protocol.transaction): void {\n    System.putObject(METADATA_SPACE, 'transaction', transaction, protocol.transaction.encode);\n  }\n\n  /**\n    * Set block that will be used when calling System.getBlock() and System.getBlockField(...)\n    * @param { protocol.block } block block to set\n    * @example\n    * ```ts\n    * let block = new protocol.block();\n    * block.id = StringBytes.stringToBytes(\"0x12345\");\n    *\n    * MockVM.setBlock(block);\n    *\n    * block = System.getBlock();\n    *\n    * System.log(\"block.id: \" + (StringBytes.bytesToString((block.id) as Uint8Array) as string));\n    *\n    * let blField = System.getBlockField('id');\n    * if (blField) {\n    *   System.log(\"block.id: \" + (StringBytes.bytesToString((blField.bytes_value) as Uint8Array) as string));\n    * }\n    * ```\n    */\n  export function setBlock(block: protocol.block): void {\n    System.putObject(METADATA_SPACE, 'block', block, protocol.block.encode);\n  }\n\n  /**\n    * Set authorities that will be used when calling System.requireAuthority(...)\n    * @param { MockAuthority[] } authorities authorities to set\n    * @example\n    * ```ts\n    * const account = Base58.decode('1DQzuCcTKacbs9GGScRTU1Hc8BsyARTPqe');\n    * const auth1 = new MockVM.MockAuthority(authority.authorization_type.contract_call, account, true);\n    * const auth2 = new MockVM.MockAuthority(authority.authorization_type.contract_upload, account, false)\n    *\n    * MockVM.setAuthorities([auth1, auth2]);\n    *\n    * System.requireAuthority(authority.authorization_type.contract_call, account);\n    * ```\n    */\n  export function setAuthorities(authorities: MockAuthority[]): void {\n    const authoritiesListType = new value.list_type();\n\n    for (let index = 0; index < authorities.length; index++) {\n      const auth = authorities[index];\n\n      const authorityValueType = new value.value_type();\n      authorityValueType.bool_value = auth.authorized;\n      authorityValueType.bytes_value = auth.account;\n      authorityValueType.int32_value = auth.autorization_type;\n\n      authoritiesListType.values.push(authorityValueType);\n    }\n\n    System.putObject(METADATA_SPACE, 'authority', authoritiesListType, value.list_type.encode);\n  }\n\n   /**\n    * Set results that will be used when calling System.verifyVRFProof(...)\n    * @param { Uint8Array[] } verifyVRFProofResults The results are FIFO, so the first System.verifyVRFPRoof(...) used in your code will use the first result you set in callContractResults, the second System.callContract(...) will get the second result, etc...\n    * @example\n    * ```ts\n    MockVM.setVerifyVRFProofResults([false, true]);\n\n    let callRes = System.verifyVRFProof(pubKey, proof, hash, messgae);\n    if (callRes) {\n      // Will execute\n    }\n\n    let callRes = System.verifyVRFProof(pubKey, proof, hash, messgae);\n    if (callRes) {\n      // Will not execute\n    }\n    * ```\n    */\n    export function setVerifyVRFPRoofResults(verifyVRFProofResults: bool[]): void {\n      const verifyVRFProofResultListType = new value.list_type();\n\n      for (let index = 0; index < verifyVRFProofResults.length; index++) {\n        const callVerufyVRFProofValueType = new value.value_type();\n        callVerufyVRFProofValueType.bool_value = verifyVRFProofResults[index];\n\n        verifyVRFProofResultListType.values.push(callVerufyVRFProofValueType);\n      }\n\n      System.putObject(METADATA_SPACE, 'verify_vrf', verifyVRFProofResultListType, value.list_type.encode);\n    }\n\n  /**\n    * Set call contract results that will be used when calling System.callContract(...)\n    * @param { Uint8Array[] } callContractResults The results are FIFO, so the first System.callContract(...) used in your code will use the first result you set in callContractResults, the second System.callContract(...) will get the second result, etc...\n    * @example\n    * ```ts\n    * const callContractResults = new value.list_type();\n\n    const callContractRes1 = Base64.decode('res1');\n    const callContractRes2 = Base64.decode('res2');\n\n    MockVM.setCallContractResults([callContractRes1, callContractRes2]);\n\n    let callRes = System.callContract(contract_id, 1, new Uint8Array(0));\n    if (callRes) {\n      System.log('callRes1: ' + (Base64.encode(callRes as Uint8Array) as string));\n    }\n\n    callRes = System.callContract(contract_id, 1, new Uint8Array(0));\n    if (callRes) {\n      System.log('callRes2: ' + (Base64.encode(callRes as Uint8Array) as string));\n    }\n    * ```\n    */\n  export function setCallContractResults(callContractResults: system_calls.exit_arguments[]): void {\n    const callContractResultListType = new value.list_type();\n\n    for (let index = 0; index < callContractResults.length; index++) {\n      const callContractResultValueType = new value.value_type();\n      callContractResultValueType.bytes_value = Protobuf.encode(callContractResults[index], system_calls.exit_arguments.encode);\n\n      callContractResultListType.values.push(callContractResultValueType);\n\n    }\n\n    System.putObject(METADATA_SPACE, 'call_contract_results', callContractResultListType, value.list_type.encode);\n  }\n\n  /**\n    * Get contract result set when calling System.exit()\n    * @returns { Uint8Array | null }\n    * @example\n    * ```ts\n    * System.setContractResult(Base64.decode('res1'));\n    *\n    * const contractRes = MockVM.getContractResult();\n    *\n    * if (contractRes) {\n    *   System.log('contractRes: ' + (Base64.encode(contractRes as Uint8Array) as string));\n    * }\n    * ```\n    */\n  export function getContractResult(): Uint8Array | null {\n    const bytes = System.getBytes(METADATA_SPACE, 'contract_result');\n\n    return bytes;\n  }\n\n  /**\n   * Get error message string after a VM error\n   * @returns  { Uint8Array | null }\n   * @example\n   * ```ts\n   * const errorMessage = MockVM.getErrorMessage();\n   * ```\n   */\n  export function getErrorMessage(): String | null {\n    const bytes = System.getBytes(METADATA_SPACE, 'error_message');\n\n    return StringBytes.bytesToString(bytes);\n  }\n\n  /**\n    * Get exit code set when calling System.exitContract(...)\n    * @returns { string[] }\n    * @example\n    * ```ts\n    * System.exit(0);\n    *\n    * const exitCode = MockVM.getExitCode();\n    *\n    * if (exitCode) {\n    *   System.log('exitCode: ' + exitCode.toString());\n    * }\n    * ```\n    */\n  export function getExitCode(): i32 {\n    const bytes = System.getBytes(METADATA_SPACE, 'exit_code');\n\n    if (bytes) {\n      const valueType = Protobuf.decode<value.value_type>(bytes, value.value_type.decode);\n      return valueType.int32_value;\n    }\n\n    return -1;\n  }\n\n  /**\n    * Get logs set when calling System.log()\n    * @returns { string[] }\n    * @example\n    * ```ts\n    * System.log('log 1');\n    * System.log('log 2');\n    *\n    * const logs = MockVM.getLogs();\n    *\n    * for (let index = 0; index < logs.length; index++) {\n    *   const log = logs;\n    * }\n    * ```\n    */\n  export function getLogs(): string[] {\n    const logs: string[] = [];\n\n    const logsBytes = System.getBytes(METADATA_SPACE, 'logs');\n\n    if (logsBytes) {\n      const logsListType = Protobuf.decode<value.list_type>(logsBytes, value.list_type.decode);\n\n      for (let index = 0; index < logsListType.values.length; index++) {\n        const log = logsListType.values[index];\n\n        logs.push(log.string_value!);\n      }\n    }\n\n    return logs;\n  }\n\n  /**\n   * Remove the current logs\n   * @example\n   * ```ts\n   * System.log('log 1');\n   * System.log('log 2');\n   * MockVM.clearLogs();\n   * System.log('log 3');\n   * System.log('log 4');\n   * console.log(MockVM.getLogs().join(\",\"));\n   * // log 3,log 4\n   * ```\n   */\n  export function clearLogs(): void {\n    System.putBytes(METADATA_SPACE, 'logs', new Uint8Array(0));\n  }\n\n  /**\n    * Get logs set when calling System.log()\n    * @returns { string[] }\n    * @example\n    * ```ts\n    * System.Event('my-event-1', Base64.decode('event data'), [Base58.decode('1DQzuCcTKacbs9GGScRTU1Hc8BsyARTPqe')]);\n    * System.Event('my-event-2', Base64.decode('event data 2'), [Base58.decode('1DQzuCcTKacbs9GGScRTU1Hc8BsyARTPqe')]);\n    *\n    * const events = MockVM.getEvents();\n    *\n    * for (let index = 0; index < events.length; index++) {\n    *   const event = events[index];\n    *\n    *   System.log(event.name)\n    *   System.log(event.data.toString())\n    *\n    *   event.impacted.forEach(acct => {\n    *     System.log(Base58.encode(acct));\n    *   });\n    * }\n    * ```\n    */\n  export function getEvents(): system_calls.event_arguments[] {\n    const events: system_calls.event_arguments[] = [];\n\n    const eventsBytes = System.getBytes(METADATA_SPACE, 'events');\n\n    if (eventsBytes) {\n      const eventsListType = Protobuf.decode<value.list_type>(eventsBytes, value.list_type.decode);\n\n      for (let index = 0; index < eventsListType.values.length; index++) {\n        const eventBytes = eventsListType.values[index];\n        events.push(Protobuf.decode<system_calls.event_arguments>(eventBytes.bytes_value!, system_calls.event_arguments.decode));\n      }\n    }\n\n    return events;\n  }\n\n  /**\n    * Reset the MockVM database\n    * @example\n    * ```ts\n    * MockVM.reset();\n    * ```\n    */\n  export function reset(): void {\n    System.putBytes(METADATA_SPACE, 'reset', new Uint8Array(0));\n  }\n\n  /**\n    * Rrestore the backup made via MockVM.commitTransaction()\n    * @example\n    * ```ts\n    * MockVM.rollbackTransaction();\n    * ```\n    */\n  export function rollbackTransaction(): void {\n    System.putBytes(METADATA_SPACE, 'rollback_transaction', new Uint8Array(0));\n  }\n\n  /**\n    * Backup the database so that it can be rolledback to the backedup state if the transaction reverts\n    * @example\n    * ```ts\n    * MockVM.commitTransaction();\n    * ```\n    */\n  export function commitTransaction(): void {\n    System.putBytes(METADATA_SPACE, 'commit_transaction', new Uint8Array(0));\n  }\n}\n","import { Protobuf, System } from \"..\";\nimport { token, error } from \"@koinos/proto-as\";\n\nenum entries {\n  name_entry = 0x82a3537f,\n  symbol_entry = 0xb76a7ca1,\n  decimals_entry = 0xee80fd2f,\n  total_supply_entry = 0xb0da3934,\n  balance_of_entry = 0x5c721497,\n  transfer_entry = 0x27f576ca,\n  mint_entry = 0xdc6f17bb,\n  burn_entry = 0x859facc5,\n}\n\nexport class Token {\n  _contractId: Uint8Array;\n\n  /**\n    * Create an instance of a token contract\n    * @example\n    * ```ts\n    *  const token = new Token(Base58.decode('1DQzuCcTKacbs9GGScFTU1Hc8BsyARTPqe'));\n    * ```\n    */\n  constructor(contractId: Uint8Array) {\n    this._contractId = contractId;\n  }\n\n  /**\n    * Get the name of the token\n    * @returns string\n    * @example\n    * ```ts\n    *  const token = new Token(Base58.decode('1DQzuCcTKacbs9GGScFTU1Hc8BsyARTPqe'));\n    *  const name = token.name();\n    * ```\n    */\n  name(): string {\n    const args = new token.name_arguments();\n\n    const callRes = System.call(this._contractId, entries.name_entry, Protobuf.encode(args, token.name_arguments.encode));\n    System.require(callRes.code == 0, \"failed to retrieve token name\");\n    const res = Protobuf.decode<token.name_result>(callRes.res.object as Uint8Array, token.name_result.decode);\n\n    return res.value!;\n  }\n\n  /**\n    * Get the symbol of the token\n    * @returns string\n    * @example\n    * ```ts\n    *  const token = new Token(Base58.decode('1DQzuCcTKacbs9GGScFTU1Hc8BsyARTPqe'));\n    *  const symbol = token.symbol();\n    * ```\n    */\n  symbol(): string {\n    const args = new token.symbol_arguments();\n\n    const callRes = System.call(this._contractId, entries.symbol_entry, Protobuf.encode(args, token.symbol_arguments.encode));\n    System.require(callRes.code == 0, \"failed to retrieve token symbol\");\n    const res = Protobuf.decode<token.symbol_result>(callRes.res.object as Uint8Array, token.symbol_result.decode);\n\n    return res.value!;\n  }\n\n  /**\n    * Get the decimal of the token\n    * @returns u32\n    * @example\n    * ```ts\n    *  const token = new Token(Base58.decode('1DQzuCcTKacbs9GGScFTU1Hc8BsyARTPqe'));\n    *  const decimals = token.decimals();\n    * ```\n    */\n  decimals(): u32 {\n    const args = new token.decimals_arguments();\n\n    const callRes = System.call(this._contractId, entries.decimals_entry, Protobuf.encode(args, token.decimals_arguments.encode));\n    System.require(callRes.code == 0, \"failed to retrieve token decimals\");\n    const res = Protobuf.decode<token.decimals_result>(callRes.res.object as Uint8Array, token.decimals_result.decode);\n\n    return res.value;\n  }\n\n  /**\n   * Get the total supply of the token\n   * @returns u64\n   * @example\n   * ```ts\n   *  const token = new Token(Base58.decode('1DQzuCcTKacbs9GGScFTU1Hc8BsyARTPqe'));\n   *  const totalSupply = token.totalSupply();\n   * ```\n   */\n  totalSupply(): u64 {\n    const args = new token.total_supply_arguments();\n\n    const callRes = System.call(this._contractId, entries.total_supply_entry, Protobuf.encode(args, token.total_supply_arguments.encode));\n    System.require(callRes.code == 0, \"failed to retrieve token supply\");\n    const res = Protobuf.decode<token.total_supply_result>(callRes.res.object as Uint8Array, token.total_supply_result.decode);\n\n    return res.value;\n  }\n\n  /**\n   * Get the balance of the `owner` account\n   * @param owner owner account\n   * @returns u64 balance\n   * @example\n   * ```ts\n   *  const ownerAccount = Base58.decode('1DQzuCcTKacbs9GGScRTU1Hc8BsyARTPqE');\n   *  const token = new Token(Base58.decode('1DQzuCcTKacbs9GGScFTU1Hc8BsyARTPqe'));\n   *  const balance = token.balanceOf(ownerAccount);\n   * ```\n   */\n  balanceOf(owner: Uint8Array): u64 {\n    const args = new token.balance_of_arguments(owner);\n\n    const callRes = System.call(this._contractId, entries.balance_of_entry, Protobuf.encode(args, token.balance_of_arguments.encode));\n    System.require(callRes.code == 0, \"failed to retrieve token balance\");\n    const res = Protobuf.decode<token.balance_of_result>(callRes.res.object as Uint8Array, token.balance_of_result.decode);\n\n    return res.value;\n  }\n\n  /**\n   * Transfer tokens from `from` to `to`\n   * @param from from account\n   * @param to to account\n   * @param value number of tokens to transfer\n   * @returns bool transfer succeeded or not\n   * @example\n   * ```ts\n   *  const from = Base58.decode('1DQzuCcTKacbs9GGScRTU1Hc8BsyARTPqe');\n   *  const to = Base58.decode('1DQzuCcTKacbs9GGScRTU1Hc8BsyARTPqE');\n   *  const value = 12376182;\n   *\n   *  const token = new Token(Base58.decode('1DQzuCcTKacbs9GGScFTU1Hc8BsyARTPqe'));\n   *  const success = token.transfer(from, to, value);\n   *  if (success) {\n   *    // transfer succeeded\n   *  } else {\n   *    // transfer failed\n   *  }\n   * ```\n   */\n  transfer(from: Uint8Array, to: Uint8Array, amount: u64): bool {\n    const args = new token.transfer_arguments(from, to, amount);\n    const callRes = System.call(this._contractId, entries.transfer_entry, Protobuf.encode(args, token.transfer_arguments.encode));\n    return callRes.code == error.error_code.success;\n  }\n\n  /**\n   * Mint tokens to `to` account\n   * @param to to account\n   * @param value number of tokens to mint\n   * @returns bool mint succeeded or not\n   * @example\n   * ```ts\n   *  const to = Base58.decode('1DQzuCcTKacbs9GGScRTU1Hc8BsyARTPqA');\n   *  const value = 12376182;\n   *\n   *  const token = new Token(Base58.decode('1DQzuCcTKacbs9GGScFTU1Hc8BsyARTPqe'));\n   *  const success = token.mint(to, value);\n   *  if (success) {\n   *    // mint succeeded\n   *  } else {\n   *    // mint failed\n   *  }\n   * ```\n   */\n  mint(to: Uint8Array, amount: u64): bool {\n    const args = new token.mint_arguments(to, amount);\n    const callRes = System.call(this._contractId, entries.mint_entry, Protobuf.encode(args, token.mint_arguments.encode));\n    return callRes.code == error.error_code.success;\n  }\n\n  /**\n   * Burn tokens from `from`\n   * @param from from account\n   * @param value number of tokens to burn\n   * @returns bool burn succeeded or not\n   * @example\n   * ```ts\n   *  const from = Base58.decode('1DQzuCcTKacbs9GGScRTU1Hc8BsyARTPqe');\n   *  const value = 12376182;\n   *\n   *  const token = new Token(Base58.decode('1DQzuCcTKacbs9GGScFTU1Hc8BsyARTPqe'));\n   *  const success = token.burn(from, value);\n   *  if (success) {\n   *    // transfer succeeded\n   *  } else {\n   *    // transfer failed\n   *  }\n   * ```\n   */\n  burn(from: Uint8Array, amount: u64): bool {\n    const args = new token.burn_arguments(from, amount);\n    const callRes = System.call(this._contractId, entries.burn_entry, Protobuf.encode(args, token.burn_arguments.encode));\n    return callRes.code == error.error_code.success;\n  }\n}\n","import { env } from \"./env\";\nimport { Protobuf, Reader, Writer } from 'as-proto';\nimport { system_calls, system_call_ids, chain, protocol, authority, value, error } from '@koinos/proto-as';\nimport { StringBytes } from \".\";\nimport { Base58 } from \"./util\";\n\nexport namespace System {\n  export const DEFAULT_MAX_BUFFER_SIZE = 1024;\n  let MAX_BUFFER_SIZE = DEFAULT_MAX_BUFFER_SIZE;\n  let SYSTEM_CALL_BUFFER = new Uint8Array(MAX_BUFFER_SIZE);\n  let RETURN_BYTES = new Uint32Array(1);\n\n  let ERROR_MESSAGE = \"\";\n\n  function checkErrorCode(code: i32, message: Uint8Array): void {\n    if (code != error.error_code.success)\n      exit(code, message);\n  }\n\n  export function setSystemBufferSize(size: u32): void {\n    MAX_BUFFER_SIZE = size;\n    SYSTEM_CALL_BUFFER = new Uint8Array(MAX_BUFFER_SIZE);\n  }\n\n  export function getSystemBufferSize(): u32 {\n    return MAX_BUFFER_SIZE;\n  }\n\n  // General Blockchain Management\n\n  /**\n    * Get the blockchain head information (head block time, height, last irreversible block, etc...)\n    * @returns chain.head_info\n    * @example\n    * ```ts\n    *  const headInfo = System.getHeadInfo();\n    *  System.log('headInfo.head_block_time: ' + headInfo.head_block_time.toString());\n    *  System.log('headInfo.head_topology.height: ' + headInfo.head_topology!.height.toString());\n    *  System.log('headInfo.last_irreversible_block.: ' + headInfo.last_irreversible_block.toString());\n    * ```\n    */\n  export function getHeadInfo(): chain.head_info {\n    const args = new system_calls.get_head_info_arguments();\n    const encodedArgs = Protobuf.encode(args, system_calls.get_head_info_arguments.encode);\n\n    const retcode = env.invokeSystemCall(system_call_ids.system_call_id.get_head_info, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n    checkErrorCode(retcode, SYSTEM_CALL_BUFFER.slice(0, RETURN_BYTES[0]));\n    const result = Protobuf.decode<system_calls.get_head_info_result>(SYSTEM_CALL_BUFFER, system_calls.get_head_info_result.decode, RETURN_BYTES[0]);\n\n    return result.value!;\n  }\n\n  export function applyBlock(block: protocol.block): i32 {\n    const args = new system_calls.apply_block_arguments(block);\n    const encodedArgs = Protobuf.encode(args, system_calls.apply_block_arguments.encode);\n\n    const retcode = env.invokeSystemCall(system_call_ids.system_call_id.apply_block, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n    ERROR_MESSAGE = StringBytes.bytesToString(SYSTEM_CALL_BUFFER.slice(0, RETURN_BYTES[0]))!;\n    return retcode;\n  }\n\n  export function applyTransaction(transaction: protocol.transaction): i32 {\n    const args = new system_calls.apply_transaction_arguments(transaction);\n    const encodedArgs = Protobuf.encode(args, system_calls.apply_transaction_arguments.encode);\n\n    const retcode = env.invokeSystemCall(system_call_ids.system_call_id.apply_transaction, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n    ERROR_MESSAGE = StringBytes.bytesToString(SYSTEM_CALL_BUFFER.slice(0, RETURN_BYTES[0]))!;\n    return retcode;\n  }\n\n  export function applyUploadContractOperation(op: protocol.upload_contract_operation): i32 {\n    const args = new system_calls.apply_upload_contract_operation_arguments(op);\n    const encodedArgs = Protobuf.encode(args, system_calls.apply_upload_contract_operation_arguments.encode);\n\n    const retcode = env.invokeSystemCall(system_call_ids.system_call_id.apply_upload_contract_operation, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n    ERROR_MESSAGE = StringBytes.bytesToString(SYSTEM_CALL_BUFFER.slice(0, RETURN_BYTES[0]))!;\n    return retcode;\n  }\n\n  export function applyCallContractOperation(op: protocol.call_contract_operation): i32 {\n    const args = new system_calls.apply_call_contract_operation_arguments(op);\n    const encodedArgs = Protobuf.encode(args, system_calls.apply_call_contract_operation_arguments.encode);\n\n    const retcode = env.invokeSystemCall(system_call_ids.system_call_id.apply_call_contract_operation, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n    ERROR_MESSAGE = StringBytes.bytesToString(SYSTEM_CALL_BUFFER.slice(0, RETURN_BYTES[0]))!;\n    return retcode;\n  }\n\n  export function applySetSystemCallOperation(op: protocol.set_system_call_operation): i32 {\n    const args = new system_calls.apply_set_system_call_operation_arguments(op);\n    const encodedArgs = Protobuf.encode(args, system_calls.apply_set_system_call_operation_arguments.encode);\n\n    const retcode = env.invokeSystemCall(system_call_ids.system_call_id.apply_set_system_call_operation, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n    ERROR_MESSAGE = StringBytes.bytesToString(SYSTEM_CALL_BUFFER.slice(0, RETURN_BYTES[0]))!;\n    return retcode;\n  }\n\n  export function applySetSystemContractOperation(op: protocol.set_system_contract_operation): i32 {\n    const args = new system_calls.apply_set_system_contract_operation_arguments(op);\n    const encodedArgs = Protobuf.encode(args, system_calls.apply_set_system_contract_operation_arguments.encode);\n\n    const retcode = env.invokeSystemCall(system_call_ids.system_call_id.apply_set_system_contract_operation, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n    ERROR_MESSAGE = StringBytes.bytesToString(SYSTEM_CALL_BUFFER.slice(0, RETURN_BYTES[0]))!;\n    return retcode;\n  }\n\n  export function getChainId(): Uint8Array {\n    const args = new system_calls.get_chain_id_arguments();\n    const encodedArgs = Protobuf.encode(args, system_calls.get_chain_id_arguments.encode);\n\n    const retcode = env.invokeSystemCall(system_call_ids.system_call_id.get_chain_id, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n    checkErrorCode(retcode, SYSTEM_CALL_BUFFER.slice(0, RETURN_BYTES[0]));\n    const result = Protobuf.decode<system_calls.get_chain_id_result>(SYSTEM_CALL_BUFFER, system_calls.get_chain_id_result.decode, RETURN_BYTES[0]);\n\n    return result.value!;\n  }\n\n  // System Helpers\n\n  export function processBlockSignature(digest: Uint8Array, header: protocol.block_header, signature: Uint8Array): bool {\n    const args = new system_calls.process_block_signature_arguments(digest, header, signature);\n    const encodedArgs = Protobuf.encode(args, system_calls.process_block_signature_arguments.encode);\n\n    const retcode = env.invokeSystemCall(system_call_ids.system_call_id.process_block_signature, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n    checkErrorCode(retcode, SYSTEM_CALL_BUFFER.slice(0, RETURN_BYTES[0]));\n    const result = Protobuf.decode<system_calls.process_block_signature_result>(SYSTEM_CALL_BUFFER, system_calls.process_block_signature_result.decode, RETURN_BYTES[0]);\n\n    return result.value;\n  }\n\n  /**\n    * Get the current transaction\n    * @returns protocol.transaction\n    * @example\n    * ```ts\n    *  const tx = System.getTransaction();\n    *  System.log(\"payer: \" + Base58.encode((tx.header!.payer!)));\n    * ```\n    */\n  export function getTransaction(): protocol.transaction {\n    const args = new system_calls.get_transaction_arguments();\n    const encodedArgs = Protobuf.encode(args, system_calls.get_transaction_arguments.encode);\n\n    const retcode = env.invokeSystemCall(system_call_ids.system_call_id.get_transaction, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n    checkErrorCode(retcode, SYSTEM_CALL_BUFFER.slice(0, RETURN_BYTES[0]));\n    const result = Protobuf.decode<system_calls.get_transaction_result>(SYSTEM_CALL_BUFFER, system_calls.get_transaction_result.decode, RETURN_BYTES[0]);\n\n    return result.value!;\n  }\n\n  /**\n    * Get a field from the current transaction\n    * @param field field to get (i.e.: 'id', 'header.payer')\n    * @returns value.value_type | null\n    * @example\n    * ```ts\n    *  const txField = System.getTransactionField('header.payer');\n    *  if (txField) {\n    *    System.log(\"payer: \" + Base58.encode(txField.bytes_value!));\n    *  }\n    * ```\n    */\n  export function getTransactionField(field: string): value.value_type | null {\n    const args = new system_calls.get_transaction_field_arguments(field);\n    const encodedArgs = Protobuf.encode(args, system_calls.get_transaction_field_arguments.encode);\n\n    const retcode = env.invokeSystemCall(system_call_ids.system_call_id.get_transaction_field, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n    checkErrorCode(retcode, SYSTEM_CALL_BUFFER.slice(0, RETURN_BYTES[0]));\n    const result = Protobuf.decode<system_calls.get_transaction_field_result>(SYSTEM_CALL_BUFFER, system_calls.get_transaction_field_result.decode, RETURN_BYTES[0]);\n\n    return result.value;\n  }\n\n  /**\n    * Get the current block\n    * @returns protocol.block\n    * @example\n    * ```ts\n    *  const b = System.getBlock();\n    *  System.log(\"signer: \" + Base58.encode((b.header!.signer!)));\n    * ```\n    */\n  export function getBlock(): protocol.block {\n    const args = new system_calls.get_block_arguments();\n    const encodedArgs = Protobuf.encode(args, system_calls.get_block_arguments.encode);\n\n    const retcode = env.invokeSystemCall(system_call_ids.system_call_id.get_block, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n    checkErrorCode(retcode, SYSTEM_CALL_BUFFER.slice(0, RETURN_BYTES[0]));\n    const result = Protobuf.decode<system_calls.get_block_result>(SYSTEM_CALL_BUFFER, system_calls.get_block_result.decode, RETURN_BYTES[0]);\n\n    return result.value!;\n  }\n\n  /**\n    * Get a field from the current block\n    * @param field field to get (i.e.: 'id', 'header.signer')\n    * @returns value.value_type | null\n    * @example\n    * ```ts\n    * const blField = System.getBlockField('header.signer');\n    * System.require(blField, `expected blField not \"null\", got \"null\"`);\n    *\n    * if (blField) {\n    *   System.log(\"signer: \" + Base58.encode(blField.bytes_value!));\n    * }\n    * ```\n    */\n  export function getBlockField(field: string): value.value_type | null {\n    const args = new system_calls.get_block_field_arguments(field);\n    const encodedArgs = Protobuf.encode(args, system_calls.get_block_field_arguments.encode);\n\n    const retcode = env.invokeSystemCall(system_call_ids.system_call_id.get_block_field, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n    checkErrorCode(retcode, SYSTEM_CALL_BUFFER.slice(0, RETURN_BYTES[0]));\n    const result = Protobuf.decode<system_calls.get_block_field_result>(SYSTEM_CALL_BUFFER, system_calls.get_block_field_result.decode, RETURN_BYTES[0]);\n\n    return result.value;\n  }\n\n  /**\n    * Get the last irreversible block height\n    * @returns u64\n    * @example\n    * ```ts\n    * const lastIrreversibleBlock = System.getLastIrreversibleBlock();\n    * System.log('lastIrreversibleBlock: ' + lastIrreversibleBlock.toString());\n    * ```\n    */\n  export function getLastIrreversibleBlock(): u64 {\n    const args = new system_calls.get_last_irreversible_block_arguments();\n    const encodedArgs = Protobuf.encode(args, system_calls.get_last_irreversible_block_arguments.encode);\n\n    const retcode = env.invokeSystemCall(system_call_ids.system_call_id.get_last_irreversible_block, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n    checkErrorCode(retcode, SYSTEM_CALL_BUFFER.slice(0, RETURN_BYTES[0]));\n    const result = Protobuf.decode<system_calls.get_last_irreversible_block_result>(SYSTEM_CALL_BUFFER, system_calls.get_last_irreversible_block_result.decode, RETURN_BYTES[0]);\n\n    return result.value;\n  }\n\n  export function getAccountNonce(account: Uint8Array): Uint8Array | null {\n    const args = new system_calls.get_account_nonce_arguments(account);\n    const encodedArgs = Protobuf.encode(args, system_calls.get_account_nonce_arguments.encode);\n\n    const retcode = env.invokeSystemCall(system_call_ids.system_call_id.get_account_nonce, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n    checkErrorCode(retcode, SYSTEM_CALL_BUFFER.slice(0, RETURN_BYTES[0]));\n    const result = Protobuf.decode<system_calls.get_account_nonce_result>(SYSTEM_CALL_BUFFER, system_calls.get_account_nonce_result.decode, RETURN_BYTES[0]);\n\n    return result.value;\n  }\n\n  export function verifyAccountNonce(account: Uint8Array, nonce: Uint8Array): bool {\n    const args = new system_calls.verify_account_nonce_arguments(account, nonce);\n    const encodedArgs = Protobuf.encode(args, system_calls.verify_account_nonce_arguments.encode);\n\n    const retcode = env.invokeSystemCall(system_call_ids.system_call_id.verify_account_nonce, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n    checkErrorCode(retcode, SYSTEM_CALL_BUFFER.slice(0, RETURN_BYTES[0]));\n    const result = Protobuf.decode<system_calls.verify_account_nonce_result>(SYSTEM_CALL_BUFFER, system_calls.verify_account_nonce_result.decode, RETURN_BYTES[0]);\n\n    return result.value;\n  }\n\n  export function setAccountNonce(account: Uint8Array, nonce: Uint8Array): void {\n    const args = new system_calls.set_account_nonce_arguments(account, nonce);\n\n    const encodedArgs = Protobuf.encode(args, system_calls.set_account_nonce_arguments.encode);\n\n    const retcode = env.invokeSystemCall(system_call_ids.system_call_id.verify_account_nonce, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n    checkErrorCode(retcode, SYSTEM_CALL_BUFFER.slice(0, RETURN_BYTES[0]));\n  }\n\n  export function checkSystemAuthority(): bool {\n    const args = new system_calls.check_system_authority_arguments();\n    const encodedArgs = Protobuf.encode(args, system_calls.check_system_authority_arguments.encode);\n\n    const retcode = env.invokeSystemCall(system_call_ids.system_call_id.check_system_authority, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n    checkErrorCode(retcode, SYSTEM_CALL_BUFFER.slice(0, RETURN_BYTES[0]));\n    return Protobuf.decode<system_calls.check_system_authority_result>(SYSTEM_CALL_BUFFER, system_calls.check_system_authority_result.decode).value;\n  }\n\n  export function requireSystemAuthority(): void {\n    require(checkSystemAuthority());\n  }\n\n  // Resource Subsystem\n\n  export function getAccountRC(account: Uint8Array): u64 {\n    const args = new system_calls.get_account_rc_arguments(account);\n    const encodedArgs = Protobuf.encode(args, system_calls.get_account_rc_arguments.encode);\n\n    const retcode = env.invokeSystemCall(system_call_ids.system_call_id.get_account_rc, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n    checkErrorCode(retcode, SYSTEM_CALL_BUFFER.slice(0, RETURN_BYTES[0]));\n    const result = Protobuf.decode<system_calls.get_account_rc_result>(SYSTEM_CALL_BUFFER, system_calls.get_account_rc_result.decode, RETURN_BYTES[0]);\n\n    return result.value;\n  }\n\n  export function consumeAccountRC(account: Uint8Array, value: u64): bool {\n    const args = new system_calls.consume_account_rc_arguments(account, value);\n    const encodedArgs = Protobuf.encode(args, system_calls.consume_account_rc_arguments.encode);\n\n    const retcode = env.invokeSystemCall(system_call_ids.system_call_id.consume_account_rc, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n    checkErrorCode(retcode, SYSTEM_CALL_BUFFER.slice(0, RETURN_BYTES[0]));\n    const result = Protobuf.decode<system_calls.consume_account_rc_result>(SYSTEM_CALL_BUFFER, system_calls.consume_account_rc_result.decode, RETURN_BYTES[0]);\n\n    return result.value;\n  }\n\n  export function getResourceLimits(): chain.resource_limit_data {\n    const args = new system_calls.get_resource_limits_arguments();\n    const encodedArgs = Protobuf.encode(args, system_calls.get_resource_limits_arguments.encode);\n\n    const retcode = env.invokeSystemCall(system_call_ids.system_call_id.get_resource_limits, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n    checkErrorCode(retcode, SYSTEM_CALL_BUFFER.slice(0, RETURN_BYTES[0]));\n    const result = Protobuf.decode<system_calls.get_resource_limits_result>(SYSTEM_CALL_BUFFER, system_calls.get_resource_limits_result.decode, RETURN_BYTES[0]);\n\n    return result.value!;\n  }\n\n  export function consumeBlockResources(disk_storage_consumed: u64, network_bandwidth_consumed: u64, compute_bandwidth_consumed: u64): bool {\n    const args = new system_calls.consume_block_resources_arguments(disk_storage_consumed, network_bandwidth_consumed, compute_bandwidth_consumed);\n    const encodedArgs = Protobuf.encode(args, system_calls.consume_block_resources_arguments.encode);\n\n    const retcode = env.invokeSystemCall(system_call_ids.system_call_id.consume_block_resources, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n    checkErrorCode(retcode, SYSTEM_CALL_BUFFER.slice(0, RETURN_BYTES[0]));\n    const result = Protobuf.decode<system_calls.consume_block_resources_result>(SYSTEM_CALL_BUFFER, system_calls.consume_block_resources_result.decode, RETURN_BYTES[0]);\n\n    return result.value;\n  }\n\n  // Logging\n\n  /**\n    * Log a string\n    * @param s string to log\n    * @example\n    * ```ts\n    * System.log('Hello World!');\n    * ```\n    */\n  export function log(s: string): void {\n    const args = new system_calls.log_arguments(s);\n    const encodedArgs = Protobuf.encode(args, system_calls.log_arguments.encode);\n\n    const retcode = env.invokeSystemCall(system_call_ids.system_call_id.log, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n    checkErrorCode(retcode, SYSTEM_CALL_BUFFER.slice(0, RETURN_BYTES[0]));\n  }\n\n  /**\n    * Emit an event\n    * @param name name of the event\n    * @param data data associated to the event\n    * @param impacted accounts impacted by the event\n    * @example\n    * ```ts\n    * const from = Base58.decode(\"1DQzuCcTKacbs9GGScRTU1Hc8BsyARTPqe\");\n    * const to = Base58.decode(\"1DQzuCcTKacbs9GGScRTU1Hc8BsyARTPqe\");\n    * const impacted: Uint8Array[] = [];\n    * impacted.push(from);\n    * impacted.push(to);\n    *\n    * const transferEvent = new token.transfer_event();\n    * transferEvent.from = from;\n    * transferEvent.to = to;\n    * transferEvent.value = amount;\n    *\n    * System.event('koin.transfer', Protobuf.encode(transferEvent, token.transfer_event.encode), impacted);\n    * ```\n    */\n  export function event(name: string, data: Uint8Array, impacted: Uint8Array[]): void {\n    const args = new system_calls.event_arguments(name, data, impacted);\n    const encodedArgs = Protobuf.encode(args, system_calls.event_arguments.encode);\n\n    const retcode = env.invokeSystemCall(system_call_ids.system_call_id.event, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n    checkErrorCode(retcode, SYSTEM_CALL_BUFFER.slice(0, RETURN_BYTES[0]));\n  }\n\n  // Cryptography\n\n  /**\n    * Hash an object\n    * @param code a Crypto.multicodec code\n    * @param obj object to hash\n    * @param size size of the object to hash\n    * @returns Uint8Array | null\n    * @example\n    * ```ts\n    * const digest = System.hash(Crypto.multicodec.sha2_256, StringBytes.stringToBytes('hello world!));\n    * ```\n    */\n  export function hash(code: u64, obj: Uint8Array, size: u64 = 0): Uint8Array | null {\n    const args = new system_calls.hash_arguments(code, obj, size);\n    const encodedArgs = Protobuf.encode(args, system_calls.hash_arguments.encode);\n\n    const retcode = env.invokeSystemCall(system_call_ids.system_call_id.hash, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n    checkErrorCode(retcode, SYSTEM_CALL_BUFFER.slice(0, RETURN_BYTES[0]));\n    const result = Protobuf.decode<system_calls.hash_result>(SYSTEM_CALL_BUFFER, system_calls.hash_result.decode, RETURN_BYTES[0]);\n\n    return result.value;\n  }\n\n  /**\n    * Recover a publick key given a signature and a digest that was signed by the public key\n    * @param signatureData the signature of the digest\n    * @param digest digest that was signed by the public key\n    * @param type type of signature\n    * @param compressed whether the public key should be compressed\n    * @returns Uint8Array | null\n    * @example\n    * ```ts\n    * const message = 'hello-world';\n    * const signatureData = Base64.decode('IHhJwlD7P-o6x7L38den1MnumUhnYmNhTZhIUQQhezvEMf7rx89NbIIioNCIQSk1PQYdQ9mOI4-rDYiwO2pLvM4=');\n    * const digest = System.hash(Crypto.multicodec.sha2_256, StringBytes.stringToBytes(message));\n    * const recoveredKey = System.recoverPublicKey(signatureData, digest!);\n    * const addr = Crypto.addressFromPublicKey(recoveredKey!);\n    * System.log('recoveredKey (b58): ' + Base58.encode(addr));\n    * ```\n    */\n  export function recoverPublicKey(signatureData: Uint8Array, digest: Uint8Array, type: chain.dsa = chain.dsa.ecdsa_secp256k1, compressed: bool = true): Uint8Array | null {\n    const args = new system_calls.recover_public_key_arguments(type, signatureData, digest, compressed);\n    const encodedArgs = Protobuf.encode(args, system_calls.recover_public_key_arguments.encode);\n\n    const retcode = env.invokeSystemCall(system_call_ids.system_call_id.recover_public_key, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n    checkErrorCode(retcode, SYSTEM_CALL_BUFFER.slice(0, RETURN_BYTES[0]));\n    const result = Protobuf.decode<system_calls.recover_public_key_result>(SYSTEM_CALL_BUFFER, system_calls.recover_public_key_result.decode, RETURN_BYTES[0]);\n\n    return result.value;\n  }\n\n  /**\n    * Verify a merkle root\n    * @param root merkle root to verify\n    * @param hashes hashes to verify\n    * @returns bool\n    * @example\n    * ```ts\n    * ```\n    */\n  export function verifyMerkleRoot(root: Uint8Array, hashes: Array<Uint8Array>): bool {\n    const args = new system_calls.verify_merkle_root_arguments(root, hashes);\n    const encodedArgs = Protobuf.encode(args, system_calls.verify_merkle_root_arguments.encode);\n\n    const retcode = env.invokeSystemCall(system_call_ids.system_call_id.verify_merkle_root, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n    checkErrorCode(retcode, SYSTEM_CALL_BUFFER.slice(0, RETURN_BYTES[0]));\n    const result = Protobuf.decode<system_calls.verify_merkle_root_result>(SYSTEM_CALL_BUFFER, system_calls.verify_merkle_root_result.decode, RETURN_BYTES[0]);\n\n    return result.value;\n  }\n\n  /**\n    * Verify that a public key signed a digest\n    * @param publicKey public key that signed the digest\n    * @param signature signature of the digest\n    * @param digest digest that was signed\n    * @param type type of signature\n    * @param compressed whether or not the public key is compressed\n    * @returns bool\n    * @example\n    * ```ts\n    * let verify = System.verifySignature(recoveredKey!, signatureData, digest!);\n    * System.require(verify == true, `expected \"true\", got \"${verify}\"`);\n    * ```\n    */\n  export function verifySignature(publicKey: Uint8Array, signature: Uint8Array, digest: Uint8Array, type: chain.dsa = chain.dsa.ecdsa_secp256k1, compressed: bool = true): bool {\n    const args = new system_calls.verify_signature_arguments(type, publicKey, signature, digest, compressed);\n    const encodedArgs = Protobuf.encode(args, system_calls.verify_signature_arguments.encode);\n\n    const retcode = env.invokeSystemCall(system_call_ids.system_call_id.verify_signature, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n    checkErrorCode(retcode, SYSTEM_CALL_BUFFER.slice(0, RETURN_BYTES[0]));\n    const result = Protobuf.decode<system_calls.verify_signature_result>(SYSTEM_CALL_BUFFER, system_calls.verify_signature_result.decode, RETURN_BYTES[0]);\n\n    return result.value;\n  }\n\n  /**\n   * Verifies a VRF proof\n   * @param publicKey public key that generated the proof\n   * @param proof the VRF proof itself\n   * @param hash the hash of the proof\n   * @param message the original message input\n   * @param type type of signature\n   */\n  export function verifyVRFProof(publicKey: Uint8Array, proof: Uint8Array, hash: Uint8Array, message: Uint8Array, type: chain.dsa = chain.dsa.ecdsa_secp256k1): bool {\n    const args = new system_calls.verify_vrf_proof_arguments(type, publicKey, proof, hash, message );\n    const encodedArgs = Protobuf.encode(args, system_calls.verify_vrf_proof_arguments.encode);\n\n    const retcode = env.invokeSystemCall(system_call_ids.system_call_id.verify_vrf_proof, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n    checkErrorCode(retcode, SYSTEM_CALL_BUFFER.slice(0, RETURN_BYTES[0]));\n    const result = Protobuf.decode<system_calls.verify_signature_result>(SYSTEM_CALL_BUFFER, system_calls.verify_signature_result.decode, RETURN_BYTES[0]);\n\n    return result.value;\n  }\n\n  // Contract Management\n\n  export class callReturn {\n    code: i32;\n    res: chain.result = new chain.result();\n  }\n\n  /**\n    * Call a contract\n    * @param contractId id of the contract to call\n    * @param entryPoint entry point of the contract to call\n    * @param contractArgs arguments of the contract to call\n    * @returns Uint8Array | null\n    * @example\n    * ```ts\n    * // Transfer 10 tKOIN to 1DQzuCcTKacbs9GGScRTU1Hc8BsyARTPqe\n    * const koinContractId = Base58.decode(\"1NvZvWNqDX7t93inmLBvbv6kxhpEZYRFWK\");\n    * const tranferEntryPoint = 0x62efa292;\n    * const from = contractId; // this contract\n    * const to = Base58.decode(\"1DQzuCcTKacbs9GGScRTU1Hc8BsyARTPqe\");\n    * const amount = 10 * 10 ** 8; // needs to be multiplied by 10^8 because Koin is 8 decimals\n    *\n    * const koinTransferArgs = new koin.transfer_arguments();\n    * koinTransferArgs.from = from;\n    * koinTransferArgs.to = to;\n    * koinTransferArgs.value = amount;\n    *\n    * const resBuf = System.callContract(koinContractId, tranferEntryPoint, Protobuf.encode(koinTransferArgs, koin.transfer_arguments.encode));\n    * System.require(resBuf, `expected resBuf not \"null\", got \"null\"`);\n    *\n    * if (resBuf) {\n    *   const transferRes = Protobuf.decode<koin.transfer_result>(resBuf, koin.transfer_result.decode, RETURN_BYTES[0]);\n    *   System.require(transferRes.value, `expected transfer not \"true\", got \"false\"`);\n    *\n    *   const impacted: Uint8Array[] = [];\n    *   impacted.push(from);\n    *   impacted.push(to);\n    *\n    *   const transferEvent = new token.transfer_event();\n    *   transferEvent.from = from;\n    *   transferEvent.to = to;\n    *   transferEvent.value = amount;\n    *\n    *   System.event('koin.transfer', Protobuf.encode(transferEvent, token.transfer_event.encode), impacted);\n    *\n    *   System.log(`transfered ${amount / 10 ** 8} tKoin from ${Base58.encode(from)} to ${Base58.encode(to)}`);\n    * }\n    * ```\n    */\n  export function call(contractId: Uint8Array, entryPoint: u32, contractArgs: Uint8Array): callReturn {\n    const args = new system_calls.call_arguments(contractId, entryPoint, contractArgs);\n    const encodedArgs = Protobuf.encode(args, system_calls.call_arguments.encode);\n\n    const retcode = env.invokeSystemCall(system_call_ids.system_call_id.call, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n\n    let result = new chain.result();\n    if (retcode) {\n      result.error = Protobuf.decode<chain.error_data>(SYSTEM_CALL_BUFFER, chain.error_data.decode, RETURN_BYTES[0]);\n    }\n    else {\n      result.object = Protobuf.decode<system_calls.call_result>(SYSTEM_CALL_BUFFER, system_calls.call_result.decode, RETURN_BYTES[0]).value;\n    }\n\n    return {code: retcode, res: result};\n  }\n\n  export class getArgumentsReturn {\n    constructor() {\n      this.entry_point = 0;\n      this.args = new Uint8Array(0);\n    }\n\n    entry_point: u32;\n    args: Uint8Array;\n  }\n\n  /**\n    * Get arguments that were used when calling the contract\n    * @returns Uint8Array\n    * @example\n    * ```ts\n    * const rdbuf = System.getContractArguments();\n    * const contractArgs = Protobuf.decode<foobar.foobar_arguments>(rdbuf, foobar.foobar_arguments.decode, RETURN_BYTES[0]);\n    * System.log('contractArgs: ' + contractArgs.value.toString());\n    * ```\n    */\n  export function getArguments(): getArgumentsReturn {\n    const args = new system_calls.get_arguments_arguments();\n    const encodedArgs = Protobuf.encode(args, system_calls.get_arguments_arguments.encode);\n\n    const retcode = env.invokeSystemCall(system_call_ids.system_call_id.get_arguments, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n    checkErrorCode(retcode, SYSTEM_CALL_BUFFER.slice(0, RETURN_BYTES[0]));\n    const result = Protobuf.decode<system_calls.get_arguments_result>(SYSTEM_CALL_BUFFER, system_calls.get_arguments_result.decode, RETURN_BYTES[0]);\n\n    let ret = new getArgumentsReturn();\n\n    if ( result.value ) {\n      ret.entry_point = result.value!.entry_point;\n\n      if ( result.value!.arguments ) {\n        ret.args = result.value!.arguments!;\n      }\n    }\n\n    return ret;\n  }\n\n  /**\n    * Exit a contract\n    * @param exitCode 0 (success) or 1 (failed, will revert the transaction)\n    * @example\n    * ```ts\n    * System.exitContract(0);\n    * ```\n    */\n  export function exit(code: i32, value: Uint8Array | null = null): void {\n    let args = new system_calls.exit_arguments();\n    args.code = code;\n\n    if (value) {\n      if (code == error.error_code.success) {\n        args.res = new chain.result(value);\n      } else {\n        args.res = new chain.result(null, new chain.error_data(StringBytes.bytesToString(value)));\n      }\n    }\n\n    const encodedArgs = Protobuf.encode(args, system_calls.exit_arguments.encode);\n\n    env.invokeSystemCall(system_call_ids.system_call_id.exit, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n  }\n\n  /**\n   * Fail the transaction in progress\n   * @param message Optional failure message\n   * @param code Optional error code, must be < 0, else code -1 is used (failure exit code)\n   * ```ts\n   * if (!System.checkAuthority(authority.authorization_type.transaction_application, Base58.decode('1DQzuCcTKacbs9GGScRTU1Hc8BsyARTPqe)))\n   *   System.fail(\"contract is not authorized\");\n   * ```\n   */\n  export function fail(message: string = \"\", code: i32 = -1): void {\n    let args = new system_calls.exit_arguments();\n    args.res = new chain.result(null, new chain.error_data(message));\n    args.code = code < error.error_code.success ? code : error.error_code.failure;\n\n    const encodedArgs = Protobuf.encode(args, system_calls.exit_arguments.encode);\n\n    env.invokeSystemCall(system_call_ids.system_call_id.exit, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n  }\n\n  /**\n   * Revert the transaction in progress\n   * @param message Optional reversion message\n   * @param code Optional error code, must be > 0, else code 1 is used (reverted exit code)\n   * ```ts\n   * if (!System.checkAuthority(authority.authorization_type.transaction_application, Base58.decode('1DQzuCcTKacbs9GGScRTU1Hc8BsyARTPqe)))\n   *   System.revert(\"contract is not authorized\");\n   * ```\n   */\n  export function revert(message: string = \"\", code: i32 = 1): void {\n    let args = new system_calls.exit_arguments();\n    args.res = new chain.result(null, new chain.error_data(message));\n    args.code = code > error.error_code.success ? code : error.error_code.reversion;\n\n    const encodedArgs = Protobuf.encode(args, system_calls.exit_arguments.encode);\n\n    env.invokeSystemCall(system_call_ids.system_call_id.exit, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n  }\n\n  /**\n   * Gets a stored error message after a system call that can return an error.\n   * @returns string\n   * @example\n   * ```ts\n   * if (System.applyTransaction(trx) != error.error_code.success)\n   *   System.log(getErrorMessage())\n   * ```\n   */\n  export function getErrorMessage(): string {\n    return ERROR_MESSAGE;\n  }\n\n  /**\n    * Get the id of the contract\n    * @returns Uint8Array\n    * @example\n    * ```ts\n    * const contractId = System.getContractId();\n    * System.log('contractId (b58): ' + Base58.encode(contractId));\n    * ```\n    */\n  export function getContractId(): Uint8Array {\n    const args = new system_calls.get_contract_id_arguments();\n    const encodedArgs = Protobuf.encode(args, system_calls.get_contract_id_arguments.encode);\n\n    const retcode = env.invokeSystemCall(system_call_ids.system_call_id.get_contract_id, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n    checkErrorCode(retcode, SYSTEM_CALL_BUFFER.slice(0, RETURN_BYTES[0]));\n    const result = Protobuf.decode<system_calls.get_contract_id_result>(SYSTEM_CALL_BUFFER, system_calls.get_contract_id_result.decode, RETURN_BYTES[0]);\n\n    return result.value!;\n  }\n\n  /**\n    * Get the contract caller information\n    * @returns chain.caller_data\n    * @example\n    * ```ts\n    * const callerData = System.getCaller();\n    * System.log('callerData.caller_privilege: ' + callerData.caller_privilege.toString());\n    * if (callerData.caller) {\n    *   System.log('callerData.caller (b58): ' + Base58.encode(callerData.caller!));\n    * }\n    * ```\n    */\n  export function getCaller(): chain.caller_data {\n    const args = new system_calls.get_caller_arguments();\n    const encodedArgs = Protobuf.encode(args, system_calls.get_caller_arguments.encode);\n\n    const retcode = env.invokeSystemCall(system_call_ids.system_call_id.get_caller, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n    checkErrorCode(retcode, SYSTEM_CALL_BUFFER.slice(0, RETURN_BYTES[0]));\n    const result = Protobuf.decode<system_calls.get_caller_result>(SYSTEM_CALL_BUFFER, system_calls.get_caller_result.decode, RETURN_BYTES[0]);\n\n    return result.value!;\n  }\n\n  /**\n    * Check authority for an account\n    * @param type type of authority required\n    * @param account account to check\n    * @returns bool true if the account has authority\n    * @example\n    * ```ts\n    * System.checkAuthority(authority.authorization_type.transaction_application, Base58.decode('1DQzuCcTKacbs9GGScRTU1Hc8BsyARTPqe));\n    * ```\n    */\n  export function checkAuthority(type: authority.authorization_type, account: Uint8Array, data: Uint8Array | null = null ): bool {\n    const args = new system_calls.check_authority_arguments(type, account, data);\n    const encodedArgs = Protobuf.encode(args, system_calls.check_authority_arguments.encode);\n\n    const retcode = env.invokeSystemCall(system_call_ids.system_call_id.check_authority, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n    checkErrorCode(retcode, SYSTEM_CALL_BUFFER.slice(0, RETURN_BYTES[0]));\n    const result = Protobuf.decode<system_calls.check_authority_result>(SYSTEM_CALL_BUFFER, system_calls.check_authority_result.decode, RETURN_BYTES[0]);\n    return result.value;\n  }\n\n   /**\n    * Require authority for an account\n    * @param type type of authority required\n    * @param account account to check\n    * @throws revert the transaction if the account is not authorized\n    * @example\n    * ```ts\n    * System.requireAuthority(authority.authorization_type.transaction_application, Base58.decode('1DQzuCcTKacbs9GGScRTU1Hc8BsyARTPqe));\n    * ```\n    */\n  export function requireAuthority(type: authority.authorization_type, account: Uint8Array): void {\n    require(checkAuthority(type, account), \"account '\" + Base58.encode(account) + \"' authorization failed\", error.error_code.authorization_failure);\n  }\n\n  /**\n    * Require an expression to be true, log a message and exit the contract otherise\n    * @returns T it is Trueish, will exit the contract with `exitCode` otherwise\n    * @example\n    * ```ts\n    * System.require(1 + 1 == 11, `expected \"11\", got \"2\"`);\n    * ```\n    */\n  export function require<T>(isTrueish: T, message: string = \"\", code: i32 = 1): T {\n\n    if (!isTrueish) {\n      exit(code, StringBytes.stringToBytes(message));\n    }\n\n    return isTrueish;\n  }\n\n  // Database\n\n  /**\n    * Store bytes (Uint8Array)\n    * @param { chain.object_space } space space where to put the byets\n    * @param { string | Uint8Array } key key of the bytes to store (string or Uint8Array)\n    * @param { Uint8Array } obj bytes to store (Uint8Array)\n    * @returns number of bytes that were put in the database\n    * @example\n    * ```ts\n    * const contractId = System.getContractId();\n    * const contractSpace = new chain.object_space(false, contractId, 1);\n    *\n    * const nbBytesWritten = System.putBytes(contractSpace, 'testKey', StringBytes.stringToBytes('testValue'));\n    * System.log('nbBytesWritten: ' + nbBytesWritten.toString());\n    * ```\n   */\n  export function putBytes<K>(space: chain.object_space, key: K, obj: Uint8Array): void {\n    let finalKey: Uint8Array;\n    if (key instanceof Uint8Array) {\n      finalKey = key;\n    } else if (typeof key == \"string\") {\n      finalKey = StringBytes.stringToBytes(key);\n    } else {\n      exit(1, StringBytes.stringToBytes(\"An invalid key was passed to putBytes\"));\n    }\n\n    // @ts-ignore\n    const args = new system_calls.put_object_arguments(space, finalKey, obj);\n    const encodedArgs = Protobuf.encode(args, system_calls.put_object_arguments.encode);\n\n    const retcode = env.invokeSystemCall(system_call_ids.system_call_id.put_object, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n    checkErrorCode(retcode, SYSTEM_CALL_BUFFER.slice(0, RETURN_BYTES[0]));\n  }\n\n  /**\n    * Store proto object\n    * @param { chain.object_space } space space where to put the object\n    * @param { string | Uint8Array } key key of the object to store (string or Uint8Array)\n    * @param { TMessage } obj object to store (string or Uint8Array)\n    * @returns number of bytes that were put in the database\n    * @example\n    * ```ts\n    * const contractId = System.getContractId();\n    * const contractSpace = new chain.object_space(false, contractId, 1);\n    * const obj = new test.test_object(42);\n    *\n    * const nbBytesWritten = System.putObject(contractSpace, \"test\", obj, test.test_object.encode);\n    * System.log('nbBytesWritten: ' + nbBytesWritten.toString());\n    * ```\n   */\n  export function putObject<K, TMessage>(\n    space: chain.object_space,\n    key: K,\n    obj: TMessage,\n    encoder: (message: TMessage, writer: Writer) => void\n  ): void {\n    let finalObj = Protobuf.encode<TMessage>(obj, encoder);\n\n    putBytes(space, key, finalObj);\n  }\n\n  /**\n    * Remove an object\n    * @param { chain.object_space } space space where to put the byets\n    * @param { string | Uint8Array } key key of the bytes to store (string or Uint8Array)\n    * @example\n    * ```ts\n    * const contractId = System.getContractId();\n    * const contractSpace = new chain.object_space(false, contractId, 1);\n    *\n    * System.removeObject(contractSpace, 'testKey');\n    * ```\n    */\n  export function removeObject<K>(space: chain.object_space, key: K): void {\n    let finalKey: Uint8Array;\n    if (key instanceof Uint8Array) {\n      finalKey = key;\n    } else if (typeof key == \"string\") {\n      finalKey = StringBytes.stringToBytes(key);\n    } else {\n      exit(1, StringBytes.stringToBytes(\"An invalid key was passed to removeObject\"));\n    }\n\n    // @ts-ignore\n    const args = new system_calls.remove_object_arguments(space, finalKey);\n    const encodedArgs = Protobuf.encode(args, system_calls.remove_object_arguments.encode);\n\n    const retcode = env.invokeSystemCall(system_call_ids.system_call_id.remove_object, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n    checkErrorCode(retcode, SYSTEM_CALL_BUFFER.slice(0, RETURN_BYTES[0]));\n  }\n\n  /**\n    * Get bytes (Uint8Array)\n    * @param { chain.object_space } space space where to get the object\n    * @param { string | Uint8Array } key key of object to get\n    * @returns Uint8Array | null\n    * @example\n    * ```ts\n    * const contractId = System.getContractId();\n    * const contractSpace = new chain.object_space(false, contractId, 1);\n    * let obj = System.getBytes(contractSpace, StringBytes.stringToBytes('key2'));\n    *\n    * if (obj) {\n    *   const str = StringBytes.bytesToString(obj)!;\n    *   System.log(str);\n    * }\n    * ```\n   */\n  export function getBytes<K>(\n    space: chain.object_space,\n    key: K\n  ): Uint8Array | null {\n    let finalKey: Uint8Array;\n    if (key instanceof Uint8Array) {\n      finalKey = key;\n    } else if (typeof key == 'string') {\n      finalKey = StringBytes.stringToBytes(key);\n    } else {\n      exit(1, StringBytes.stringToBytes(\"An invalid key was passed to getBytes\"));\n    }\n\n    // @ts-ignore\n    const args = new system_calls.get_object_arguments(space, finalKey);\n    const encodedArgs = Protobuf.encode(args, system_calls.get_object_arguments.encode);\n\n    const retcode = env.invokeSystemCall(system_call_ids.system_call_id.get_object, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n    checkErrorCode(retcode, SYSTEM_CALL_BUFFER.slice(0, RETURN_BYTES[0]));\n\n    if (!RETURN_BYTES[0]) {\n      return null;\n    }\n\n    const result = Protobuf.decode<system_calls.get_object_result>(SYSTEM_CALL_BUFFER, system_calls.get_object_result.decode, RETURN_BYTES[0]);\n\n    return (result.value!).value;\n  }\n\n  /**\n    * Get proto object\n    * @param { chain.object_space } space space where to get the object\n    * @param { string | Uint8Array } key key of object to get\n    * @returns proto object (TMessage) or null\n    * @example\n    * ```ts\n    * const contractId = System.getContractId();\n    * const contractSpace = new chain.object_space(false, contractId, 1);\n    * let obj = System.getObject<string, test.test_object>(contractSpace, 'key2', test.test_object.decode);\n    *\n    * if (obj) {\n    *   System.log('obj.value: ' + obj.value.toString());\n    * }\n    * ```\n   */\n  export function getObject<K, TMessage>(\n    space: chain.object_space,\n    key: K,\n    decoder: (reader: Reader, length: i32) => TMessage\n  ): TMessage | null {\n\n    const value = getBytes(space, key);\n\n    if (!value) {\n      return null;\n    }\n\n    return Protobuf.decode<TMessage>(value, decoder);\n  }\n\n  export class ProtoDatabaseObject<TMessage> {\n    value: TMessage;\n    key: Uint8Array | null;\n\n    constructor(obj: system_calls.database_object, decoder: (reader: Reader, length: i32) => TMessage) {\n      this.key = obj.key;\n      this.value = Protobuf.decode<TMessage>(obj.value!, decoder);\n    }\n  }\n\n  /**\n    * Get next bytes (Uint8Array)\n    * @param { string | Uint8Array } key key of object\n    * @returns system_calls.database_object\n    * @example\n    * ```ts\n    * const contractId = System.getContractId();\n    * const contractSpace = new chain.object_space(false, contractId, 1);\n    * let obj = System.getNextBytes(contractSpace, StringBytes.stringToBytes('key2'));\n    *\n    * if (obj) {\n    *   System.log('obj.value: ' + obj.value.toString());\n    * }\n    * ```\n   */\n  export function getNextBytes<K>(\n    space: chain.object_space,\n    key: K\n  ): system_calls.database_object | null {\n    let finalKey: Uint8Array;\n    if (key instanceof Uint8Array) {\n      finalKey = key;\n    } else if (typeof key == 'string') {\n      finalKey = StringBytes.stringToBytes(key);\n    } else {\n      exit(1, StringBytes.stringToBytes(\"An invalid key was passed to getNextBytes\"));\n    }\n\n    // @ts-ignore\n    const args = new system_calls.get_next_object_arguments(space, finalKey);\n    const encodedArgs = Protobuf.encode(args, system_calls.get_next_object_arguments.encode);\n\n    const retcode = env.invokeSystemCall(system_call_ids.system_call_id.get_next_object, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n    checkErrorCode(retcode, SYSTEM_CALL_BUFFER.slice(0, RETURN_BYTES[0]));\n\n    if (retcode) {\n      return null;\n    }\n\n    const result = Protobuf.decode<system_calls.get_next_object_result>(SYSTEM_CALL_BUFFER, system_calls.get_next_object_result.decode, RETURN_BYTES[0]);\n    return result.value;\n  }\n\n\n  /**\n    * Get next proto object\n    * @param { string | Uint8Array } key key of object\n    * @returns proto object (TMessage)\n    * @example\n    * ```ts\n    * const contractId = System.getContractId();\n    * const contractSpace = new chain.object_space(false, contractId, 1);\n    * let obj = System.getNextObject<string, test.test_object>(contractSpace, 'key3', test.test_object.decode);\n    *\n    * if (obj) {\n    *   System.log('next obj.value: ' + obj.value.value.toString());\n    * }\n    * ```\n    */\n  export function getNextObject<K, TMessage>(\n    space: chain.object_space,\n    key: K,\n    decoder: (reader: Reader, length: i32) => TMessage\n  ): ProtoDatabaseObject<TMessage> | null {\n\n    const value = getNextBytes(space, key);\n\n    if (!value) {\n      return null;\n    }\n\n    return new ProtoDatabaseObject(value, decoder);\n  }\n\n  /**\n   * Get next bytes (Uint8Array)\n   * @param { string | Uint8Array } key key of object\n   * @returns system_calls.database_object\n   * @example\n    * ```ts\n    * const contractId = System.getContractId();\n    * const contractSpace = new chain.object_space(false, contractId, 1);\n    * let obj = System.getPrevBytes(contractSpace, StringBytes.stringToBytes('key2'));\n    *\n    * if (obj) {\n    *   System.log('obj.value: ' + obj.value.toString());\n    * }\n    * ```\n   */\n  export function getPrevBytes<K>(\n    space: chain.object_space,\n    key: K\n  ): system_calls.database_object | null {\n    let finalKey: Uint8Array;\n    if (key instanceof Uint8Array) {\n      finalKey = key;\n    } else if (typeof key == 'string') {\n      finalKey = StringBytes.stringToBytes(key);\n    } else {\n      exit(1, StringBytes.stringToBytes(\"An invalid key was passed to getPrevBytes\"));\n    }\n\n    // @ts-ignore\n    const args = new system_calls.get_prev_object_arguments(space, finalKey);\n    const encodedArgs = Protobuf.encode(args, system_calls.get_prev_object_arguments.encode);\n\n    const retcode = env.invokeSystemCall(system_call_ids.system_call_id.get_prev_object, SYSTEM_CALL_BUFFER.dataStart as u32, MAX_BUFFER_SIZE, encodedArgs.dataStart as u32, encodedArgs.byteLength, RETURN_BYTES.dataStart as u32);\n    checkErrorCode(retcode, SYSTEM_CALL_BUFFER.slice(0, RETURN_BYTES[0]));\n\n    if (retcode) {\n      return null;\n    }\n\n    const result = Protobuf.decode<system_calls.get_prev_object_result>(SYSTEM_CALL_BUFFER, system_calls.get_prev_object_result.decode, RETURN_BYTES[0]);\n    return result.value;\n  }\n\n  /**\n   * Get previous proto object\n   * @param { string | Uint8Array } key key of object\n   * @returns proto object (TMessage)\n   * @example\n    * ```ts\n    * const contractId = System.getContractId();\n    * const contractSpace = new chain.object_space(false, contractId, 1);\n    * let obj = System.getPrevObject<string, test.test_object>(contractSpace, 'key3', test.test_object.decode);\n    *\n    * if (obj) {\n    *   System.log('next obj.value: ' + obj.value.value.toString());\n    * }\n    * ```\n   */\n  export function getPrevObject<K, TMessage>(\n    space: chain.object_space,\n    key: K,\n    decoder: (reader: Reader, length: i32) => TMessage\n  ): ProtoDatabaseObject<TMessage> | null {\n\n    const value = getPrevBytes(space, key);\n\n    if (!value) {\n      return null;\n    }\n\n    return new ProtoDatabaseObject(value, decoder);\n  }\n}\n","import { Writer, Reader } from \"as-proto\";\n\nexport namespace calculator {\n  @unmanaged\n  export class add_arguments {\n    static encode(message: add_arguments, writer: Writer): void {\n      if (message.x != 0) {\n        writer.uint32(8);\n        writer.int64(message.x);\n      }\n\n      if (message.y != 0) {\n        writer.uint32(16);\n        writer.int64(message.y);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): add_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new add_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.x = reader.int64();\n            break;\n\n          case 2:\n            message.y = reader.int64();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    x: i64;\n    y: i64;\n\n    constructor(x: i64 = 0, y: i64 = 0) {\n      this.x = x;\n      this.y = y;\n    }\n  }\n\n  @unmanaged\n  export class add_result {\n    static encode(message: add_result, writer: Writer): void {\n      if (message.value != 0) {\n        writer.uint32(8);\n        writer.int64(message.value);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): add_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new add_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.value = reader.int64();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    value: i64;\n\n    constructor(value: i64 = 0) {\n      this.value = value;\n    }\n  }\n\n  @unmanaged\n  export class sub_arguments {\n    static encode(message: sub_arguments, writer: Writer): void {\n      if (message.x != 0) {\n        writer.uint32(8);\n        writer.int64(message.x);\n      }\n\n      if (message.y != 0) {\n        writer.uint32(16);\n        writer.int64(message.y);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): sub_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new sub_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.x = reader.int64();\n            break;\n\n          case 2:\n            message.y = reader.int64();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    x: i64;\n    y: i64;\n\n    constructor(x: i64 = 0, y: i64 = 0) {\n      this.x = x;\n      this.y = y;\n    }\n  }\n\n  @unmanaged\n  export class sub_result {\n    static encode(message: sub_result, writer: Writer): void {\n      if (message.value != 0) {\n        writer.uint32(8);\n        writer.int64(message.value);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): sub_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new sub_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.value = reader.int64();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    value: i64;\n\n    constructor(value: i64 = 0) {\n      this.value = value;\n    }\n  }\n\n  @unmanaged\n  export class mul_arguments {\n    static encode(message: mul_arguments, writer: Writer): void {\n      if (message.x != 0) {\n        writer.uint32(8);\n        writer.int64(message.x);\n      }\n\n      if (message.y != 0) {\n        writer.uint32(16);\n        writer.int64(message.y);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): mul_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new mul_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.x = reader.int64();\n            break;\n\n          case 2:\n            message.y = reader.int64();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    x: i64;\n    y: i64;\n\n    constructor(x: i64 = 0, y: i64 = 0) {\n      this.x = x;\n      this.y = y;\n    }\n  }\n\n  @unmanaged\n  export class mul_result {\n    static encode(message: mul_result, writer: Writer): void {\n      if (message.value != 0) {\n        writer.uint32(8);\n        writer.int64(message.value);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): mul_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new mul_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.value = reader.int64();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    value: i64;\n\n    constructor(value: i64 = 0) {\n      this.value = value;\n    }\n  }\n\n  @unmanaged\n  export class div_arguments {\n    static encode(message: div_arguments, writer: Writer): void {\n      if (message.x != 0) {\n        writer.uint32(8);\n        writer.int64(message.x);\n      }\n\n      if (message.y != 0) {\n        writer.uint32(16);\n        writer.int64(message.y);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): div_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new div_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.x = reader.int64();\n            break;\n\n          case 2:\n            message.y = reader.int64();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    x: i64;\n    y: i64;\n\n    constructor(x: i64 = 0, y: i64 = 0) {\n      this.x = x;\n      this.y = y;\n    }\n  }\n\n  @unmanaged\n  export class div_result {\n    static encode(message: div_result, writer: Writer): void {\n      if (message.value != 0) {\n        writer.uint32(8);\n        writer.int64(message.value);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): div_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new div_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.value = reader.int64();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    value: i64;\n\n    constructor(value: i64 = 0) {\n      this.value = value;\n    }\n  }\n}\n","import { System } from \"../systemCalls\";\nimport { u128 } from \"as-bignum\";\n\nexport namespace SafeMath {\n\n  export class SafeInteger<T> {\n    value: T;\n    error: bool;\n    constructor(value: T, error: bool) {\n      this.value = value;\n      this.error = error;\n    }\n  }\n\n  /**\n    * Try to add 2 integers (unsigned or signed)\n    * @param { T } a unsigned or signed integer\n    * @param { T } b unsigned or signed integer\n    * @returns SafeInteger\n    * @example\n    * ```ts\n    * const res = SafeMath.tryAdd(1, 2);\n    *\n    * if (!res.error) {\n    *   System.Log('1 + 2 = ' + c.value.toString());\n    * } else {\n    *   System.log('could not add');\n    * }\n    * ```\n    */\n  export function tryAdd<T>(a: T, b: T): SafeInteger<T> {\n    if (isInteger<T>()) {\n      // @ts-ignore valid in AS\n      const c = a + b;\n\n      if (isSigned<T>()) {\n        // signed integers\n        // @ts-ignore valid in AS\n        if ((b >= 0 && c >= a) || (b < 0 && c < a)) {\n          return new SafeInteger<T>(c, false);\n        }\n      } else {\n        // unsigned integers\n        if (c >= a) {\n          return new SafeInteger<T>(c, false);\n        }\n      }\n    } else if (a instanceof u128) {\n      // @ts-ignore valid in AS\n      const c = a + b;\n\n      if (c >= a) {\n        return new SafeInteger(c, false);\n      }\n\n      // @ts-ignore valid in AS\n      return new SafeInteger(u128.Zero, true);\n    }\n\n    // @ts-ignore valid in AS\n    return new SafeInteger<T>(0, true);\n  }\n\n  /**\n    * Add 2 integers (unsigned or signed)\n    * @param { T } a unsigned or signed integer\n    * @param { T } b unsigned or signed integer\n    * @param { string } message message that will be logged if the calculation reverts\n    * @returns reverts if overflow/underflow, result otherwise\n    * @example\n    * ```ts\n    * const res = SafeMath.add(1, 2);\n    *\n    * // code here is not executed if the calculation above overflows/underflows\n    * ```\n    */\n  export function add<T>(a: T, b: T, message: string = ''): T {\n    const result = tryAdd(a, b);\n\n    if (result.error) {\n      if (isInteger<T>()) {\n        // @ts-ignore valid in AS\n        message = message != '' ? message : `could not add ${a.toString()} to ${b.toString()}`;\n      } else {\n        message = message != '' ? message : 'could not add';\n      }\n      System.revert(message);\n    }\n\n    return result.value;\n  }\n\n  /**\n    * Try to subtract 2 integers (unsigned or signed)\n    * @param { T } a unsigned or signed integer\n    * @param { T } b unsigned or signed integer\n    * @returns SafeInteger\n    * @example\n    * ```ts\n    * const res = SafeMath.trySub(2, 1);\n    *\n    * if (!res.error) {\n    *   System.Log('2 - 1 = ' + c.value.toString());\n    * } else {\n    *   System.log('could not subtract');\n    * }\n    * ```\n    */\n  export function trySub<T>(a: T, b: T): SafeInteger<T> {\n    if (isInteger<T>()) {\n      if (isSigned<T>()) {\n        // signed integers\n        // @ts-ignore valid in AS\n        const c = a - b;\n        // @ts-ignore valid in AS\n        if ((b >= 0 && c <= a) || (b < 0 && c > a)) {\n          // @ts-ignore valid in AS\n          return new SafeInteger<T>(c, false);\n        }\n      } else {\n        // unsigned integers\n        if (b <= a) {\n          // @ts-ignore valid in AS\n          return new SafeInteger<T>(a - b, false);\n        }\n      }\n    } else if (a instanceof u128) {\n      if (b <= a) {\n        // @ts-ignore valid in AS\n        return new SafeInteger(a - b, false);\n      }\n\n      // @ts-ignore valid in AS\n      return new SafeInteger(u128.Zero, true);\n    }\n\n    // @ts-ignore valid in AS\n    return new SafeInteger<T>(0, true);\n  }\n\n  /**\n    * Subtract 2 integers (unsigned or signed)\n    * @param { T } a unsigned or signed integer\n    * @param { T } b unsigned or signed integer\n    * @param { string } message message that will be logged if the calculation reverts\n    * @returns reverts if overflow/underflow, result otherwise\n    * @example\n    * ```ts\n    * const res = SafeMath.sub(1, 2);\n    *\n    * // code here is not executed if the calculation above overflows/underflows\n    * ```\n    */\n  export function sub<T>(a: T, b: T, message: string = ''): T {\n    const result = trySub(a, b);\n\n    if (result.error) {\n      if (isInteger<T>()) {\n        // @ts-ignore valid in AS\n        message = message != '' ? message : `could not subtract ${b.toString()} from ${a.toString()}`;\n      } else {\n        message = message != '' ? message : 'could not subtract';\n      }\n      System.revert(message);\n    }\n\n    return result.value;\n  }\n\n  /**\n    * Try to multiply 2 integers (unsigned or signed)\n    * @param { T } a unsigned or signed integer\n    * @param { T } b unsigned or signed integer\n    * @returns SafeInteger\n    * @example\n    * ```ts\n    * const res = SafeMath.tryMul(2, 1);\n    *\n    * if (!res.error) {\n    *   System.Log('2 * 1 = ' + c.value.toString());\n    * } else {\n    *   System.log('could not multiply');\n    * }\n    * ```\n    */\n  export function tryMul<T>(a: T, b: T): SafeInteger<T> {\n    if (isInteger<T>()) {\n      // @ts-ignore valid in AS\n      if (a == 0) {\n        // @ts-ignore valid in AS\n        return new SafeInteger<T>(0, false);\n      }\n\n      // @ts-ignore valid in AS\n      if (isSigned<T>() && a == -1) {\n        if (\n          // @ts-ignore valid in AS\n          (b instanceof i64 && b == i64.MIN_VALUE) ||\n          // @ts-ignore valid in AS\n          (b instanceof i32 && b == i32.MIN_VALUE) ||\n          // @ts-ignore valid in AS\n          (b instanceof i16 && b == i16.MIN_VALUE) ||\n          // @ts-ignore valid in AS\n          (b instanceof i8 && b == i8.MIN_VALUE)\n        ) {\n          // @ts-ignore valid in AS\n          return new SafeInteger<T>(0, true);\n        }\n      }\n\n      // @ts-ignore valid in AS\n      const c = a * b;\n      // @ts-ignore valid in AS\n      if (c / a == b) {\n        // @ts-ignore valid in AS\n        return new SafeInteger<T>(c, false);\n      }\n    } else if (a instanceof u128) {\n      // @ts-ignore valid in AS\n      if (a == u128.Zero) {\n        // @ts-ignore valid in AS\n        return new SafeInteger(u128.Zero, false);\n      }\n\n      // @ts-ignore valid in AS\n      const c = a * b;\n      // @ts-ignore valid in AS\n      if (c / a == b) {\n        // @ts-ignore valid in AS\n        return new SafeInteger(c, false);\n      }\n\n      // @ts-ignore valid in AS\n      return new SafeInteger(u128.Zero, true);\n    }\n\n    // @ts-ignore valid in AS\n    return new SafeInteger<T>(0, true);\n  }\n\n  /**\n    * Multiply 2  integers (unsigned or signed)\n    * @param { T } a unsigned or signed integer\n    * @param { T } b unsigned or signed integer\n    * @param { string } message message that will be logged if the calculation reverts\n    * @returns reverts if overflow/underflow, result otherwise\n    * @example\n    * ```ts\n    * const res = SafeMath.mul(1, 2);\n    *\n    * // code here is not executed if the calculation above overflows/underflows\n    * ```\n    */\n  export function mul<T>(a: T, b: T, message: string = ''): T {\n    const result = tryMul(a, b);\n\n    if (result.error) {\n      if (isInteger<T>()) {\n        // @ts-ignore valid in AS\n        message = message != '' ? message : `could not multiply ${a.toString()} by ${b.toString()}`;\n      } else {\n        message = message != '' ? message : 'could not multiply';\n      }\n      System.revert(message);\n    }\n\n    return result.value;\n  }\n\n  /**\n    * Try to divide 2 integers (unsigned or signed)\n    * @param { T } a unsigned or signed integer\n    * @param { T } b unsigned or signed integer\n    * @returns SafeInteger\n    * @example\n    * ```ts\n    * const res = SafeMath.tryDiv(2, 1);\n    *\n    * if (!res.error) {\n    *   System.Log('2 / 1 = ' + c.value.toString());\n    * } else {\n    *   System.log('could not divide');\n    * }\n    * ```\n    */\n  export function tryDiv<T>(a: T, b: T): SafeInteger<T> {\n    if (isInteger<T>()) {\n      // @ts-ignore valid in AS\n      if (isSigned<T>() && b == -1) {\n        if (\n          // @ts-ignore valid in AS\n          (a instanceof i64 && a == i64.MIN_VALUE) ||\n          // @ts-ignore valid in AS\n          (a instanceof i32 && a == i32.MIN_VALUE) ||\n          // @ts-ignore valid in AS\n          (a instanceof i16 && a == i16.MIN_VALUE) ||\n          // @ts-ignore valid in AS\n          (a instanceof i8 && a == i8.MIN_VALUE)\n        ) {\n          // @ts-ignore valid in AS\n          return new SafeInteger<T>(0, true);\n        }\n      }\n\n      // @ts-ignore valid in AS\n      if (b != 0) {\n        // @ts-ignore valid in AS\n        return new SafeInteger<T>(a / b, false);\n      }\n    } else if (a instanceof u128) {\n      // @ts-ignore valid in AS\n      if (b != u128.Zero) {\n        // @ts-ignore valid in AS\n        return new SafeInteger(a / b, false);\n      }\n\n      // @ts-ignore valid in AS\n      return new SafeInteger(u128.Zero, true);\n    }\n\n    // @ts-ignore valid in AS\n    return new SafeInteger<T>(0, true);\n  }\n\n  /**\n    * Divide 2 integers (unsigned or signed)\n    * @param { T } a unsigned or signed integer\n    * @param { T } b unsigned or signed integer\n    * @param { string } message message that will be logged if the calculation reverts\n    * @returns reverts if overflow/underflow, result otherwise\n    * @example\n    * ```ts\n    * const res = SafeMath.div(1, 2);\n    *\n    * // code here is not executed if the calculation above overflows/underflows\n    * ```\n    */\n  export function div<T>(a: T, b: T, message: string = ''): T {\n    const result = tryDiv(a, b);\n\n    if (result.error) {\n      if (isInteger<T>()) {\n        // @ts-ignore valid in AS\n        message = message != '' ? message : `could not divide ${a.toString()} by ${b.toString()}`;\n      } else {\n        message = message != '' ? message : 'could not divide';\n      }\n      System.revert(message);\n    }\n\n    return result.value;\n  }\n\n  /**\n    * Try to calculate the modulo of 2 integers (unsigned or signed)\n    * @param { T } a unsigned or signed integer\n    * @param { T } b unsigned or signed integer\n    * @returns SafeInteger\n    * @example\n    * ```ts\n    * const res = SafeMath.tryMod(2, 1);\n    *\n    * if (!res.error) {\n    *   System.Log('2 % 1 = ' + c.value.toString());\n    * } else {\n    *   System.log('could not calculate modulo');\n    * }\n    * ```\n    */\n  export function tryMod<T>(a: T, b: T): SafeInteger<T> {\n    if (isInteger<T>()) {\n      // @ts-ignore valid in AS\n      if (isSigned<T>() && b == -1) {\n        if (\n          // @ts-ignore valid in AS\n          (a instanceof i64 && a == i64.MIN_VALUE) ||\n          // @ts-ignore valid in AS\n          (a instanceof i32 && a == i32.MIN_VALUE) ||\n          // @ts-ignore valid in AS\n          (a instanceof i16 && a == i16.MIN_VALUE) ||\n          // @ts-ignore valid in AS\n          (a instanceof i8 && a == i8.MIN_VALUE)\n        ) {\n          // @ts-ignore valid in AS\n          return new SafeInteger<T>(0, true);\n        }\n      }\n\n      // @ts-ignore valid in AS\n      if (b != 0) {\n        // @ts-ignore valid in AS\n        return new SafeInteger<T>(a % b, false);\n      }\n    } else if (a instanceof u128) {\n      // @ts-ignore valid in AS\n      if (b != u128.Zero) {\n        // @ts-ignore valid in AS\n        return new SafeInteger(a % b, false);\n      }\n\n      // @ts-ignore valid in AS\n      return new SafeInteger(u128.Zero, true);\n    }\n\n    // @ts-ignore valid in AS\n    return new SafeInteger<T>(0, true);\n  }\n\n  /**\n    * Calculate the modulo of 2 integers (unsigned or signed)\n    * @param { T } a unsigned or signed integer\n    * @param { T } b unsigned or signed integer\n    * @param { string } message message that will be logged if the calculation reverts\n    * @returns reverts if overflow/underflow, result otherwise\n    * @example\n    * ```ts\n    * const res = SafeMath.mod(10, 2);\n    *\n    * // code here is not executed if the calculation above overflows/underflows\n    * ```\n    */\n  export function mod<T>(a: T, b: T, message: string = ''): T {\n    const result = tryMod(a, b);\n\n    if (result.error) {\n      if (isInteger<T>()) {\n        // @ts-ignore valid in AS\n        message = message != '' ? message : `could not calulate ${a.toString()} modulo ${b.toString()}`;\n      } else {\n        message =message != '' ? message : 'could not calulate modulo';\n      }\n      System.revert(message);\n    }\n\n    return result.value;\n  }\n}\n","import { itoa32, utoa32, itoa64, utoa64, dtoa } from \"./util/number\";\nimport { strtol } from \"./util/string\";\n\n// @ts-ignore: decorator\n@builtin @inline\nexport const NaN: f64 = 0 / 0;\n\n// @ts-ignore: decorator\n@builtin @inline\nexport const Infinity: f64 = 1 / 0;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isNaN<T extends number>(value: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFinite<T extends number>(value: T): bool;\n\n@final @unmanaged\nexport abstract class I8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i8 = i8.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i8 = i8.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i8 {\n    return <i8>strtol<i32>(value, radix);\n  }\n\n  toString(this: i8, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i16 = i16.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i16 = i16.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i16 {\n    return <i16>strtol<i32>(value, radix);\n  }\n\n  toString(this: i16, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i32 = i32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i32 = i32.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i32 {\n    return <i32>strtol<i32>(value, radix);\n  }\n\n  toString(this: i32, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i64 = i64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i64 = i64.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i64 {\n    return strtol<i64>(value, radix);\n  }\n\n  toString(this: i64, radix: i32 = 10): String {\n    return itoa64(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class Isize {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: isize = isize.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: isize = isize.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): isize {\n    return <isize>strtol<i64>(value, radix);\n  }\n\n  toString(this: isize, radix: i32 = 10): String {\n    if (sizeof<isize>() == 4) {\n      return itoa32(<i32>this, radix);\n    } else {\n      return itoa64(<i64>this, radix);\n    }\n  }\n}\n\n@final @unmanaged\nexport abstract class U8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u8 = u8.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u8 = u8.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u8 {\n    return <u8>strtol<i32>(value, radix);\n  }\n\n  toString(this: u8, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u16 = u16.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u16 = u16.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u16 {\n    return <u16>strtol<i32>(value, radix);\n  }\n\n  toString(this: u16, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u32 = u32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u32 = u32.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u32 {\n    return <u32>strtol<i32>(value, radix);\n  }\n\n  toString(this: u32, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u64 = u64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u64 = u64.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u64 {\n    return <u64>strtol<i64>(value, radix);\n  }\n\n  toString(this: u64, radix: i32 = 10): String {\n    return utoa64(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class Usize {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: usize = usize.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: usize = usize.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): usize {\n    return <usize>strtol<i64>(value, radix);\n  }\n\n  toString(this: usize, radix: i32 = 10): String {\n    if (sizeof<usize>() == 4) {\n      return utoa32(<u32>this, radix);\n    } else {\n      return utoa64(<u64>this, radix);\n    }\n  }\n}\n\n@final @unmanaged\nexport abstract class Bool {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: bool = bool.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: bool = bool.MAX_VALUE;\n\n  toString(this: bool, radix: i32 = 0): String {\n    return this ? \"true\" : \"false\";\n  }\n}\n\nexport { Bool as Boolean };\n\n@final @unmanaged\nexport abstract class F32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly EPSILON: f32 = f32.EPSILON;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: f32 = f32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: f32 = f32.MAX_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_SAFE_INTEGER: f32 = f32.MIN_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_SAFE_INTEGER: f32 = f32.MAX_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly POSITIVE_INFINITY: f32 = f32.POSITIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NEGATIVE_INFINITY: f32 = f32.NEGATIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NaN: f32 = f32.NaN;\n\n  static isNaN(value: f32): bool {\n    return isNaN<f32>(value);\n  }\n\n  static isFinite(value: f32): bool {\n    return isFinite<f32>(value);\n  }\n\n  static isSafeInteger(value: f32): bool {\n    return abs<f32>(value) <= f32.MAX_SAFE_INTEGER && trunc<f32>(value) == value;\n  }\n\n  static isInteger(value: f32): bool {\n    return isFinite<f32>(value) && trunc<f32>(value) == value;\n  }\n\n  static parseInt(value: string, radix: i32 = 0): f32 {\n    return <f32>strtol<f64>(value, radix);\n  }\n\n  static parseFloat(value: string): f32 {\n    return <f32>parseFloat(value);\n  }\n\n  toString(this: f32, radix: i32 = 0): String {\n    return dtoa(this);\n  }\n}\n\n@final @unmanaged\nexport abstract class F64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly EPSILON: f64 = f64.EPSILON;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: f64 = f64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: f64 = f64.MAX_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_SAFE_INTEGER: f64 = f64.MIN_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_SAFE_INTEGER: f64 = f64.MAX_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly POSITIVE_INFINITY: f64 = f64.POSITIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NEGATIVE_INFINITY: f64 = f64.NEGATIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NaN: f64 = f64.NaN;\n\n  static isNaN(value: f64): bool {\n    return isNaN<f64>(value);\n  }\n\n  static isFinite(value: f64): bool {\n    return isFinite<f64>(value);\n  }\n\n  static isSafeInteger(value: f64): bool {\n    return abs<f64>(value) <= f64.MAX_SAFE_INTEGER && trunc<f64>(value) == value;\n  }\n\n  static isInteger(value: f64): bool {\n    return isFinite<f64>(value) && trunc<f64>(value) == value;\n  }\n\n  static parseInt(value: string, radix: i32 = 0): f64 {\n    return strtol<f64>(value, radix);\n  }\n\n  static parseFloat(value: string): f64 {\n    return parseFloat(value);\n  }\n\n  toString(this: f64, radix: i32 = 0): String {\n    return dtoa(this);\n  }\n}\n\nexport { F64 as Number };\n","type auto = i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isInteger<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFloat<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isBoolean<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isSigned<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isReference<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isString<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isArray<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isArrayLike<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFunction<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isNullable<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isDefined(expression: auto): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isConstant(expression: auto): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isManaged<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isVoid<T>(): bool;\n\n// @ts-ignore\n@builtin\nexport declare function lengthof<T>(func?: T): i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function clz<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ctz<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function popcnt<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rotl<T>(value: T, shift: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rotr<T>(value: T, shift: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function abs<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function max<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function min<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ceil<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function floor<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function copysign<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function nearest<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function reinterpret<T>(value: number): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sqrt<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function trunc<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function add<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sub<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function mul<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function div<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function load<T>(ptr: usize, immOffset?: usize, immAlign?: usize): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function store<T>(ptr: usize, value: auto, immOffset?: usize, immAlign?: usize): void;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sizeof<T>(): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function alignof<T>(): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function offsetof<T>(fieldName?: string): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function idof<T>(): u32;\n\n// @ts-ignore\n@builtin\nexport declare function nameof<T>(): string;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function unreachable(): auto;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function changetype<T>(value: auto): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function assert<T>(isTrueish: T, message?: string): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function unchecked<T>(expr: T): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function call_indirect<T>(index: u32, ...args: auto[]): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function instantiate<T>(...args: auto[]): T;\n\nexport namespace atomic {\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load<T>(ptr: usize, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store<T>(ptr: usize, value: T, immOffset?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function and<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function or<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function xor<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function xchg<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function cmpxchg<T>(ptr: usize, expected: T, replacement: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function wait<T>(ptr: usize, expected: T, timeout: i64): AtomicWaitResult;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function notify(ptr: usize, count: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function fence(): void;\n}\n\n// @ts-ignore: decorator\n@lazy\nexport const enum AtomicWaitResult {\n  OK = 0,\n  NOT_EQUAL = 1,\n  TIMED_OUT = 2\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i8(value: auto): i8;\n\nexport namespace i8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i8 = -128;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i8 =  127;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i16(value: auto): i16;\n\nexport namespace i16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i16 = -32768;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i16 =  32767;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i32(value: auto): i32;\n\nexport namespace i32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i32 = -2147483648;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i32 =  2147483647;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function clz(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ctz(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_s(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_u(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotl(value: i32, shift: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotr(value: i32, shift: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_f32(value: f32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load8_u(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load16_u(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store8(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store16(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function wait(ptr: usize, expected: i32, timeout: i64): AtomicWaitResult;\n\n    export namespace rmw8 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n\n    export namespace rmw16 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n\n    export namespace rmw {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i64(value: auto): i64;\n\nexport namespace i64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i64 = -9223372036854775808;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i64 =  9223372036854775807;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function clz(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ctz(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_s(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_u(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotl(value: i64, shift: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotr(value: i64, shift: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_f64(value: f64): i64;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store32(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load8_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load16_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load32_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store8(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store16(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store32(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function wait(ptr: usize, expected: i64, timeout: i64): AtomicWaitResult;\n\n    export namespace rmw8 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw16 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw32 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isize(value: auto): isize;\n\nexport namespace isize {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? -2147483648\n    : <isize>-9223372036854775808;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? 2147483647\n    : <isize>9223372036854775807;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u8(value: auto): u8;\n\nexport namespace u8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u8 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u8 = 255;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u16(value: auto): u16;\n\nexport namespace u16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u16 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u16 = 65535;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u32(value: auto): u32;\n\nexport namespace u32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u32 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u32 = 4294967295;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u64(value: auto): u64;\n\nexport namespace u64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u64 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u64 = 18446744073709551615;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function usize(value: auto): usize;\n\nexport namespace usize {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: usize = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: usize = sizeof<u32>() == sizeof<usize>()\n    ? 4294967295\n    : <usize>18446744073709551615;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function bool(value: auto): bool;\n\nexport namespace bool {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: bool = false;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: bool = true;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f32(value: auto): f32;\n\nexport namespace f32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const EPSILON = reinterpret<f32>(0x34000000); // 0x1p-23f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE = reinterpret<f32>(0x00000001); // 0x0.000001p+0f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE = reinterpret<f32>(0x7F7FFFFF); // 0x1.fffffep+127f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_NORMAL_VALUE = reinterpret<f32>(0x00800000); // 0x1p-126f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_SAFE_INTEGER: f32 = -16777215;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_SAFE_INTEGER: f32 =  16777215;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const POSITIVE_INFINITY: f32 =  Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NEGATIVE_INFINITY: f32 = -Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NaN: f32 = 0.0 / 0.0;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function copysign(x: f32, y: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_i32(value: i32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: f32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(left: f32, right: f32): f32;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f64(value: auto): f64;\n\nexport namespace f64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const EPSILON = reinterpret<f64>(0x3CB0000000000000); // 0x1p-52\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE = reinterpret<f64>(0x0000000000000001); // 0x0.0000000000001p+0\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE = reinterpret<f64>(0x7FEFFFFFFFFFFFFF); // 0x1.fffffffffffffp+1023\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_NORMAL_VALUE = reinterpret<f64>(0x0010000000000000); // 0x1p-1022\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_SAFE_INTEGER: f64 = -9007199254740991;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_SAFE_INTEGER: f64 =  9007199254740991;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const POSITIVE_INFINITY: f64 =  Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NEGATIVE_INFINITY: f64 = -Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NaN: f64 = 0.0 / 0.0;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function copysign(x: f64, y: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_i64(value: i64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: f64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(left: f64, right: f64): f64;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function v128(\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\n): v128;\n\nexport namespace v128 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat<T>(x: T): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane<T>(x: v128, idx: u8): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane<T>(x: v128, idx: u8, value: T): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle<T>(a: v128, b: v128, ...lanes: u8[]): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, s: v128): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_ext<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_zero<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_lane<TFrom>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store_lane<TFrom>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8x8_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8x8_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16x4_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16x4_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32x2_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32x2_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_splat<T>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load8_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load16_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load32_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load64_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load32_zero(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load64_zero(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load8_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load16_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load32_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load64_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store32_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store64_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: v128, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div<T>(a: v128, b: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl<T>(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr<T>(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function and(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function or(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function xor(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function andnot(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function not(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitselect(v1: v128, v2: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true<T>(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask<T>(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function dot<T>(a: v128, b: v128): v128; // i16 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr<T>(a: v128, b: v128): v128; // u8, u16 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_low<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_zero<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function demote_zero<T = f64>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function promote_low<T = f32>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function q15mulr_sat<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high<T>(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i8x16(\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\n): v128;\n\nexport namespace i8x16 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_s(x: v128, idx: u8): i8;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_u(x: v128, idx: u8): u8;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i16x8_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(\n    a: v128, b: v128,\n    l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8,\n    l8: u8, l9: u8, l10: u8, l11: u8, l12: u8, l13: u8, l14: u8, l15: u8\n  ): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, s: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i16x8(a: i16, b: i16, c: i16, d: i16, e: i16, f: i16, g: i16, h: i16): v128;\n\nexport namespace i16x8 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i16): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_s(x: v128, idx: u8): i16;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_u(x: v128, idx: u8): u16;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i16): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i32x4_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i32x4_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function q15mulr_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i8x16_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i8x16_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i8x16_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i8x16_u(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i32x4(a: i32, b: i32, c: i32, d: i32): v128;\n\nexport namespace i32x4 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function dot_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f64x2_s_zero(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f64x2_u_zero(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i16x8_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i16x8_u(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i64x2(a: i64, b: i64): v128;\n\nexport namespace i64x2 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i32x4_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i32x4_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i32x4_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i32x4_u(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f32x4(a: f32, b: f32, c: f32, d: f32): v128;\n\nexport namespace f32x4 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: f32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: f32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function demote_f64x2_zero(a: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f64x2(a: f64, b: f64): v128;\n\nexport namespace f64x2 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: f64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: f64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_low_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_low_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function promote_low_f32x4(a: v128): v128;\n}\n\n@final\nexport abstract class i31 { // FIXME: usage of 'new' requires a class :(\n\n  // @ts-ignore: decorator\n  @builtin\n  static new(value: i32): i31ref { return changetype<i31ref>(unreachable()); }\n\n  // @ts-ignore: decorator\n  @builtin\n  static get(i31expr: i31ref): i32 { return unreachable(); }\n}\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n// @ts-ignore: decorator\n@external(\"env\", \"abort\")\ndeclare function abort(\n  message?: string | null,\n  fileName?: string | null,\n  lineNumber?: u32,\n  columnNumber?: u32\n): void;\n\n// @ts-ignore: decorator\n@external(\"env\", \"trace\")\ndeclare function trace(\n  message: string,\n  n?: i32,\n  a0?: f64,\n  a1?: f64,\n  a2?: f64,\n  a3?: f64,\n  a4?: f64\n): void;\n\n// @ts-ignore: decorator\n@external(\"env\", \"seed\")\ndeclare function seed(): f64;\n\n/* eslint-enable @typescript-eslint/no-unused-vars */\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { Runtime } from \"shared/runtime\";\nimport { COMPARATOR, SORT } from \"./util/sort\";\nimport { REVERSE } from \"./util/bytes\";\nimport { idof } from \"./builtins\";\nimport { Array } from \"./array\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_HOLEYARRAY } from \"./util/error\";\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from \"./util/string\";\n\n@final\nexport class StaticArray<T> {\n  [key: number]: T;\n\n  // Note that the interface of StaticArray instances must be a semantically\n  // compatible subset of Array<T> in order for syntax highlighting to work\n  // properly, for instance when creating static arrays from array literals.\n  // The additionally provided static methods take care of dealing with static\n  // arrays exclusively, without having to convert to Array<T> first.\n\n  static fromArray<T>(source: Array<T>): StaticArray<T> {\n    var length = source.length;\n    var outSize = <usize>length << alignof<T>();\n    var out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));\n    if (isManaged<T>()) {\n      let sourcePtr = source.dataStart;\n      for (let i = 0; i < length; ++i) {\n        let off = <usize>i << alignof<T>();\n        let ref = load<usize>(sourcePtr + off);\n        store<usize>(changetype<usize>(out) + off, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(changetype<usize>(out), source.dataStart, outSize);\n    }\n    return out;\n  }\n\n  static concat<T>(source: StaticArray<T>, other: StaticArray<T>): StaticArray<T> {\n    var sourceLen = source.length;\n    var otherLen = select(0, other.length, other === null);\n    var outLen = sourceLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);\n    var out = changetype<StaticArray<T>>(__new(<usize>outLen << alignof<T>(), idof<StaticArray<T>>()));\n    var outStart = changetype<usize>(out);\n    var sourceSize = <usize>sourceLen << alignof<T>();\n    if (isManaged<T>()) {\n      for (let offset: usize = 0; offset < sourceSize; offset += sizeof<T>()) {\n        let ref = load<usize>(changetype<usize>(source) + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n      outStart += sourceSize;\n      let otherSize = <usize>otherLen << alignof<T>();\n      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n        let ref = load<usize>(changetype<usize>(other) + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(outStart, changetype<usize>(source), sourceSize);\n      memory.copy(outStart + sourceSize, changetype<usize>(other), <usize>otherLen << alignof<T>());\n    }\n    return out;\n  }\n\n  static slice<T>(source: StaticArray<T>, start: i32 = 0, end: i32 = i32.MAX_VALUE): StaticArray<T> {\n    var length = source.length;\n    start = start < 0 ? max(start + length, 0) : min(start, length);\n    end   = end   < 0 ? max(end   + length, 0) : min(end  , length);\n    length = max(end - start, 0);\n    var sliceSize = <usize>length << alignof<T>();\n    var slice = changetype<StaticArray<T>>(__new(sliceSize, idof<StaticArray<T>>()));\n    var sourcePtr = changetype<usize>(source) + (<usize>start << alignof<T>());\n    if (isManaged<T>()) {\n      let off: usize = 0;\n      while (off < sliceSize) {\n        let ref = load<usize>(sourcePtr + off);\n        store<usize>(changetype<usize>(slice) + off, ref);\n        __link(changetype<usize>(slice), ref, true);\n        off += sizeof<usize>();\n      }\n    } else {\n      memory.copy(changetype<usize>(slice), sourcePtr, sliceSize);\n    }\n    return slice;\n  }\n\n  constructor(length: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);\n    var outSize = <usize>length << alignof<T>();\n    var out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(out), 0, outSize);\n    }\n    return out;\n  }\n\n  get length(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize >>> alignof<T>();\n  }\n\n  at(index: i32): T {\n    var len = this.length;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    var value = load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @operator(\"[]\") private __get(index: i32): T {\n    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);\n    var value = load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @unsafe @operator(\"{}\") private __uget(index: i32): T {\n    return load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n  }\n\n  @operator(\"[]=\") private __set(index: i32, value: T): void {\n    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);\n    this.__uset(index, value);\n  }\n\n  @unsafe @operator(\"{}=\") private __uset(index: i32, value: T): void {\n    store<T>(changetype<usize>(this) + (<usize>index << alignof<T>()), value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n  }\n\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): this {\n    var ptr = changetype<usize>(this);\n    var len = this.length;\n    start = start < 0 ? max(len + start, 0) : min(start, len);\n    end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n    if (isManaged<T>()) {\n      for (; start < end; ++start) {\n        store<usize>(ptr + (<usize>start << alignof<T>()), changetype<usize>(value));\n        __link(changetype<usize>(this), changetype<usize>(value), true);\n      }\n    } else if (sizeof<T>() == 1) {\n      if (start < end) {\n        memory.fill(\n          ptr + <usize>start,\n          u8(value),\n          <usize>(end - start)\n        );\n      }\n    } else {\n      for (; start < end; ++start) {\n        store<T>(ptr + (<usize>start << alignof<T>()), value);\n      }\n    }\n    return this;\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): this {\n    var ptr = changetype<usize>(this);\n    var len = this.length;\n\n    end = min<i32>(end, len);\n\n    var to    = target < 0 ? max(len + target, 0) : min(target, len);\n    var from  = start < 0 ? max(len + start, 0) : min(start, len);\n    var last  = end < 0 ? max(len + end, 0) : min(end, len);\n    var count = min(last - from, len - to);\n\n    memory.copy( // is memmove\n      ptr + (<usize>to << alignof<T>()),\n      ptr + (<usize>from << alignof<T>()),\n      <usize>count << alignof<T>()\n    );\n    return this;\n  }\n\n  includes(value: T, fromIndex: i32 = 0): bool {\n    if (isFloat<T>()) {\n      let length = this.length;\n      if (length == 0 || fromIndex >= length) return false;\n      if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n      while (fromIndex < length) {\n        let elem = load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>()));\n        // @ts-ignore\n        if (elem == value || isNaN(elem) & isNaN(value)) return true;\n        ++fromIndex;\n      }\n      return false;\n    } else {\n      return this.indexOf(value, fromIndex) >= 0;\n    }\n  }\n\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\n    var length = this.length;\n    if (length == 0 || fromIndex >= length) return -1;\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n    while (fromIndex < length) {\n      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(value: T, fromIndex: i32 = this.length): i32 {\n    var length = this.length;\n    if (length == 0) return -1;\n    if (fromIndex < 0) fromIndex = length + fromIndex;\n    else if (fromIndex >= length) fromIndex = length - 1;\n    while (fromIndex >= 0) {\n      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  concat(other: Array<T>): Array<T> {\n    var thisLen = this.length;\n    var otherLen = select(0, other.length, other === null);\n    var outLen = thisLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);\n    var out = changetype<Array<T>>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));\n    var outStart = out.dataStart;\n    var thisSize = <usize>thisLen << alignof<T>();\n    if (isManaged<T>()) {\n      let thisStart = changetype<usize>(this);\n      for (let offset: usize = 0; offset < thisSize; offset += sizeof<T>()) {\n        let ref = load<usize>(thisStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n      outStart += thisSize;\n      let otherStart = other.dataStart;\n      let otherSize = <usize>otherLen << alignof<T>();\n      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n        let ref = load<usize>(otherStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(outStart, changetype<usize>(this), thisSize);\n      memory.copy(outStart + thisSize, other.dataStart, <usize>otherLen << alignof<T>());\n    }\n    return out;\n  }\n\n  slice(start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    var length = this.length;\n    start = start < 0 ? max(start + length, 0) : min(start, length);\n    end   = end   < 0 ? max(end   + length, 0) : min(end  , length);\n    length = max(end - start, 0);\n    var slice = changetype<Array<T>>(__newArray(length, alignof<T>(), idof<Array<T>>()));\n    var sliceBase = slice.dataStart;\n    var thisBase = changetype<usize>(this) + (<usize>start << alignof<T>());\n    if (isManaged<T>()) {\n      let off = <usize>0;\n      let end = <usize>length << alignof<usize>();\n      while (off < end) {\n        let ref = load<usize>(thisBase + off);\n        store<usize>(sliceBase + off, ref);\n        __link(changetype<usize>(slice), ref, true);\n        off += sizeof<usize>();\n      }\n    } else {\n      memory.copy(sliceBase, thisBase, length << alignof<T>());\n    }\n    return slice;\n  }\n\n  findIndex(fn: (value: T, index: i32, array: StaticArray<T>) => bool): i32 {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  findLastIndex(fn: (value: T, index: i32, array: StaticArray<T>) => bool): i32 {\n    for (let i = this.length - 1; i >= 0; --i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  forEach(fn: (value: T, index: i32, array: StaticArray<T>) => void): void {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n  }\n\n  map<U>(fn: (value: T, index: i32, array: StaticArray<T>) => U): Array<U> {\n    var len = this.length;\n    var out = changetype<Array<U>>(__newArray(len, alignof<U>(), idof<Array<U>>()));\n    var outStart = out.dataStart;\n    for (let i = 0; i < len; ++i) {\n      let result = fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n      store<U>(outStart + (<usize>i << alignof<U>()), result);\n      if (isManaged<U>()) {\n        __link(changetype<usize>(out), changetype<usize>(result), true);\n      }\n    }\n    return out;\n  }\n\n  filter(fn: (value: T, index: i32, array: StaticArray<T>) => bool): Array<T> {\n    var result = changetype<Array<T>>(__newArray(0, alignof<T>(), idof<Array<T>>()));\n    for (let i = 0, len = this.length; i < len; ++i) {\n      let value = load<T>(changetype<usize>(this) + (<usize>i << alignof<T>()));\n      if (fn(value, i, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: StaticArray<T>) => U,\n    initialValue: U\n  ): U {\n    var acc = initialValue;\n    for (let i = 0, len = this.length; i < len; ++i) {\n      acc = fn(acc, load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  reduceRight<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: StaticArray<T>) => U,\n    initialValue: U\n  ): U {\n    var acc = initialValue;\n    for (let i = this.length - 1; i >= 0; --i) {\n      acc = fn(acc, load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  every(fn: (value: T, index: i32, array: StaticArray<T>) => bool): bool {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (!fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return false;\n    }\n    return true;\n  }\n\n  some(fn: (value: T, index: i32, array: StaticArray<T>) => bool): bool {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return true;\n    }\n    return false;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): this {\n    SORT<T>(changetype<usize>(this), this.length, comparator);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    if (isBoolean<T>())   return joinBooleanArray(changetype<usize>(this), this.length, separator);\n    if (isInteger<T>())   return joinIntegerArray<T>(changetype<usize>(this), this.length, separator);\n    if (isFloat<T>())     return joinFloatArray<T>(changetype<usize>(this), this.length, separator);\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (isString<T>())  return joinStringArray(changetype<usize>(this), this.length, separator);\n    }\n    if (isReference<T>()) return joinReferenceArray<T>(changetype<usize>(this), this.length, separator);\n    ERROR(\"unspported element type\");\n    return <string>unreachable();\n  }\n\n  reverse(): this {\n    REVERSE<T>(changetype<usize>(this), this.length);\n    return this;\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    if (isManaged<T>()) {\n      let cur = changetype<usize>(this);\n      let end = cur + changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;\n      while (cur < end) {\n        let val = load<usize>(cur);\n        if (val) __visit(val, cookie);\n        cur += sizeof<usize>();\n      }\n    }\n  }\n}\n","import { Writer, Reader } from \"as-proto\";\nimport { chain } from \"./chain\";\nimport { protocol } from \"../protocol/protocol\";\nimport { value } from \"./value\";\nimport { authority } from \"./authority\";\n\nexport namespace system_calls {\n  @unmanaged\n  export class nop_arguments {\n    static encode(message: nop_arguments, writer: Writer): void {}\n\n    static decode(reader: Reader, length: i32): nop_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new nop_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    constructor() {}\n  }\n\n  @unmanaged\n  export class nop_result {\n    static encode(message: nop_result, writer: Writer): void {}\n\n    static decode(reader: Reader, length: i32): nop_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new nop_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    constructor() {}\n  }\n\n  @unmanaged\n  export class get_head_info_arguments {\n    static encode(message: get_head_info_arguments, writer: Writer): void {}\n\n    static decode(reader: Reader, length: i32): get_head_info_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new get_head_info_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    constructor() {}\n  }\n\n  export class get_head_info_result {\n    static encode(message: get_head_info_result, writer: Writer): void {\n      const unique_name_value = message.value;\n      if (unique_name_value !== null) {\n        writer.uint32(10);\n        writer.fork();\n        chain.head_info.encode(unique_name_value, writer);\n        writer.ldelim();\n      }\n    }\n\n    static decode(reader: Reader, length: i32): get_head_info_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new get_head_info_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.value = chain.head_info.decode(reader, reader.uint32());\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    value: chain.head_info | null;\n\n    constructor(value: chain.head_info | null = null) {\n      this.value = value;\n    }\n  }\n\n  export class apply_block_arguments {\n    static encode(message: apply_block_arguments, writer: Writer): void {\n      const unique_name_block = message.block;\n      if (unique_name_block !== null) {\n        writer.uint32(10);\n        writer.fork();\n        protocol.block.encode(unique_name_block, writer);\n        writer.ldelim();\n      }\n    }\n\n    static decode(reader: Reader, length: i32): apply_block_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new apply_block_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.block = protocol.block.decode(reader, reader.uint32());\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    block: protocol.block | null;\n\n    constructor(block: protocol.block | null = null) {\n      this.block = block;\n    }\n  }\n\n  @unmanaged\n  export class apply_block_result {\n    static encode(message: apply_block_result, writer: Writer): void {}\n\n    static decode(reader: Reader, length: i32): apply_block_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new apply_block_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    constructor() {}\n  }\n\n  export class apply_transaction_arguments {\n    static encode(message: apply_transaction_arguments, writer: Writer): void {\n      const unique_name_transaction = message.transaction;\n      if (unique_name_transaction !== null) {\n        writer.uint32(10);\n        writer.fork();\n        protocol.transaction.encode(unique_name_transaction, writer);\n        writer.ldelim();\n      }\n    }\n\n    static decode(reader: Reader, length: i32): apply_transaction_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new apply_transaction_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.transaction = protocol.transaction.decode(\n              reader,\n              reader.uint32()\n            );\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    transaction: protocol.transaction | null;\n\n    constructor(transaction: protocol.transaction | null = null) {\n      this.transaction = transaction;\n    }\n  }\n\n  @unmanaged\n  export class apply_transaction_result {\n    static encode(message: apply_transaction_result, writer: Writer): void {}\n\n    static decode(reader: Reader, length: i32): apply_transaction_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new apply_transaction_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    constructor() {}\n  }\n\n  export class apply_upload_contract_operation_arguments {\n    static encode(\n      message: apply_upload_contract_operation_arguments,\n      writer: Writer\n    ): void {\n      const unique_name_op = message.op;\n      if (unique_name_op !== null) {\n        writer.uint32(10);\n        writer.fork();\n        protocol.upload_contract_operation.encode(unique_name_op, writer);\n        writer.ldelim();\n      }\n    }\n\n    static decode(\n      reader: Reader,\n      length: i32\n    ): apply_upload_contract_operation_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new apply_upload_contract_operation_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.op = protocol.upload_contract_operation.decode(\n              reader,\n              reader.uint32()\n            );\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    op: protocol.upload_contract_operation | null;\n\n    constructor(op: protocol.upload_contract_operation | null = null) {\n      this.op = op;\n    }\n  }\n\n  @unmanaged\n  export class apply_upload_contract_operation_result {\n    static encode(\n      message: apply_upload_contract_operation_result,\n      writer: Writer\n    ): void {}\n\n    static decode(\n      reader: Reader,\n      length: i32\n    ): apply_upload_contract_operation_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new apply_upload_contract_operation_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    constructor() {}\n  }\n\n  export class apply_call_contract_operation_arguments {\n    static encode(\n      message: apply_call_contract_operation_arguments,\n      writer: Writer\n    ): void {\n      const unique_name_op = message.op;\n      if (unique_name_op !== null) {\n        writer.uint32(10);\n        writer.fork();\n        protocol.call_contract_operation.encode(unique_name_op, writer);\n        writer.ldelim();\n      }\n    }\n\n    static decode(\n      reader: Reader,\n      length: i32\n    ): apply_call_contract_operation_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new apply_call_contract_operation_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.op = protocol.call_contract_operation.decode(\n              reader,\n              reader.uint32()\n            );\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    op: protocol.call_contract_operation | null;\n\n    constructor(op: protocol.call_contract_operation | null = null) {\n      this.op = op;\n    }\n  }\n\n  @unmanaged\n  export class apply_call_contract_operation_result {\n    static encode(\n      message: apply_call_contract_operation_result,\n      writer: Writer\n    ): void {}\n\n    static decode(\n      reader: Reader,\n      length: i32\n    ): apply_call_contract_operation_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new apply_call_contract_operation_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    constructor() {}\n  }\n\n  export class apply_set_system_call_operation_arguments {\n    static encode(\n      message: apply_set_system_call_operation_arguments,\n      writer: Writer\n    ): void {\n      const unique_name_op = message.op;\n      if (unique_name_op !== null) {\n        writer.uint32(10);\n        writer.fork();\n        protocol.set_system_call_operation.encode(unique_name_op, writer);\n        writer.ldelim();\n      }\n    }\n\n    static decode(\n      reader: Reader,\n      length: i32\n    ): apply_set_system_call_operation_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new apply_set_system_call_operation_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.op = protocol.set_system_call_operation.decode(\n              reader,\n              reader.uint32()\n            );\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    op: protocol.set_system_call_operation | null;\n\n    constructor(op: protocol.set_system_call_operation | null = null) {\n      this.op = op;\n    }\n  }\n\n  @unmanaged\n  export class apply_set_system_call_operation_result {\n    static encode(\n      message: apply_set_system_call_operation_result,\n      writer: Writer\n    ): void {}\n\n    static decode(\n      reader: Reader,\n      length: i32\n    ): apply_set_system_call_operation_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new apply_set_system_call_operation_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    constructor() {}\n  }\n\n  export class apply_set_system_contract_operation_arguments {\n    static encode(\n      message: apply_set_system_contract_operation_arguments,\n      writer: Writer\n    ): void {\n      const unique_name_op = message.op;\n      if (unique_name_op !== null) {\n        writer.uint32(10);\n        writer.fork();\n        protocol.set_system_contract_operation.encode(unique_name_op, writer);\n        writer.ldelim();\n      }\n    }\n\n    static decode(\n      reader: Reader,\n      length: i32\n    ): apply_set_system_contract_operation_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new apply_set_system_contract_operation_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.op = protocol.set_system_contract_operation.decode(\n              reader,\n              reader.uint32()\n            );\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    op: protocol.set_system_contract_operation | null;\n\n    constructor(op: protocol.set_system_contract_operation | null = null) {\n      this.op = op;\n    }\n  }\n\n  @unmanaged\n  export class apply_set_system_contract_operation_result {\n    static encode(\n      message: apply_set_system_contract_operation_result,\n      writer: Writer\n    ): void {}\n\n    static decode(\n      reader: Reader,\n      length: i32\n    ): apply_set_system_contract_operation_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new apply_set_system_contract_operation_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    constructor() {}\n  }\n\n  @unmanaged\n  export class pre_block_callback_arguments {\n    static encode(\n      message: pre_block_callback_arguments,\n      writer: Writer\n    ): void {}\n\n    static decode(reader: Reader, length: i32): pre_block_callback_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new pre_block_callback_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    constructor() {}\n  }\n\n  @unmanaged\n  export class pre_block_callback_result {\n    static encode(message: pre_block_callback_result, writer: Writer): void {}\n\n    static decode(reader: Reader, length: i32): pre_block_callback_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new pre_block_callback_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    constructor() {}\n  }\n\n  @unmanaged\n  export class post_block_callback_arguments {\n    static encode(\n      message: post_block_callback_arguments,\n      writer: Writer\n    ): void {}\n\n    static decode(reader: Reader, length: i32): post_block_callback_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new post_block_callback_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    constructor() {}\n  }\n\n  @unmanaged\n  export class post_block_callback_result {\n    static encode(message: post_block_callback_result, writer: Writer): void {}\n\n    static decode(reader: Reader, length: i32): post_block_callback_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new post_block_callback_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    constructor() {}\n  }\n\n  @unmanaged\n  export class pre_transaction_callback_arguments {\n    static encode(\n      message: pre_transaction_callback_arguments,\n      writer: Writer\n    ): void {}\n\n    static decode(\n      reader: Reader,\n      length: i32\n    ): pre_transaction_callback_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new pre_transaction_callback_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    constructor() {}\n  }\n\n  @unmanaged\n  export class pre_transaction_callback_result {\n    static encode(\n      message: pre_transaction_callback_result,\n      writer: Writer\n    ): void {}\n\n    static decode(\n      reader: Reader,\n      length: i32\n    ): pre_transaction_callback_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new pre_transaction_callback_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    constructor() {}\n  }\n\n  @unmanaged\n  export class post_transaction_callback_arguments {\n    static encode(\n      message: post_transaction_callback_arguments,\n      writer: Writer\n    ): void {}\n\n    static decode(\n      reader: Reader,\n      length: i32\n    ): post_transaction_callback_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new post_transaction_callback_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    constructor() {}\n  }\n\n  @unmanaged\n  export class post_transaction_callback_result {\n    static encode(\n      message: post_transaction_callback_result,\n      writer: Writer\n    ): void {}\n\n    static decode(\n      reader: Reader,\n      length: i32\n    ): post_transaction_callback_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new post_transaction_callback_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    constructor() {}\n  }\n\n  @unmanaged\n  export class get_chain_id_arguments {\n    static encode(message: get_chain_id_arguments, writer: Writer): void {}\n\n    static decode(reader: Reader, length: i32): get_chain_id_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new get_chain_id_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    constructor() {}\n  }\n\n  export class get_chain_id_result {\n    static encode(message: get_chain_id_result, writer: Writer): void {\n      const unique_name_value = message.value;\n      if (unique_name_value !== null) {\n        writer.uint32(10);\n        writer.bytes(unique_name_value);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): get_chain_id_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new get_chain_id_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.value = reader.bytes();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    value: Uint8Array | null;\n\n    constructor(value: Uint8Array | null = null) {\n      this.value = value;\n    }\n  }\n\n  export class process_block_signature_arguments {\n    static encode(\n      message: process_block_signature_arguments,\n      writer: Writer\n    ): void {\n      const unique_name_digest = message.digest;\n      if (unique_name_digest !== null) {\n        writer.uint32(10);\n        writer.bytes(unique_name_digest);\n      }\n\n      const unique_name_header = message.header;\n      if (unique_name_header !== null) {\n        writer.uint32(18);\n        writer.fork();\n        protocol.block_header.encode(unique_name_header, writer);\n        writer.ldelim();\n      }\n\n      const unique_name_signature = message.signature;\n      if (unique_name_signature !== null) {\n        writer.uint32(26);\n        writer.bytes(unique_name_signature);\n      }\n    }\n\n    static decode(\n      reader: Reader,\n      length: i32\n    ): process_block_signature_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new process_block_signature_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.digest = reader.bytes();\n            break;\n\n          case 2:\n            message.header = protocol.block_header.decode(\n              reader,\n              reader.uint32()\n            );\n            break;\n\n          case 3:\n            message.signature = reader.bytes();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    digest: Uint8Array | null;\n    header: protocol.block_header | null;\n    signature: Uint8Array | null;\n\n    constructor(\n      digest: Uint8Array | null = null,\n      header: protocol.block_header | null = null,\n      signature: Uint8Array | null = null\n    ) {\n      this.digest = digest;\n      this.header = header;\n      this.signature = signature;\n    }\n  }\n\n  @unmanaged\n  export class process_block_signature_result {\n    static encode(\n      message: process_block_signature_result,\n      writer: Writer\n    ): void {\n      if (message.value != false) {\n        writer.uint32(8);\n        writer.bool(message.value);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): process_block_signature_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new process_block_signature_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.value = reader.bool();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    value: bool;\n\n    constructor(value: bool = false) {\n      this.value = value;\n    }\n  }\n\n  @unmanaged\n  export class get_transaction_arguments {\n    static encode(message: get_transaction_arguments, writer: Writer): void {}\n\n    static decode(reader: Reader, length: i32): get_transaction_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new get_transaction_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    constructor() {}\n  }\n\n  export class get_transaction_result {\n    static encode(message: get_transaction_result, writer: Writer): void {\n      const unique_name_value = message.value;\n      if (unique_name_value !== null) {\n        writer.uint32(10);\n        writer.fork();\n        protocol.transaction.encode(unique_name_value, writer);\n        writer.ldelim();\n      }\n    }\n\n    static decode(reader: Reader, length: i32): get_transaction_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new get_transaction_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.value = protocol.transaction.decode(\n              reader,\n              reader.uint32()\n            );\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    value: protocol.transaction | null;\n\n    constructor(value: protocol.transaction | null = null) {\n      this.value = value;\n    }\n  }\n\n  export class get_transaction_field_arguments {\n    static encode(\n      message: get_transaction_field_arguments,\n      writer: Writer\n    ): void {\n      const unique_name_field = message.field;\n      if (unique_name_field !== null) {\n        writer.uint32(10);\n        writer.string(unique_name_field);\n      }\n    }\n\n    static decode(\n      reader: Reader,\n      length: i32\n    ): get_transaction_field_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new get_transaction_field_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.field = reader.string();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    field: string | null;\n\n    constructor(field: string | null = null) {\n      this.field = field;\n    }\n  }\n\n  export class get_transaction_field_result {\n    static encode(message: get_transaction_field_result, writer: Writer): void {\n      const unique_name_value = message.value;\n      if (unique_name_value !== null) {\n        writer.uint32(10);\n        writer.fork();\n        value.value_type.encode(unique_name_value, writer);\n        writer.ldelim();\n      }\n    }\n\n    static decode(reader: Reader, length: i32): get_transaction_field_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new get_transaction_field_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.value = value.value_type.decode(reader, reader.uint32());\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    value: value.value_type | null;\n\n    constructor(value: value.value_type | null = null) {\n      this.value = value;\n    }\n  }\n\n  @unmanaged\n  export class get_block_arguments {\n    static encode(message: get_block_arguments, writer: Writer): void {}\n\n    static decode(reader: Reader, length: i32): get_block_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new get_block_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    constructor() {}\n  }\n\n  export class get_block_result {\n    static encode(message: get_block_result, writer: Writer): void {\n      const unique_name_value = message.value;\n      if (unique_name_value !== null) {\n        writer.uint32(10);\n        writer.fork();\n        protocol.block.encode(unique_name_value, writer);\n        writer.ldelim();\n      }\n    }\n\n    static decode(reader: Reader, length: i32): get_block_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new get_block_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.value = protocol.block.decode(reader, reader.uint32());\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    value: protocol.block | null;\n\n    constructor(value: protocol.block | null = null) {\n      this.value = value;\n    }\n  }\n\n  export class get_block_field_arguments {\n    static encode(message: get_block_field_arguments, writer: Writer): void {\n      const unique_name_field = message.field;\n      if (unique_name_field !== null) {\n        writer.uint32(10);\n        writer.string(unique_name_field);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): get_block_field_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new get_block_field_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.field = reader.string();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    field: string | null;\n\n    constructor(field: string | null = null) {\n      this.field = field;\n    }\n  }\n\n  export class get_block_field_result {\n    static encode(message: get_block_field_result, writer: Writer): void {\n      const unique_name_value = message.value;\n      if (unique_name_value !== null) {\n        writer.uint32(10);\n        writer.fork();\n        value.value_type.encode(unique_name_value, writer);\n        writer.ldelim();\n      }\n    }\n\n    static decode(reader: Reader, length: i32): get_block_field_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new get_block_field_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.value = value.value_type.decode(reader, reader.uint32());\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    value: value.value_type | null;\n\n    constructor(value: value.value_type | null = null) {\n      this.value = value;\n    }\n  }\n\n  @unmanaged\n  export class get_last_irreversible_block_arguments {\n    static encode(\n      message: get_last_irreversible_block_arguments,\n      writer: Writer\n    ): void {}\n\n    static decode(\n      reader: Reader,\n      length: i32\n    ): get_last_irreversible_block_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new get_last_irreversible_block_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    constructor() {}\n  }\n\n  @unmanaged\n  export class get_last_irreversible_block_result {\n    static encode(\n      message: get_last_irreversible_block_result,\n      writer: Writer\n    ): void {\n      if (message.value != 0) {\n        writer.uint32(8);\n        writer.uint64(message.value);\n      }\n    }\n\n    static decode(\n      reader: Reader,\n      length: i32\n    ): get_last_irreversible_block_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new get_last_irreversible_block_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.value = reader.uint64();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    value: u64;\n\n    constructor(value: u64 = 0) {\n      this.value = value;\n    }\n  }\n\n  export class get_account_nonce_arguments {\n    static encode(message: get_account_nonce_arguments, writer: Writer): void {\n      const unique_name_account = message.account;\n      if (unique_name_account !== null) {\n        writer.uint32(10);\n        writer.bytes(unique_name_account);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): get_account_nonce_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new get_account_nonce_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.account = reader.bytes();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    account: Uint8Array | null;\n\n    constructor(account: Uint8Array | null = null) {\n      this.account = account;\n    }\n  }\n\n  export class get_account_nonce_result {\n    static encode(message: get_account_nonce_result, writer: Writer): void {\n      const unique_name_value = message.value;\n      if (unique_name_value !== null) {\n        writer.uint32(10);\n        writer.bytes(unique_name_value);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): get_account_nonce_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new get_account_nonce_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.value = reader.bytes();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    value: Uint8Array | null;\n\n    constructor(value: Uint8Array | null = null) {\n      this.value = value;\n    }\n  }\n\n  export class verify_account_nonce_arguments {\n    static encode(\n      message: verify_account_nonce_arguments,\n      writer: Writer\n    ): void {\n      const unique_name_account = message.account;\n      if (unique_name_account !== null) {\n        writer.uint32(10);\n        writer.bytes(unique_name_account);\n      }\n\n      const unique_name_nonce = message.nonce;\n      if (unique_name_nonce !== null) {\n        writer.uint32(18);\n        writer.bytes(unique_name_nonce);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): verify_account_nonce_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new verify_account_nonce_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.account = reader.bytes();\n            break;\n\n          case 2:\n            message.nonce = reader.bytes();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    account: Uint8Array | null;\n    nonce: Uint8Array | null;\n\n    constructor(\n      account: Uint8Array | null = null,\n      nonce: Uint8Array | null = null\n    ) {\n      this.account = account;\n      this.nonce = nonce;\n    }\n  }\n\n  @unmanaged\n  export class verify_account_nonce_result {\n    static encode(message: verify_account_nonce_result, writer: Writer): void {\n      if (message.value != false) {\n        writer.uint32(8);\n        writer.bool(message.value);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): verify_account_nonce_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new verify_account_nonce_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.value = reader.bool();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    value: bool;\n\n    constructor(value: bool = false) {\n      this.value = value;\n    }\n  }\n\n  export class set_account_nonce_arguments {\n    static encode(message: set_account_nonce_arguments, writer: Writer): void {\n      const unique_name_account = message.account;\n      if (unique_name_account !== null) {\n        writer.uint32(10);\n        writer.bytes(unique_name_account);\n      }\n\n      const unique_name_nonce = message.nonce;\n      if (unique_name_nonce !== null) {\n        writer.uint32(18);\n        writer.bytes(unique_name_nonce);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): set_account_nonce_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new set_account_nonce_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.account = reader.bytes();\n            break;\n\n          case 2:\n            message.nonce = reader.bytes();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    account: Uint8Array | null;\n    nonce: Uint8Array | null;\n\n    constructor(\n      account: Uint8Array | null = null,\n      nonce: Uint8Array | null = null\n    ) {\n      this.account = account;\n      this.nonce = nonce;\n    }\n  }\n\n  @unmanaged\n  export class set_account_nonce_result {\n    static encode(message: set_account_nonce_result, writer: Writer): void {}\n\n    static decode(reader: Reader, length: i32): set_account_nonce_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new set_account_nonce_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    constructor() {}\n  }\n\n  @unmanaged\n  export class check_system_authority_arguments {\n    static encode(\n      message: check_system_authority_arguments,\n      writer: Writer\n    ): void {}\n\n    static decode(\n      reader: Reader,\n      length: i32\n    ): check_system_authority_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new check_system_authority_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    constructor() {}\n  }\n\n  @unmanaged\n  export class check_system_authority_result {\n    static encode(\n      message: check_system_authority_result,\n      writer: Writer\n    ): void {\n      if (message.value != false) {\n        writer.uint32(8);\n        writer.bool(message.value);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): check_system_authority_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new check_system_authority_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.value = reader.bool();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    value: bool;\n\n    constructor(value: bool = false) {\n      this.value = value;\n    }\n  }\n\n  @unmanaged\n  export class get_operation_arguments {\n    static encode(message: get_operation_arguments, writer: Writer): void {}\n\n    static decode(reader: Reader, length: i32): get_operation_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new get_operation_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    constructor() {}\n  }\n\n  export class get_operation_result {\n    static encode(message: get_operation_result, writer: Writer): void {\n      const unique_name_value = message.value;\n      if (unique_name_value !== null) {\n        writer.uint32(10);\n        writer.fork();\n        protocol.operation.encode(unique_name_value, writer);\n        writer.ldelim();\n      }\n    }\n\n    static decode(reader: Reader, length: i32): get_operation_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new get_operation_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.value = protocol.operation.decode(reader, reader.uint32());\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    value: protocol.operation | null;\n\n    constructor(value: protocol.operation | null = null) {\n      this.value = value;\n    }\n  }\n\n  export class get_account_rc_arguments {\n    static encode(message: get_account_rc_arguments, writer: Writer): void {\n      const unique_name_account = message.account;\n      if (unique_name_account !== null) {\n        writer.uint32(10);\n        writer.bytes(unique_name_account);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): get_account_rc_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new get_account_rc_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.account = reader.bytes();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    account: Uint8Array | null;\n\n    constructor(account: Uint8Array | null = null) {\n      this.account = account;\n    }\n  }\n\n  @unmanaged\n  export class get_account_rc_result {\n    static encode(message: get_account_rc_result, writer: Writer): void {\n      if (message.value != 0) {\n        writer.uint32(8);\n        writer.uint64(message.value);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): get_account_rc_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new get_account_rc_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.value = reader.uint64();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    value: u64;\n\n    constructor(value: u64 = 0) {\n      this.value = value;\n    }\n  }\n\n  export class consume_account_rc_arguments {\n    static encode(message: consume_account_rc_arguments, writer: Writer): void {\n      const unique_name_account = message.account;\n      if (unique_name_account !== null) {\n        writer.uint32(10);\n        writer.bytes(unique_name_account);\n      }\n\n      if (message.value != 0) {\n        writer.uint32(16);\n        writer.uint64(message.value);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): consume_account_rc_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new consume_account_rc_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.account = reader.bytes();\n            break;\n\n          case 2:\n            message.value = reader.uint64();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    account: Uint8Array | null;\n    value: u64;\n\n    constructor(account: Uint8Array | null = null, value: u64 = 0) {\n      this.account = account;\n      this.value = value;\n    }\n  }\n\n  @unmanaged\n  export class consume_account_rc_result {\n    static encode(message: consume_account_rc_result, writer: Writer): void {\n      if (message.value != false) {\n        writer.uint32(8);\n        writer.bool(message.value);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): consume_account_rc_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new consume_account_rc_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.value = reader.bool();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    value: bool;\n\n    constructor(value: bool = false) {\n      this.value = value;\n    }\n  }\n\n  @unmanaged\n  export class get_resource_limits_arguments {\n    static encode(\n      message: get_resource_limits_arguments,\n      writer: Writer\n    ): void {}\n\n    static decode(reader: Reader, length: i32): get_resource_limits_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new get_resource_limits_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    constructor() {}\n  }\n\n  @unmanaged\n  export class get_resource_limits_result {\n    static encode(message: get_resource_limits_result, writer: Writer): void {\n      const unique_name_value = message.value;\n      if (unique_name_value !== null) {\n        writer.uint32(10);\n        writer.fork();\n        chain.resource_limit_data.encode(unique_name_value, writer);\n        writer.ldelim();\n      }\n    }\n\n    static decode(reader: Reader, length: i32): get_resource_limits_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new get_resource_limits_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.value = chain.resource_limit_data.decode(\n              reader,\n              reader.uint32()\n            );\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    value: chain.resource_limit_data | null;\n\n    constructor(value: chain.resource_limit_data | null = null) {\n      this.value = value;\n    }\n  }\n\n  @unmanaged\n  export class consume_block_resources_arguments {\n    static encode(\n      message: consume_block_resources_arguments,\n      writer: Writer\n    ): void {\n      if (message.disk_storage_consumed != 0) {\n        writer.uint32(8);\n        writer.uint64(message.disk_storage_consumed);\n      }\n\n      if (message.network_bandwidth_consumed != 0) {\n        writer.uint32(16);\n        writer.uint64(message.network_bandwidth_consumed);\n      }\n\n      if (message.compute_bandwidth_consumed != 0) {\n        writer.uint32(24);\n        writer.uint64(message.compute_bandwidth_consumed);\n      }\n    }\n\n    static decode(\n      reader: Reader,\n      length: i32\n    ): consume_block_resources_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new consume_block_resources_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.disk_storage_consumed = reader.uint64();\n            break;\n\n          case 2:\n            message.network_bandwidth_consumed = reader.uint64();\n            break;\n\n          case 3:\n            message.compute_bandwidth_consumed = reader.uint64();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    disk_storage_consumed: u64;\n    network_bandwidth_consumed: u64;\n    compute_bandwidth_consumed: u64;\n\n    constructor(\n      disk_storage_consumed: u64 = 0,\n      network_bandwidth_consumed: u64 = 0,\n      compute_bandwidth_consumed: u64 = 0\n    ) {\n      this.disk_storage_consumed = disk_storage_consumed;\n      this.network_bandwidth_consumed = network_bandwidth_consumed;\n      this.compute_bandwidth_consumed = compute_bandwidth_consumed;\n    }\n  }\n\n  @unmanaged\n  export class consume_block_resources_result {\n    static encode(\n      message: consume_block_resources_result,\n      writer: Writer\n    ): void {\n      if (message.value != false) {\n        writer.uint32(8);\n        writer.bool(message.value);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): consume_block_resources_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new consume_block_resources_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.value = reader.bool();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    value: bool;\n\n    constructor(value: bool = false) {\n      this.value = value;\n    }\n  }\n\n  export class put_object_arguments {\n    static encode(message: put_object_arguments, writer: Writer): void {\n      const unique_name_space = message.space;\n      if (unique_name_space !== null) {\n        writer.uint32(10);\n        writer.fork();\n        chain.object_space.encode(unique_name_space, writer);\n        writer.ldelim();\n      }\n\n      const unique_name_key = message.key;\n      if (unique_name_key !== null) {\n        writer.uint32(18);\n        writer.bytes(unique_name_key);\n      }\n\n      const unique_name_obj = message.obj;\n      if (unique_name_obj !== null) {\n        writer.uint32(26);\n        writer.bytes(unique_name_obj);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): put_object_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new put_object_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.space = chain.object_space.decode(reader, reader.uint32());\n            break;\n\n          case 2:\n            message.key = reader.bytes();\n            break;\n\n          case 3:\n            message.obj = reader.bytes();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    space: chain.object_space | null;\n    key: Uint8Array | null;\n    obj: Uint8Array | null;\n\n    constructor(\n      space: chain.object_space | null = null,\n      key: Uint8Array | null = null,\n      obj: Uint8Array | null = null\n    ) {\n      this.space = space;\n      this.key = key;\n      this.obj = obj;\n    }\n  }\n\n  @unmanaged\n  export class put_object_result {\n    static encode(message: put_object_result, writer: Writer): void {}\n\n    static decode(reader: Reader, length: i32): put_object_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new put_object_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    constructor() {}\n  }\n\n  export class remove_object_arguments {\n    static encode(message: remove_object_arguments, writer: Writer): void {\n      const unique_name_space = message.space;\n      if (unique_name_space !== null) {\n        writer.uint32(10);\n        writer.fork();\n        chain.object_space.encode(unique_name_space, writer);\n        writer.ldelim();\n      }\n\n      const unique_name_key = message.key;\n      if (unique_name_key !== null) {\n        writer.uint32(18);\n        writer.bytes(unique_name_key);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): remove_object_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new remove_object_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.space = chain.object_space.decode(reader, reader.uint32());\n            break;\n\n          case 2:\n            message.key = reader.bytes();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    space: chain.object_space | null;\n    key: Uint8Array | null;\n\n    constructor(\n      space: chain.object_space | null = null,\n      key: Uint8Array | null = null\n    ) {\n      this.space = space;\n      this.key = key;\n    }\n  }\n\n  @unmanaged\n  export class remove_object_result {\n    static encode(message: remove_object_result, writer: Writer): void {}\n\n    static decode(reader: Reader, length: i32): remove_object_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new remove_object_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    constructor() {}\n  }\n\n  export class get_object_arguments {\n    static encode(message: get_object_arguments, writer: Writer): void {\n      const unique_name_space = message.space;\n      if (unique_name_space !== null) {\n        writer.uint32(10);\n        writer.fork();\n        chain.object_space.encode(unique_name_space, writer);\n        writer.ldelim();\n      }\n\n      const unique_name_key = message.key;\n      if (unique_name_key !== null) {\n        writer.uint32(18);\n        writer.bytes(unique_name_key);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): get_object_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new get_object_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.space = chain.object_space.decode(reader, reader.uint32());\n            break;\n\n          case 2:\n            message.key = reader.bytes();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    space: chain.object_space | null;\n    key: Uint8Array | null;\n\n    constructor(\n      space: chain.object_space | null = null,\n      key: Uint8Array | null = null\n    ) {\n      this.space = space;\n      this.key = key;\n    }\n  }\n\n  export class database_object {\n    static encode(message: database_object, writer: Writer): void {\n      if (message.exists != false) {\n        writer.uint32(8);\n        writer.bool(message.exists);\n      }\n\n      const unique_name_value = message.value;\n      if (unique_name_value !== null) {\n        writer.uint32(18);\n        writer.bytes(unique_name_value);\n      }\n\n      const unique_name_key = message.key;\n      if (unique_name_key !== null) {\n        writer.uint32(26);\n        writer.bytes(unique_name_key);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): database_object {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new database_object();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.exists = reader.bool();\n            break;\n\n          case 2:\n            message.value = reader.bytes();\n            break;\n\n          case 3:\n            message.key = reader.bytes();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    exists: bool;\n    value: Uint8Array | null;\n    key: Uint8Array | null;\n\n    constructor(\n      exists: bool = false,\n      value: Uint8Array | null = null,\n      key: Uint8Array | null = null\n    ) {\n      this.exists = exists;\n      this.value = value;\n      this.key = key;\n    }\n  }\n\n  export class get_object_result {\n    static encode(message: get_object_result, writer: Writer): void {\n      const unique_name_value = message.value;\n      if (unique_name_value !== null) {\n        writer.uint32(10);\n        writer.fork();\n        database_object.encode(unique_name_value, writer);\n        writer.ldelim();\n      }\n    }\n\n    static decode(reader: Reader, length: i32): get_object_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new get_object_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.value = database_object.decode(reader, reader.uint32());\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    value: database_object | null;\n\n    constructor(value: database_object | null = null) {\n      this.value = value;\n    }\n  }\n\n  export class get_next_object_arguments {\n    static encode(message: get_next_object_arguments, writer: Writer): void {\n      const unique_name_space = message.space;\n      if (unique_name_space !== null) {\n        writer.uint32(10);\n        writer.fork();\n        chain.object_space.encode(unique_name_space, writer);\n        writer.ldelim();\n      }\n\n      const unique_name_key = message.key;\n      if (unique_name_key !== null) {\n        writer.uint32(18);\n        writer.bytes(unique_name_key);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): get_next_object_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new get_next_object_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.space = chain.object_space.decode(reader, reader.uint32());\n            break;\n\n          case 2:\n            message.key = reader.bytes();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    space: chain.object_space | null;\n    key: Uint8Array | null;\n\n    constructor(\n      space: chain.object_space | null = null,\n      key: Uint8Array | null = null\n    ) {\n      this.space = space;\n      this.key = key;\n    }\n  }\n\n  export class get_next_object_result {\n    static encode(message: get_next_object_result, writer: Writer): void {\n      const unique_name_value = message.value;\n      if (unique_name_value !== null) {\n        writer.uint32(10);\n        writer.fork();\n        database_object.encode(unique_name_value, writer);\n        writer.ldelim();\n      }\n    }\n\n    static decode(reader: Reader, length: i32): get_next_object_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new get_next_object_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.value = database_object.decode(reader, reader.uint32());\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    value: database_object | null;\n\n    constructor(value: database_object | null = null) {\n      this.value = value;\n    }\n  }\n\n  export class get_prev_object_arguments {\n    static encode(message: get_prev_object_arguments, writer: Writer): void {\n      const unique_name_space = message.space;\n      if (unique_name_space !== null) {\n        writer.uint32(10);\n        writer.fork();\n        chain.object_space.encode(unique_name_space, writer);\n        writer.ldelim();\n      }\n\n      const unique_name_key = message.key;\n      if (unique_name_key !== null) {\n        writer.uint32(18);\n        writer.bytes(unique_name_key);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): get_prev_object_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new get_prev_object_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.space = chain.object_space.decode(reader, reader.uint32());\n            break;\n\n          case 2:\n            message.key = reader.bytes();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    space: chain.object_space | null;\n    key: Uint8Array | null;\n\n    constructor(\n      space: chain.object_space | null = null,\n      key: Uint8Array | null = null\n    ) {\n      this.space = space;\n      this.key = key;\n    }\n  }\n\n  export class get_prev_object_result {\n    static encode(message: get_prev_object_result, writer: Writer): void {\n      const unique_name_value = message.value;\n      if (unique_name_value !== null) {\n        writer.uint32(10);\n        writer.fork();\n        database_object.encode(unique_name_value, writer);\n        writer.ldelim();\n      }\n    }\n\n    static decode(reader: Reader, length: i32): get_prev_object_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new get_prev_object_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.value = database_object.decode(reader, reader.uint32());\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    value: database_object | null;\n\n    constructor(value: database_object | null = null) {\n      this.value = value;\n    }\n  }\n\n  export class log_arguments {\n    static encode(message: log_arguments, writer: Writer): void {\n      const unique_name_message_2 = message.message;\n      if (unique_name_message_2 !== null) {\n        writer.uint32(10);\n        writer.string(unique_name_message_2);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): log_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new log_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.message = reader.string();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    message: string | null;\n\n    constructor(message: string | null = null) {\n      this.message = message;\n    }\n  }\n\n  @unmanaged\n  export class log_result {\n    static encode(message: log_result, writer: Writer): void {}\n\n    static decode(reader: Reader, length: i32): log_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new log_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    constructor() {}\n  }\n\n  export class event_arguments {\n    static encode(message: event_arguments, writer: Writer): void {\n      const unique_name_name = message.name;\n      if (unique_name_name !== null) {\n        writer.uint32(10);\n        writer.string(unique_name_name);\n      }\n\n      const unique_name_data = message.data;\n      if (unique_name_data !== null) {\n        writer.uint32(18);\n        writer.bytes(unique_name_data);\n      }\n\n      const unique_name_impacted = message.impacted;\n      if (unique_name_impacted.length !== 0) {\n        for (let i = 0; i < unique_name_impacted.length; ++i) {\n          writer.uint32(26);\n          writer.bytes(unique_name_impacted[i]);\n        }\n      }\n    }\n\n    static decode(reader: Reader, length: i32): event_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new event_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.name = reader.string();\n            break;\n\n          case 2:\n            message.data = reader.bytes();\n            break;\n\n          case 3:\n            message.impacted.push(reader.bytes());\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    name: string | null;\n    data: Uint8Array | null;\n    impacted: Array<Uint8Array>;\n\n    constructor(\n      name: string | null = null,\n      data: Uint8Array | null = null,\n      impacted: Array<Uint8Array> = []\n    ) {\n      this.name = name;\n      this.data = data;\n      this.impacted = impacted;\n    }\n  }\n\n  @unmanaged\n  export class event_result {\n    static encode(message: event_result, writer: Writer): void {}\n\n    static decode(reader: Reader, length: i32): event_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new event_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    constructor() {}\n  }\n\n  export class hash_arguments {\n    static encode(message: hash_arguments, writer: Writer): void {\n      if (message.code != 0) {\n        writer.uint32(8);\n        writer.uint64(message.code);\n      }\n\n      const unique_name_obj = message.obj;\n      if (unique_name_obj !== null) {\n        writer.uint32(18);\n        writer.bytes(unique_name_obj);\n      }\n\n      if (message.size != 0) {\n        writer.uint32(24);\n        writer.uint64(message.size);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): hash_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new hash_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.code = reader.uint64();\n            break;\n\n          case 2:\n            message.obj = reader.bytes();\n            break;\n\n          case 3:\n            message.size = reader.uint64();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    code: u64;\n    obj: Uint8Array | null;\n    size: u64;\n\n    constructor(code: u64 = 0, obj: Uint8Array | null = null, size: u64 = 0) {\n      this.code = code;\n      this.obj = obj;\n      this.size = size;\n    }\n  }\n\n  export class hash_result {\n    static encode(message: hash_result, writer: Writer): void {\n      const unique_name_value = message.value;\n      if (unique_name_value !== null) {\n        writer.uint32(10);\n        writer.bytes(unique_name_value);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): hash_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new hash_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.value = reader.bytes();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    value: Uint8Array | null;\n\n    constructor(value: Uint8Array | null = null) {\n      this.value = value;\n    }\n  }\n\n  export class recover_public_key_arguments {\n    static encode(message: recover_public_key_arguments, writer: Writer): void {\n      if (message.type != 0) {\n        writer.uint32(8);\n        writer.int32(message.type);\n      }\n\n      const unique_name_signature = message.signature;\n      if (unique_name_signature !== null) {\n        writer.uint32(18);\n        writer.bytes(unique_name_signature);\n      }\n\n      const unique_name_digest = message.digest;\n      if (unique_name_digest !== null) {\n        writer.uint32(26);\n        writer.bytes(unique_name_digest);\n      }\n\n      if (message.compressed != false) {\n        writer.uint32(32);\n        writer.bool(message.compressed);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): recover_public_key_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new recover_public_key_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.type = reader.int32();\n            break;\n\n          case 2:\n            message.signature = reader.bytes();\n            break;\n\n          case 3:\n            message.digest = reader.bytes();\n            break;\n\n          case 4:\n            message.compressed = reader.bool();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    type: chain.dsa;\n    signature: Uint8Array | null;\n    digest: Uint8Array | null;\n    compressed: bool;\n\n    constructor(\n      type: chain.dsa = 0,\n      signature: Uint8Array | null = null,\n      digest: Uint8Array | null = null,\n      compressed: bool = false\n    ) {\n      this.type = type;\n      this.signature = signature;\n      this.digest = digest;\n      this.compressed = compressed;\n    }\n  }\n\n  export class recover_public_key_result {\n    static encode(message: recover_public_key_result, writer: Writer): void {\n      const unique_name_value = message.value;\n      if (unique_name_value !== null) {\n        writer.uint32(10);\n        writer.bytes(unique_name_value);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): recover_public_key_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new recover_public_key_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.value = reader.bytes();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    value: Uint8Array | null;\n\n    constructor(value: Uint8Array | null = null) {\n      this.value = value;\n    }\n  }\n\n  export class verify_merkle_root_arguments {\n    static encode(message: verify_merkle_root_arguments, writer: Writer): void {\n      const unique_name_root = message.root;\n      if (unique_name_root !== null) {\n        writer.uint32(10);\n        writer.bytes(unique_name_root);\n      }\n\n      const unique_name_hashes = message.hashes;\n      if (unique_name_hashes.length !== 0) {\n        for (let i = 0; i < unique_name_hashes.length; ++i) {\n          writer.uint32(18);\n          writer.bytes(unique_name_hashes[i]);\n        }\n      }\n    }\n\n    static decode(reader: Reader, length: i32): verify_merkle_root_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new verify_merkle_root_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.root = reader.bytes();\n            break;\n\n          case 2:\n            message.hashes.push(reader.bytes());\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    root: Uint8Array | null;\n    hashes: Array<Uint8Array>;\n\n    constructor(\n      root: Uint8Array | null = null,\n      hashes: Array<Uint8Array> = []\n    ) {\n      this.root = root;\n      this.hashes = hashes;\n    }\n  }\n\n  @unmanaged\n  export class verify_merkle_root_result {\n    static encode(message: verify_merkle_root_result, writer: Writer): void {\n      if (message.value != false) {\n        writer.uint32(8);\n        writer.bool(message.value);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): verify_merkle_root_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new verify_merkle_root_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.value = reader.bool();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    value: bool;\n\n    constructor(value: bool = false) {\n      this.value = value;\n    }\n  }\n\n  export class verify_signature_arguments {\n    static encode(message: verify_signature_arguments, writer: Writer): void {\n      if (message.type != 0) {\n        writer.uint32(8);\n        writer.int32(message.type);\n      }\n\n      const unique_name_public_key = message.public_key;\n      if (unique_name_public_key !== null) {\n        writer.uint32(18);\n        writer.bytes(unique_name_public_key);\n      }\n\n      const unique_name_signature = message.signature;\n      if (unique_name_signature !== null) {\n        writer.uint32(26);\n        writer.bytes(unique_name_signature);\n      }\n\n      const unique_name_digest = message.digest;\n      if (unique_name_digest !== null) {\n        writer.uint32(34);\n        writer.bytes(unique_name_digest);\n      }\n\n      if (message.compressed != false) {\n        writer.uint32(40);\n        writer.bool(message.compressed);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): verify_signature_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new verify_signature_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.type = reader.int32();\n            break;\n\n          case 2:\n            message.public_key = reader.bytes();\n            break;\n\n          case 3:\n            message.signature = reader.bytes();\n            break;\n\n          case 4:\n            message.digest = reader.bytes();\n            break;\n\n          case 5:\n            message.compressed = reader.bool();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    type: chain.dsa;\n    public_key: Uint8Array | null;\n    signature: Uint8Array | null;\n    digest: Uint8Array | null;\n    compressed: bool;\n\n    constructor(\n      type: chain.dsa = 0,\n      public_key: Uint8Array | null = null,\n      signature: Uint8Array | null = null,\n      digest: Uint8Array | null = null,\n      compressed: bool = false\n    ) {\n      this.type = type;\n      this.public_key = public_key;\n      this.signature = signature;\n      this.digest = digest;\n      this.compressed = compressed;\n    }\n  }\n\n  @unmanaged\n  export class verify_signature_result {\n    static encode(message: verify_signature_result, writer: Writer): void {\n      if (message.value != false) {\n        writer.uint32(8);\n        writer.bool(message.value);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): verify_signature_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new verify_signature_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.value = reader.bool();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    value: bool;\n\n    constructor(value: bool = false) {\n      this.value = value;\n    }\n  }\n\n  export class verify_vrf_proof_arguments {\n    static encode(message: verify_vrf_proof_arguments, writer: Writer): void {\n      if (message.type != 0) {\n        writer.uint32(8);\n        writer.int32(message.type);\n      }\n\n      const unique_name_public_key = message.public_key;\n      if (unique_name_public_key !== null) {\n        writer.uint32(18);\n        writer.bytes(unique_name_public_key);\n      }\n\n      const unique_name_proof = message.proof;\n      if (unique_name_proof !== null) {\n        writer.uint32(26);\n        writer.bytes(unique_name_proof);\n      }\n\n      const unique_name_hash = message.hash;\n      if (unique_name_hash !== null) {\n        writer.uint32(34);\n        writer.bytes(unique_name_hash);\n      }\n\n      const unique_name_message_2 = message.message;\n      if (unique_name_message_2 !== null) {\n        writer.uint32(42);\n        writer.bytes(unique_name_message_2);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): verify_vrf_proof_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new verify_vrf_proof_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.type = reader.int32();\n            break;\n\n          case 2:\n            message.public_key = reader.bytes();\n            break;\n\n          case 3:\n            message.proof = reader.bytes();\n            break;\n\n          case 4:\n            message.hash = reader.bytes();\n            break;\n\n          case 5:\n            message.message = reader.bytes();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    type: chain.dsa;\n    public_key: Uint8Array | null;\n    proof: Uint8Array | null;\n    hash: Uint8Array | null;\n    message: Uint8Array | null;\n\n    constructor(\n      type: chain.dsa = 0,\n      public_key: Uint8Array | null = null,\n      proof: Uint8Array | null = null,\n      hash: Uint8Array | null = null,\n      message: Uint8Array | null = null\n    ) {\n      this.type = type;\n      this.public_key = public_key;\n      this.proof = proof;\n      this.hash = hash;\n      this.message = message;\n    }\n  }\n\n  @unmanaged\n  export class verify_vrf_proof_result {\n    static encode(message: verify_vrf_proof_result, writer: Writer): void {\n      if (message.value != false) {\n        writer.uint32(8);\n        writer.bool(message.value);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): verify_vrf_proof_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new verify_vrf_proof_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.value = reader.bool();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    value: bool;\n\n    constructor(value: bool = false) {\n      this.value = value;\n    }\n  }\n\n  export class call_arguments {\n    static encode(message: call_arguments, writer: Writer): void {\n      const unique_name_contract_id = message.contract_id;\n      if (unique_name_contract_id !== null) {\n        writer.uint32(10);\n        writer.bytes(unique_name_contract_id);\n      }\n\n      if (message.entry_point != 0) {\n        writer.uint32(16);\n        writer.uint32(message.entry_point);\n      }\n\n      const unique_name_args = message.args;\n      if (unique_name_args !== null) {\n        writer.uint32(26);\n        writer.bytes(unique_name_args);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): call_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new call_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.contract_id = reader.bytes();\n            break;\n\n          case 2:\n            message.entry_point = reader.uint32();\n            break;\n\n          case 3:\n            message.args = reader.bytes();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    contract_id: Uint8Array | null;\n    entry_point: u32;\n    args: Uint8Array | null;\n\n    constructor(\n      contract_id: Uint8Array | null = null,\n      entry_point: u32 = 0,\n      args: Uint8Array | null = null\n    ) {\n      this.contract_id = contract_id;\n      this.entry_point = entry_point;\n      this.args = args;\n    }\n  }\n\n  export class call_result {\n    static encode(message: call_result, writer: Writer): void {\n      const unique_name_value = message.value;\n      if (unique_name_value !== null) {\n        writer.uint32(10);\n        writer.bytes(unique_name_value);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): call_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new call_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.value = reader.bytes();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    value: Uint8Array | null;\n\n    constructor(value: Uint8Array | null = null) {\n      this.value = value;\n    }\n  }\n\n  @unmanaged\n  export class get_arguments_arguments {\n    static encode(message: get_arguments_arguments, writer: Writer): void {}\n\n    static decode(reader: Reader, length: i32): get_arguments_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new get_arguments_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    constructor() {}\n  }\n\n  export class get_arguments_result {\n    static encode(message: get_arguments_result, writer: Writer): void {\n      const unique_name_value = message.value;\n      if (unique_name_value !== null) {\n        writer.uint32(10);\n        writer.fork();\n        chain.argument_data.encode(unique_name_value, writer);\n        writer.ldelim();\n      }\n    }\n\n    static decode(reader: Reader, length: i32): get_arguments_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new get_arguments_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.value = chain.argument_data.decode(reader, reader.uint32());\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    value: chain.argument_data | null;\n\n    constructor(value: chain.argument_data | null = null) {\n      this.value = value;\n    }\n  }\n\n  export class exit_arguments {\n    static encode(message: exit_arguments, writer: Writer): void {\n      if (message.code != 0) {\n        writer.uint32(8);\n        writer.int32(message.code);\n      }\n\n      const unique_name_res = message.res;\n      if (unique_name_res !== null) {\n        writer.uint32(18);\n        writer.fork();\n        chain.result.encode(unique_name_res, writer);\n        writer.ldelim();\n      }\n    }\n\n    static decode(reader: Reader, length: i32): exit_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new exit_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.code = reader.int32();\n            break;\n\n          case 2:\n            message.res = chain.result.decode(reader, reader.uint32());\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    code: i32;\n    res: chain.result | null;\n\n    constructor(code: i32 = 0, res: chain.result | null = null) {\n      this.code = code;\n      this.res = res;\n    }\n  }\n\n  @unmanaged\n  export class exit_result {\n    static encode(message: exit_result, writer: Writer): void {}\n\n    static decode(reader: Reader, length: i32): exit_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new exit_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    constructor() {}\n  }\n\n  @unmanaged\n  export class get_contract_id_arguments {\n    static encode(message: get_contract_id_arguments, writer: Writer): void {}\n\n    static decode(reader: Reader, length: i32): get_contract_id_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new get_contract_id_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    constructor() {}\n  }\n\n  export class get_contract_id_result {\n    static encode(message: get_contract_id_result, writer: Writer): void {\n      const unique_name_value = message.value;\n      if (unique_name_value !== null) {\n        writer.uint32(10);\n        writer.bytes(unique_name_value);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): get_contract_id_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new get_contract_id_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.value = reader.bytes();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    value: Uint8Array | null;\n\n    constructor(value: Uint8Array | null = null) {\n      this.value = value;\n    }\n  }\n\n  @unmanaged\n  export class get_caller_arguments {\n    static encode(message: get_caller_arguments, writer: Writer): void {}\n\n    static decode(reader: Reader, length: i32): get_caller_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new get_caller_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    constructor() {}\n  }\n\n  export class get_caller_result {\n    static encode(message: get_caller_result, writer: Writer): void {\n      const unique_name_value = message.value;\n      if (unique_name_value !== null) {\n        writer.uint32(10);\n        writer.fork();\n        chain.caller_data.encode(unique_name_value, writer);\n        writer.ldelim();\n      }\n    }\n\n    static decode(reader: Reader, length: i32): get_caller_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new get_caller_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.value = chain.caller_data.decode(reader, reader.uint32());\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    value: chain.caller_data | null;\n\n    constructor(value: chain.caller_data | null = null) {\n      this.value = value;\n    }\n  }\n\n  export class check_authority_arguments {\n    static encode(message: check_authority_arguments, writer: Writer): void {\n      if (message.type != 0) {\n        writer.uint32(8);\n        writer.int32(message.type);\n      }\n\n      const unique_name_account = message.account;\n      if (unique_name_account !== null) {\n        writer.uint32(18);\n        writer.bytes(unique_name_account);\n      }\n\n      const unique_name_data = message.data;\n      if (unique_name_data !== null) {\n        writer.uint32(26);\n        writer.bytes(unique_name_data);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): check_authority_arguments {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new check_authority_arguments();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.type = reader.int32();\n            break;\n\n          case 2:\n            message.account = reader.bytes();\n            break;\n\n          case 3:\n            message.data = reader.bytes();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    type: authority.authorization_type;\n    account: Uint8Array | null;\n    data: Uint8Array | null;\n\n    constructor(\n      type: authority.authorization_type = 0,\n      account: Uint8Array | null = null,\n      data: Uint8Array | null = null\n    ) {\n      this.type = type;\n      this.account = account;\n      this.data = data;\n    }\n  }\n\n  @unmanaged\n  export class check_authority_result {\n    static encode(message: check_authority_result, writer: Writer): void {\n      if (message.value != false) {\n        writer.uint32(8);\n        writer.bool(message.value);\n      }\n    }\n\n    static decode(reader: Reader, length: i32): check_authority_result {\n      const end: usize = length < 0 ? reader.end : reader.ptr + length;\n      const message = new check_authority_result();\n\n      while (reader.ptr < end) {\n        const tag = reader.uint32();\n        switch (tag >>> 3) {\n          case 1:\n            message.value = reader.bool();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    }\n\n    value: bool;\n\n    constructor(value: bool = false) {\n      this.value = value;\n    }\n  }\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { BLOCK_MAXSIZE } from \"./rt/common\";\nimport { Runtime } from \"shared/runtime\";\nimport { COMPARATOR, SORT } from \"./util/sort\";\nimport { REVERSE } from \"./util/bytes\";\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from \"./util/string\";\nimport { idof, isArray as builtin_isArray } from \"./builtins\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_ILLEGALGENTYPE, E_EMPTYARRAY, E_HOLEYARRAY } from \"./util/error\";\n\n// @ts-ignore: decorator\n@inline @lazy const MIN_SIZE: usize = 8;\n\n/** Ensures that the given array has _at least_ the specified backing size. */\nfunction ensureCapacity(array: usize, newSize: usize, alignLog2: u32, canGrow: bool = true): void {\n  // Depends on the fact that Arrays mimic ArrayBufferView\n  var oldCapacity = <usize>changetype<ArrayBufferView>(array).byteLength;\n  if (newSize > oldCapacity >>> alignLog2) {\n    if (newSize > BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    let oldData = changetype<usize>(changetype<ArrayBufferView>(array).buffer);\n    // Grows old capacity by factor of two.\n    // Make sure we don't reach BLOCK_MAXSIZE for new growed capacity.\n    let newCapacity = max(newSize, MIN_SIZE) << alignLog2;\n    if (canGrow) newCapacity = max(min(oldCapacity << 1, BLOCK_MAXSIZE), newCapacity);\n    let newData = __renew(oldData, newCapacity);\n    // __new / __renew already init memory range as zeros in Incremental runtime.\n    // So try to avoid this.\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(newData + oldCapacity, 0, newCapacity - oldCapacity);\n    }\n    if (newData !== oldData) { // oldData has been free'd\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\"buffer\"));\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\"dataStart\"));\n      __link(array, changetype<usize>(newData), false);\n    }\n    store<u32>(array, <u32>newCapacity, offsetof<ArrayBufferView>(\"byteLength\"));\n  }\n}\n\nexport class Array<T> {\n  [key: number]: T;\n\n  // Mimicking ArrayBufferView isn't strictly necessary here but is done to allow glue code\n  // to work with typed and normal arrays interchangeably. Technically, normal arrays do not need\n  // `dataStart` (equals `buffer`) and `byteLength` (equals computed `buffer.byteLength`), but the\n  // block is 16 bytes anyway so it's fine to have a couple extra fields in there.\n\n  private buffer: ArrayBuffer;\n  @unsafe readonly dataStart: usize;\n  private byteLength: i32; // Uses here as capacity\n\n  // Also note that Array<T> with non-nullable T must guard against uninitialized null values\n  // whenever an element is accessed. Otherwise, the compiler wouldn't be able to guarantee\n  // type-safety anymore. For lack of a better word, such an array is \"holey\".\n\n  private length_: i32;\n\n  static isArray<U>(value: U): bool {\n    return isReference<U>() ? builtin_isArray(value) && value !== null : false;\n  }\n\n  static create<T>(capacity: i32 = 0): Array<T> {\n    WARNING(\"'Array.create' is deprecated. Use 'new Array' instead, making sure initial elements are initialized.\");\n    var array = new Array<T>(capacity);\n    array.length = 0;\n    return array;\n  }\n\n  constructor(length: i32 = 0) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);\n    // reserve capacity for at least MIN_SIZE elements\n    var bufferSize = max(<usize>length, MIN_SIZE) << alignof<T>();\n    var buffer = changetype<ArrayBuffer>(__new(bufferSize, idof<ArrayBuffer>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(buffer), 0, bufferSize);\n    }\n    this.buffer = buffer; // links\n    this.dataStart = changetype<usize>(buffer);\n    this.byteLength = <i32>bufferSize;\n    this.length_ = length;\n  }\n\n  get length(): i32 {\n    return this.length_;\n  }\n\n  set length(newLength: i32) {\n    ensureCapacity(changetype<usize>(this), newLength, alignof<T>(), false);\n    this.length_ = newLength;\n  }\n\n  every(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (!fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return false;\n    }\n    return true;\n  }\n\n  findIndex(fn: (value: T, index: i32, array: Array<T>) => bool): i32 {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  findLastIndex(fn: (value: T, index: i32, array: Array<T>) => bool): i32 {\n    for (let i = this.length_ - 1; i >= 0; --i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  @operator(\"[]\") private __get(index: i32): T {\n    if (<u32>index >= <u32>this.length_) throw new RangeError(E_INDEXOUTOFRANGE);\n    var value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @unsafe @operator(\"{}\") private __uget(index: i32): T {\n    return load<T>(this.dataStart + (<usize>index << alignof<T>()));\n  }\n\n  @operator(\"[]=\") private __set(index: i32, value: T): void {\n    if (<u32>index >= <u32>this.length_) {\n      if (index < 0) throw new RangeError(E_INDEXOUTOFRANGE);\n      ensureCapacity(changetype<usize>(this), index + 1, alignof<T>());\n      this.length_ = index + 1;\n    }\n    this.__uset(index, value);\n  }\n\n  @unsafe @operator(\"{}=\") private __uset(index: i32, value: T): void {\n    store<T>(this.dataStart + (<usize>index << alignof<T>()), value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n  }\n\n  at(index: i32): T {\n    var len = this.length_;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    var value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): this {\n    var ptr = this.dataStart;\n    var len = this.length_;\n    start = start < 0 ? max(len + start, 0) : min(start, len);\n    end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n    if (isManaged<T>()) {\n      for (; start < end; ++start) {\n        store<usize>(ptr + (<usize>start << alignof<T>()), changetype<usize>(value));\n        __link(changetype<usize>(this), changetype<usize>(value), true);\n      }\n    } else if (sizeof<T>() == 1) {\n      if (start < end) {\n        memory.fill(\n          ptr + <usize>start,\n          u8(value),\n          <usize>(end - start)\n        );\n      }\n    } else {\n      for (; start < end; ++start) {\n        store<T>(ptr + (<usize>start << alignof<T>()), value);\n      }\n    }\n    return this;\n  }\n\n  includes(value: T, fromIndex: i32 = 0): bool {\n    if (isFloat<T>()) {\n      let len = this.length_;\n      if (len == 0 || fromIndex >= len) return false;\n      if (fromIndex < 0) fromIndex = max(len + fromIndex, 0);\n      let ptr = this.dataStart;\n      while (fromIndex < len) {\n        let elem = load<T>(ptr + (<usize>fromIndex << alignof<T>()));\n        // @ts-ignore\n        if (elem == value || isNaN(elem) & isNaN(value)) return true;\n        ++fromIndex;\n      }\n      return false;\n    } else {\n      return this.indexOf(value, fromIndex) >= 0;\n    }\n  }\n\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\n    var len = this.length_;\n    if (len == 0 || fromIndex >= len) return -1;\n    if (fromIndex < 0) fromIndex = max(len + fromIndex, 0);\n    var ptr = this.dataStart;\n    while (fromIndex < len) {\n      if (load<T>(ptr + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(value: T, fromIndex: i32 = this.length_): i32 {\n    var len = this.length_;\n    if (len == 0) return -1;\n    if (fromIndex < 0) fromIndex = len + fromIndex;\n    else if (fromIndex >= len) fromIndex = len - 1;\n    var ptr = this.dataStart;\n    while (fromIndex >= 0) {\n      if (load<T>(ptr + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  push(value: T): i32 {\n    var oldLen = this.length_;\n    var len = oldLen + 1;\n    ensureCapacity(changetype<usize>(this), len, alignof<T>());\n    if (isManaged<T>()) {\n      store<usize>(this.dataStart + (<usize>oldLen << alignof<T>()), changetype<usize>(value));\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    } else {\n      store<T>(this.dataStart + (<usize>oldLen << alignof<T>()), value);\n    }\n    this.length_ = len;\n    return len;\n  }\n\n  concat(other: Array<T>): Array<T> {\n    var thisLen = this.length_;\n    var otherLen = select(0, other.length_, other === null);\n    var outLen = thisLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);\n    var out = changetype<Array<T>>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));\n    var outStart = out.dataStart;\n    var thisSize = <usize>thisLen << alignof<T>();\n    if (isManaged<T>()) {\n      let thisStart = this.dataStart;\n      for (let offset: usize = 0; offset < thisSize; offset += sizeof<T>()) {\n        let ref = load<usize>(thisStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n      outStart += thisSize;\n      let otherStart = other.dataStart;\n      let otherSize = <usize>otherLen << alignof<T>();\n      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n        let ref = load<usize>(otherStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(outStart, this.dataStart, thisSize);\n      memory.copy(outStart + thisSize, other.dataStart, <usize>otherLen << alignof<T>());\n    }\n    return out;\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): this {\n    var ptr = this.dataStart;\n    var len = this.length_;\n\n    end = min<i32>(end, len);\n\n    var to    = target < 0 ? max(len + target, 0) : min(target, len);\n    var from  = start < 0 ? max(len + start, 0) : min(start, len);\n    var last  = end < 0 ? max(len + end, 0) : min(end, len);\n    var count = min(last - from, len - to);\n\n    memory.copy( // is memmove\n      ptr + (<usize>to << alignof<T>()),\n      ptr + (<usize>from << alignof<T>()),\n      <usize>count << alignof<T>()\n    );\n    return this;\n  }\n\n  pop(): T {\n    var len = this.length_;\n    if (len < 1) throw new RangeError(E_EMPTYARRAY);\n    var val = load<T>(this.dataStart + (<usize>(--len) << alignof<T>()));\n    this.length_ = len;\n    return val;\n  }\n\n  forEach(fn: (value: T, index: i32, array: Array<T>) => void): void {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n  }\n\n  map<U>(fn: (value: T, index: i32, array: Array<T>) => U): Array<U> {\n    var len = this.length_;\n    var out = changetype<Array<U>>(__newArray(len, alignof<U>(), idof<Array<U>>()));\n    var outStart = out.dataStart;\n    for (let i = 0; i < min(len, this.length_); ++i) {\n      let result = fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n      store<U>(outStart + (<usize>i << alignof<U>()), result);\n      if (isManaged<U>()) {\n        __link(changetype<usize>(out), changetype<usize>(result), true);\n      }\n    }\n    return out;\n  }\n\n  filter(fn: (value: T, index: i32, array: Array<T>) => bool): Array<T> {\n    var result = changetype<Array<T>>(__newArray(0, alignof<T>(), idof<Array<T>>()));\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      let value = load<T>(this.dataStart + (<usize>i << alignof<T>()));\n      if (fn(value, i, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    var acc = initialValue;\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      acc = fn(acc, load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  reduceRight<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    var acc = initialValue;\n    for (let i = this.length_ - 1; i >= 0; --i) {\n      acc = fn(acc, load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  shift(): T {\n    var len = this.length_;\n    if (len < 1) throw new RangeError(E_EMPTYARRAY);\n    var base = this.dataStart;\n    var element = load<T>(base);\n    var lastIndex = len - 1;\n    memory.copy(\n      base,\n      base + sizeof<T>(),\n      <usize>lastIndex << alignof<T>()\n    );\n    if (isReference<T>()) {\n      store<usize>(base + (<usize>lastIndex << alignof<T>()), 0);\n    } else {\n      // @ts-ignore\n      store<T>(base + (<usize>lastIndex << alignof<T>()), <T>0);\n    }\n    this.length_ = lastIndex;\n    return element;\n  }\n\n  some(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return true;\n    }\n    return false;\n  }\n\n  unshift(value: T): i32 {\n    var len = this.length_ + 1;\n    ensureCapacity(changetype<usize>(this), len, alignof<T>());\n    var ptr = this.dataStart;\n    memory.copy(\n      ptr + sizeof<T>(),\n      ptr,\n      <usize>(len - 1) << alignof<T>()\n    );\n    store<T>(ptr, value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n    this.length_ = len;\n    return len;\n  }\n\n  slice(start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    var len = this.length_;\n    start = start < 0 ? max(start + len, 0) : min(start, len);\n    end   = end   < 0 ? max(end   + len, 0) : min(end  , len);\n    len = max(end - start, 0);\n    var slice = changetype<Array<T>>(__newArray(len, alignof<T>(), idof<Array<T>>()));\n    var sliceBase = slice.dataStart;\n    var thisBase = this.dataStart + (<usize>start << alignof<T>());\n    if (isManaged<T>()) {\n      let off = <usize>0;\n      let end = <usize>len << alignof<usize>();\n      while (off < end) {\n        let ref = load<usize>(thisBase + off);\n        store<usize>(sliceBase + off, ref);\n        __link(changetype<usize>(slice), ref, true);\n        off += sizeof<usize>();\n      }\n    } else {\n      memory.copy(sliceBase, thisBase, len << alignof<T>());\n    }\n    return slice;\n  }\n\n  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): Array<T> {\n    var len = this.length_;\n    start       = start < 0 ? max<i32>(len + start, 0) : min<i32>(start, len);\n    deleteCount = max<i32>(min<i32>(deleteCount, len - start), 0);\n    var result  = changetype<Array<T>>(__newArray(deleteCount, alignof<T>(), idof<Array<T>>()));\n    var resultStart = result.dataStart;\n    var thisStart = this.dataStart;\n    var thisBase  = thisStart + (<usize>start << alignof<T>());\n    memory.copy(\n      resultStart,\n      thisBase,\n      <usize>deleteCount << alignof<T>()\n    );\n    var offset = start + deleteCount;\n    if (len != offset) {\n      memory.copy(\n        thisBase,\n        thisStart + (<usize>offset << alignof<T>()),\n        <usize>(len - offset) << alignof<T>()\n      );\n    }\n    this.length_ = len - deleteCount;\n    return result;\n  }\n\n  reverse(): this {\n    REVERSE<T>(this.dataStart, this.length_);\n    return this;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): this {\n    SORT<T>(this.dataStart, this.length_, comparator);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    var ptr = this.dataStart;\n    var len = this.length_;\n    if (isBoolean<T>())   return joinBooleanArray(ptr, len, separator);\n    if (isInteger<T>())   return joinIntegerArray<T>(ptr, len, separator);\n    if (isFloat<T>())     return joinFloatArray<T>(ptr, len, separator);\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (isString<T>())  return joinStringArray(ptr, len, separator);\n    }\n    // For rest objects and arrays use general join routine\n    if (isReference<T>()) return joinReferenceArray<T>(ptr, len, separator);\n    ERROR(\"unspported element type\");\n    return <string>unreachable();\n  }\n\n  flat(): T {\n    if (!isArray<T>()) {\n      throw new TypeError(E_ILLEGALGENTYPE);\n    }\n    // Get the length and data start values\n    var ptr = this.dataStart;\n    var len = this.length_;\n\n    // calculate the end size with an initial pass\n    var size = 0;\n    for (let i = 0; i < len; ++i) {\n      let child = load<usize>(ptr + (i << alignof<T>()));\n      size += child == 0 ? 0 : load<i32>(child, offsetof<T>(\"length_\"));\n    }\n\n    // calculate the byteLength of the resulting backing ArrayBuffer\n    const align = alignof<valueof<T>>();\n    var byteLength = <usize>size << align;\n    var outBuffer = changetype<ArrayBuffer>(__new(byteLength, idof<ArrayBuffer>()));\n\n    // create the return value and initialize it\n    var outArray = changetype<T>(__new(offsetof<T>(), idof<T>()));\n    store<i32>(changetype<usize>(outArray), size, offsetof<T>(\"length_\"));\n\n    // byteLength, dataStart, and buffer are all readonly\n    store<i32>(changetype<usize>(outArray), byteLength, offsetof<T>(\"byteLength\"));\n    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>(\"dataStart\"));\n    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>(\"buffer\"));\n    __link(changetype<usize>(outArray), changetype<usize>(outBuffer), false);\n\n    // set the elements\n    var resultOffset: usize = 0;\n    for (let i = 0; i < len; ++i) { // for each child\n      let child = load<usize>(ptr + (<usize>i << alignof<T>()));\n\n      // ignore null arrays\n      if (!child) continue;\n\n      // copy the underlying buffer data to the result buffer\n      let childDataLength = <usize>load<i32>(child, offsetof<T>(\"length_\")) << align;\n      memory.copy(\n        changetype<usize>(outBuffer) + resultOffset,\n        load<usize>(child, offsetof<T>(\"dataStart\")),\n        childDataLength\n      );\n\n      // advance the result length\n      resultOffset += childDataLength;\n    }\n\n    // if the `valueof<T>` type is managed, we must link each reference\n    if (isManaged<valueof<T>>()) {\n      for (let i = 0; i < size; ++i) {\n        let ref = load<usize>(changetype<usize>(outBuffer) + (<usize>i << usize(alignof<valueof<T>>())));\n        __link(changetype<usize>(outBuffer), ref, true);\n      }\n    }\n\n    return outArray;\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    if (isManaged<T>()) {\n      let cur = this.dataStart;\n      let end = cur + (<usize>this.length_ << alignof<T>());\n      while (cur < end) {\n        let val = load<usize>(cur);\n        if (val) __visit(val, cookie);\n        cur += sizeof<usize>();\n      }\n    }\n    __visit(changetype<usize>(this.buffer), cookie);\n  }\n}\n","import {\n  args_get,\n  args_sizes_get,\n  environ_get,\n  environ_sizes_get,\n  proc_exit,\n  fd_write,\n  fd_close,\n  fd_read,\n  clock_time_get,\n  clockid,\n  errnoToString,\n  fd,\n  tempbuf\n} from \"bindings/wasi\";\n\nimport {\n  E_INDEXOUTOFRANGE\n} from \"util/error\";\n\nexport namespace process {\n\n  // @ts-ignore: decorator\n  @lazy export const arch = sizeof<usize>() == 4 ? \"wasm32\" : \"wasm64\";\n\n  // @ts-ignore: decorator\n  @lazy export const platform = \"wasm\";\n\n  // @ts-ignore: decorator\n  @lazy export const argv = lazyArgv();\n\n  // @ts-ignore: decorator\n  @lazy export const env = lazyEnv();\n\n  // @ts-ignore: decorator\n  @lazy export var exitCode = 0;\n\n  export function exit(code: i32 = exitCode): void {\n    proc_exit(code);\n  }\n\n  // @ts-ignore: decorator\n  @lazy export const stdin = changetype<ReadableStream>(0);\n  // @ts-ignore: decorator\n  @lazy export const stdout = changetype<WritableStream>(1);\n  // @ts-ignore: decorator\n  @lazy export const stderr = changetype<WritableStream>(2);\n\n  export function time(): i64 {\n    var err = clock_time_get(clockid.REALTIME, 1000000, tempbuf);\n    if (err) throw new Error(errnoToString(err));\n    return load<u64>(tempbuf) / 1000000;\n  }\n\n  export function hrtime(): u64 {\n    var err = clock_time_get(clockid.MONOTONIC, 0, tempbuf);\n    if (err) throw new Error(errnoToString(err));\n    return load<u64>(tempbuf);\n  }\n}\n\nfunction lazyArgv(): string[] {\n  var err = args_sizes_get(tempbuf, tempbuf + sizeof<usize>());\n  if (err) throw new Error(errnoToString(err));\n  var count = load<usize>(tempbuf);\n  var ptrsSize = count * sizeof<usize>();\n  var dataSize = load<usize>(tempbuf, sizeof<usize>());\n  var bufSize = ptrsSize + dataSize;\n  var buf = __alloc(bufSize);\n  err = args_get(buf, buf + ptrsSize);\n  if (err) throw new Error(errnoToString(err));\n  var count32 = <i32>count;\n  var argv = new Array<string>(count32);\n  for (let i = 0; i < count32; ++i) {\n    let ptr = load<usize>(buf + i * sizeof<usize>());\n    let str = String.UTF8.decodeUnsafe(ptr, ptr + bufSize - buf, true);\n    argv[i] = str;\n  }\n  __free(buf);\n  return argv;\n}\n\nfunction lazyEnv(): Map<string,string> {\n  var err = environ_sizes_get(tempbuf, tempbuf + 4);\n  if (err) throw new Error(errnoToString(err));\n  var count = load<usize>(tempbuf);\n  var ptrsSize = count * sizeof<usize>();\n  var dataSize = load<usize>(tempbuf, sizeof<usize>());\n  var bufSize = ptrsSize + dataSize;\n  var buf = __alloc(bufSize);\n  err = environ_get(buf, buf + ptrsSize);\n  if (err) throw new Error(errnoToString(err));\n  var env = new Map<string,string>();\n  for (let i: usize = 0; i < count; ++i) {\n    let ptr = load<usize>(buf + i * sizeof<usize>());\n    let str = String.UTF8.decodeUnsafe(ptr, ptr + bufSize - buf, true);\n    let pos = str.indexOf(\"=\");\n    if (~pos) {\n      env.set(str.substring(0, pos), str.substring(pos + 1));\n      // __dispose(changetype<usize>(str));\n    } else {\n      env.set(str, \"\");\n    }\n  }\n  __free(buf);\n  return env;\n}\n\n@unmanaged\nabstract class Stream {\n  close(): void {\n    var err = fd_close(<u32>changetype<usize>(this));\n    if (err) throw new Error(errnoToString(err));\n  }\n}\n\n@unmanaged\nabstract class WritableStream extends Stream {\n  write<T>(data: T): void {\n    if (isString<T>()) {\n      writeString(<u32>changetype<usize>(this), changetype<string>(data));\n    } else if (data instanceof ArrayBuffer) {\n      writeBuffer(<u32>changetype<usize>(this), data);\n    } else {\n      ERROR(\"String or ArrayBuffer expected\");\n    }\n  }\n}\n\n@unmanaged\nabstract class ReadableStream extends Stream {\n  read(buffer: ArrayBuffer, offset: isize = 0): i32 {\n    var end = <usize>buffer.byteLength;\n    if (offset < 0 || <usize>offset > end) {\n      throw new Error(E_INDEXOUTOFRANGE);\n    }\n    store<usize>(tempbuf, changetype<usize>(buffer) + offset);\n    store<usize>(tempbuf, end - offset, sizeof<usize>());\n    var err = fd_read(<u32>changetype<usize>(this), tempbuf, 1, tempbuf + 2 * sizeof<usize>());\n    if (err) throw new Error(errnoToString(err));\n    return <i32>load<isize>(tempbuf, 2 * sizeof<usize>());\n  }\n}\n\nfunction writeBuffer(fd: fd, data: ArrayBuffer): void {\n  store<usize>(tempbuf, changetype<usize>(data));\n  store<usize>(tempbuf, data.byteLength, sizeof<usize>());\n  var err = fd_write(<u32>fd, tempbuf, 1, tempbuf + 2 * sizeof<usize>());\n  if (err) throw new Error(errnoToString(err));\n}\n\nfunction writeString(fd: fd, data: string): void {\n  var len = data.length;\n  var\n    char2: u32 = 0,\n    char3: u32 = 0,\n    char4: u32 = 0;\n  switch (len) {\n    case 4: { // \"null\"\n      char4 = <u32>load<u16>(changetype<usize>(data), 6);\n      if (char4 >= 0x80) break;\n    }\n    case 3: { // \"ms\\n\"\n      char3 = <u32>load<u16>(changetype<usize>(data), 4);\n      if (char3 >= 0x80) break;\n    }\n    case 2: { // \"\\r\\n\"\n      char2 = <u32>load<u16>(changetype<usize>(data), 2);\n      if (char2 >= 0x80) break;\n    }\n    case 1: { // \"\\n\"\n      let char1 = <u32>load<u16>(changetype<usize>(data));\n      if (char1 >= 0x80) break;\n      store<usize>(tempbuf, tempbuf + 2 * sizeof<usize>());\n      store<usize>(tempbuf, len, sizeof<usize>());\n      store<u32>(tempbuf, char1 | char2 << 8 | char3 << 16 | char4 << 24, 2 * sizeof<usize>());\n      let err = fd_write(<u32>fd, tempbuf, 1, tempbuf + 3 * sizeof<usize>());\n      if (err) throw new Error(errnoToString(err));\n    }\n    case 0: return;\n  }\n  var utf8len = <usize>String.UTF8.byteLength(data);\n  var utf8buf = __alloc(utf8len);\n  assert(String.UTF8.encodeUnsafe(changetype<usize>(data), len, utf8buf) == utf8len);\n  store<usize>(tempbuf, utf8buf);\n  store<usize>(tempbuf, utf8len, sizeof<usize>());\n  var err = fd_write(<u32>fd, tempbuf, 1, tempbuf + 2 * sizeof<usize>());\n  __free(utf8buf);\n  if (err) throw new Error(errnoToString(err));\n}\n","import {\n  process\n} from \"./process\";\n\n// @ts-ignore: decorator\n@lazy var timers = new Map<string,u64>();\n\nexport namespace console {\n\n  export function assert<T>(condition: T, message: string = \"\"): void {\n    if (!condition) {\n      let stderr = process.stderr;\n      stderr.write(\"Assertion failed: \");\n      stderr.write(message);\n      stderr.write(\"\\n\");\n    }\n  }\n\n  export function log(message: string = \"\"): void {\n    var stdout = process.stdout;\n    stdout.write(message);\n    stdout.write(\"\\n\");\n  }\n\n  export function debug(message: string = \"\"): void {\n    var stdout = process.stdout;\n    stdout.write(\"Debug: \");\n    stdout.write(message);\n    stdout.write(\"\\n\");\n  }\n\n  export function info(message: string = \"\"): void {\n    var stdout = process.stdout;\n    stdout.write(\"Info: \");\n    stdout.write(message);\n    stdout.write(\"\\n\");\n  }\n\n  export function warn(message: string = \"\"): void {\n    var stdout = process.stdout;\n    stdout.write(\"Warning: \");\n    stdout.write(message);\n    stdout.write(\"\\n\");\n  }\n\n  export function error(message: string = \"\"): void {\n    var stdout = process.stdout;\n    stdout.write(\"Error: \");\n    stdout.write(message);\n    stdout.write(\"\\n\");\n  }\n\n  export function time(label: string = \"default\"): void {\n    var stdout = process.stdout;\n    if (timers.has(label)) {\n      stdout.write(\"Warning: Label '\");\n      stdout.write(label);\n      stdout.write(\"' already exists for console.time()\\n\");\n      return;\n    }\n    timers.set(label, process.hrtime());\n  }\n\n  export function timeLog(label: string = \"default\"): void {\n    var stdout = process.stdout;\n    if (!timers.has(label)) {\n      stdout.write(\"Warning: No such label '\");\n      stdout.write(label);\n      stdout.write(\"' for console.timeLog()\\n\");\n      return;\n    }\n    timeLogImpl(label);\n  }\n\n  export function timeEnd(label: string = \"default\"): void {\n    var stdout = process.stdout;\n    if (!timers.has(label)) {\n      stdout.write(\"Warning: No such label '\");\n      stdout.write(label);\n      stdout.write(\"' for console.timeEnd()\\n\");\n      return;\n    }\n    timeLogImpl(label);\n    timers.delete(label);\n  }\n}\n\nfunction timeLogImpl(label: string): void {\n  var start = changetype<u64>(timers.get(label));\n  var end = process.hrtime();\n  var nanos = end - start;\n  var millis = nanos / 1000000;\n  var millisStr = millis.toString();\n  var stdout = process.stdout;\n  stdout.write(label);\n  stdout.write(\": \");\n  stdout.write(millisStr);\n  stdout.write(\"ms\\n\");\n  // __dispose(changetype<usize>(millisStr));\n}\n","export * from \"./wasi_snapshot_preview1\";\n\n// A WASI-wide reusable temporary buffer to store and work with out values. Must\n// be large enough to fit any operation it is used in, i.e. process/writeString.\n// @ts-ignore: decorator\n@lazy export const tempbuf = memory.data(4 * sizeof<usize>());\n","import { toIncludeComparison } from \"./comparison/toIncludeComparison\";\nimport { toIncludeEqualComparison } from \"./comparison/toIncludeEqualComparison\";\nimport { Actual } from \"./Actual\";\nimport { Expected } from \"./Expected\";\nimport { assert } from \"./assert\";\n\n// @ts-ignore: Decorators *are* valid here\n@external(\"__aspect\", \"tryCall\")\ndeclare function tryCall(func: () => void): bool;\n\n// @ts-ignore: Decorators *are* valid here\n@global\nexport class Expectation<T> {\n  /**\n   * This i32 is set to 1 if the expectation is negated. Using the _not (xor) condition assertion\n   * makes assertions very easy to write and understand.\n   */\n  _not: i32 = 0;\n\n  actual: T;\n\n  constructor(actual: T) {\n    this.actual = actual;\n  }\n\n  public get not(): Expectation<T> {\n    this._not = 1;\n    return this;\n  }\n\n  public toBe(expected: T, message: string = \"\"): void {\n    let actual = this.actual;\n    let equals = i32(actual == expected);\n    let negated = this._not;\n\n    Actual.report(actual);\n\n    if (isReference(actual) && !isFunction(actual)) {\n      if (\n        !negated &&\n        changetype<usize>(actual) !== 0 &&\n        changetype<usize>(expected) !== 0 &&\n        Reflect.equals(actual, expected) == Reflect.SUCCESSFUL_MATCH\n      ) {\n        Expected.report(\"Serializes to same value.\", 0);\n      } else {\n        Expected.report(expected, negated);\n      }\n    } else {\n      Expected.report(expected, negated);\n    }\n\n    // The assertion is either the items equal, or the expectation is negated\n    assert(equals ^ negated, message);\n    Actual.clear();\n    Expected.clear();\n  }\n\n  public toStrictEqual(expected: T, message: string = \"\"): void {\n    let result = Reflect.FAILED_MATCH;\n    result = Reflect.equals(this.actual, expected);\n\n    let equals = i32(result == Reflect.SUCCESSFUL_MATCH);\n    Actual.report(this.actual);\n    Expected.report(expected);\n\n    assert(equals ^ this._not, message);\n\n    Actual.clear();\n    Expected.clear();\n  }\n\n  // @as-covers: ignore because this function is deprecated\n  public toBlockEqual(expected: T, message: string = \"\"): void {\n    WARNING(\n      \"toBlockEqual has been deprecated and results in a toStrictEqual call.\",\n    );\n    this.toStrictEqual(expected, message);\n  }\n\n  public toBeTruthy(message: string = \"\"): void {\n    let actual = this.actual;\n    Actual.report(actual);\n    let negated = this._not;\n    Expected.reportTruthy(negated);\n\n    if (isReference(actual)) {\n      if (actual instanceof String) {\n        let truthy = i32(\n          changetype<usize>(actual) != 0 &&\n            changetype<string>(actual).length > 0,\n        );\n        assert(truthy ^ negated, message);\n      } else {\n        let truthy = i32(changetype<usize>(actual) != 0);\n        assert(truthy ^ negated, message);\n      }\n    } else {\n      if (isFloat(actual)) {\n        let truthy = i32(!isNaN(actual) && actual != 0.0);\n        assert(truthy ^ negated, message);\n      } else if (isInteger(actual)) {\n        let truthy = i32(actual != 0);\n        assert(truthy ^ negated, message);\n      }\n    }\n\n    Actual.clear();\n    Expected.clear();\n  }\n\n  public toBeFalsy(message: string = \"\"): void {\n    let actual = this.actual;\n    Actual.report(actual);\n    let negated = this._not;\n    Expected.reportFalsy(negated);\n\n    if (isReference(actual)) {\n      // strings require an extra length check\n      if (actual instanceof String) {\n        let falsy = i32(\n          changetype<usize>(actual) == 0 ||\n            changetype<string>(actual).length == 0,\n        );\n        assert(falsy ^ negated, message);\n      } else {\n        let falsy = i32(changetype<usize>(actual) == 0);\n        assert(falsy ^ negated, message);\n      }\n    } else {\n      if (isFloat(actual)) {\n        // @ts-ignore: actual is a float value\n        let falsy = i32(isNaN(actual) || actual == 0.0);\n        assert(falsy ^ negated, message);\n      } else if (isInteger(actual)) {\n        let falsy = i32(actual == 0);\n        assert(falsy ^ negated, message);\n      }\n    }\n\n    Actual.clear();\n    Expected.clear();\n  }\n\n  public toThrow(message: string = \"\"): void {\n    let actual = this.actual;\n    let negated = this._not;\n\n    if (!isFunction(this.actual))\n      // @as-covers: ignore because this is a compile time error\n      ERROR(\n      \"Expectation#toThrow assertion called on actual T where T is not a function reference\",\n      );\n    if (idof<T>() != idof<() => void>())\n      // @as-covers: ignore because this is a compile time error\n      ERROR(\n        \"Expectation#toThrow assertion called on actual T where T is not a function reference with signature () => void\",\n      );\n\n    // @ts-ignore: safe tryCall\n    let throws = i32(!tryCall(actual));\n    Actual.report(throws ? \"Throws\" : \"Not Throws\");\n    Expected.report(\"Throws\", negated);\n    assert(negated ^ throws, message);\n    Actual.clear();\n    Expected.clear();\n  }\n\n  public toBeGreaterThan(expected: T, message: string = \"\"): void {\n    let actual = this.actual;\n    let negated = this._not;\n    Actual.report(actual);\n    Expected.report(expected, negated);\n\n    if (!isDefined(actual > expected))\n      // @as-covers: ignore because this is a compile time error\n      ERROR(\n        \"Invalid call to toBeGreaterThan. Generic type T must have an operator implemented for the greaterThan (>) operation.\",\n      );\n\n    if (isReference(actual)) {\n      // Perform reference type null checks\n      assert(\n        i32(changetype<usize>(expected) != 0),\n        \"Value comparison fails, expected value is null.\",\n      );\n      assert(\n        i32(changetype<usize>(actual) != 0),\n        \"Value comparison fails, actual value is null.\",\n      );\n    }\n\n    // Compare float types\n    if (isFloat(actual)) {\n      assert(\n        i32(!isNaN(expected)),\n        \"Value comparison fails, expected value is NaN.\",\n      );\n      assert(\n        i32(!isNaN(actual)),\n        \"Value comparison fails, actual value is NaN.\",\n      );\n    }\n\n    // do actual greater than comparison\n    assert(negated ^ i32(actual > expected), message);\n    Actual.clear();\n    Expected.clear();\n  }\n\n  public toBeGreaterThanOrEqual(expected: T, message: string = \"\"): void {\n    let actual = this.actual;\n    let negated = this._not;\n\n    Actual.report(actual);\n    Expected.report(expected, negated);\n\n    if (!isDefined(actual >= expected))\n      // @as-covers: ignore because this is a compile time error\n      ERROR(\n        \"Invalid call to toBeGreaterThanOrEqual. Generic type T must have an operator implemented for the greaterThanOrEqual (>=) operation.\",\n      );\n\n    // null checks\n    if (isReference(actual)) {\n      assert(\n        i32(changetype<usize>(expected) != 0),\n        \"Value comparison fails, expected value is null.\",\n      );\n      assert(\n        i32(changetype<usize>(actual) != 0),\n        \"Value comparison fails, actual value is null.\",\n      );\n    }\n\n    // Compare float types\n    if (isFloat(actual)) {\n      assert(\n        i32(!isNaN(expected)),\n        \"Value comparison fails, expected value is NaN.\",\n      );\n      assert(\n        i32(!isNaN(actual)),\n        \"Value comparison fails, actual value is NaN.\",\n      );\n    }\n\n    // do actual greater than comparison\n    assert(negated ^ i32(actual >= expected), message);\n    Actual.clear();\n    Expected.clear();\n  }\n\n  public toBeLessThan(expected: T, message: string = \"\"): void {\n    let actual = this.actual;\n    let negated = this._not;\n    Actual.report(actual);\n    Expected.report(expected, negated);\n\n    if (!isDefined(actual < expected))\n      // @as-covers: ignore because this is a compile time error\n      ERROR(\n        \"Invalid call to toBeLessThan. Generic type T must have an operator implemented for the lessThan (<) operation.\",\n      );\n\n    // null checks\n    if (isReference(actual)) {\n      assert(\n        i32(changetype<usize>(expected) != 0),\n        \"Value comparison fails, expected value is null.\",\n      );\n      assert(\n        i32(changetype<usize>(actual) != 0),\n        \"Value comparison fails, actual value is null.\",\n      );\n    } else if (isFloat(actual)) {\n      assert(\n        i32(!isNaN(expected)),\n        \"Value comparison fails, expected value is NaN.\",\n      );\n      assert(\n        i32(!isNaN(actual)),\n        \"Value comparison fails, actual value is NaN.\",\n      );\n    }\n\n    // do actual less than comparison\n    assert(negated ^ i32(actual < expected), message);\n    Actual.clear();\n    Expected.clear();\n  }\n\n  public toBeLessThanOrEqual(expected: T, message: string = \"\"): void {\n    let actual = this.actual;\n    let negated = this._not;\n    Actual.report(actual);\n    Expected.report(expected, negated);\n\n    if (!isDefined(actual > expected))\n      // @as-covers: ignore because this is a compile time error\n      ERROR(\n        \"Invalid call to toBeLessThanOrEqual. Generic type T must have an operator implemented for the lessThanOrEqual (<=) operation.\",\n      );\n\n    // null checks\n    if (isReference(actual)) {\n      assert(\n        i32(changetype<usize>(expected) != 0),\n        \"Value comparison fails, expected value is null.\",\n      );\n      assert(\n        i32(changetype<usize>(actual) != 0),\n        \"Value comparison fails, actual value is null.\",\n      );\n    }\n\n    if (isFloat(actual)) {\n      assert(\n        i32(!isNaN(expected)),\n        \"Value comparison fails, expected value is NaN.\",\n      );\n      assert(\n        i32(!isNaN(actual)),\n        \"Value comparison fails, actual value is NaN.\",\n      );\n    }\n\n    // do actual less than comparison\n    assert(negated ^ i32(actual <= expected), message);\n    Actual.clear();\n    Expected.clear();\n  }\n\n  public toBeNull(message: string = \"\"): void {\n    let negated = this._not;\n    let actual = this.actual;\n\n    if (actual instanceof usize) {\n      Actual.report(actual);\n      Expected.report(<usize>0, negated);\n      // @ts-ignore: actual is instanceof number type\n      assert(negated ^ i32(actual == 0), message);\n      Actual.clear();\n      Expected.clear();\n    } else if (isReference(actual)) {\n      Actual.report(actual);\n\n      Expected.report(changetype<T>(0), negated);\n      assert(negated ^ i32(changetype<usize>(actual) == 0), message);\n      Actual.clear();\n      Expected.clear();\n      // @as-covers: ignore because this is a compile time error\n    } else {\n      ERROR(\n        \"toBeNull assertion must be called with a reference type T or usize.\",\n      );\n    }\n  }\n\n  public toBeCloseTo(\n    expected: T,\n    decimalPlaces: i32 = 2,\n    message: string = \"\",\n  ): void {\n    let actual = this.actual;\n    let negated = this._not;\n\n    // must be called on a float T\n    if (!isFloat(actual))\n      // @as-covers: ignore because this is a compile time error\n      ERROR(\"toBeCloseTo must be called with a Float value type T.\");\n    Actual.report(actual);\n    Expected.report(expected, negated);\n\n    // both actual and expected values must be finite\n    assert(\n      i32(isFinite(actual)),\n      \"toBeCloseTo assertion fails because a actual value is not finite\",\n    );\n    assert(\n      i32(isFinite(expected)),\n      \"toBeCloseTo assertion fails because expected value is not finite.\",\n    );\n\n    // calculated: `|expected - actual| < 1 / numberOfDigits`.\n    // @ts-ignore tooling errors because T does not extend a numeric value type. This compiles just fine.\n    let isClose = i32(abs(expected - actual) < Math.pow(10, -decimalPlaces));\n    assert(negated ^ isClose, message);\n    Actual.clear();\n    Expected.clear();\n  }\n\n  public toBeNaN(message: string = \"\"): void {\n    let actual = this.actual;\n    let negated = this._not;\n\n    // must be called on a float T\n    if (!isFloat(actual))\n      // @as-covers: ignore because this is a compile time error\n      ERROR(\"toBeNaN must be called with a Float value type T.\");\n    Actual.report(actual);\n\n    // @ts-ignore: The compiler should pass bit count (64/32 bit float to the report function)\n    Expected.report<T>(NaN, negated);\n\n    let isNaNValue = i32(isNaN(actual));\n    assert(isNaNValue ^ negated, message);\n    Actual.clear();\n    Expected.clear();\n  }\n\n  public toBeFinite(message: string = \"\"): void {\n    let actual = this.actual;\n    let negated = this._not;\n\n    // must be called on a float T\n    if (!isFloat(actual))\n      // @as-covers: ignore because this is a compile time error\n      ERROR(\"toBeNaN must be called with a Float value type T.\");\n    Actual.report(actual);\n    Expected.reportFinite(negated);\n\n    let isFiniteValue = i32(isFinite(actual));\n    assert(isFiniteValue ^ negated, message);\n    Actual.clear();\n    Expected.clear();\n  }\n\n  public toHaveLength(expected: i32, message: string = \"\"): void {\n    let actual = this.actual;\n    let negated = this._not;\n    let length = 0;\n    if (actual instanceof ArrayBuffer) {\n      length = actual.byteLength;\n    } else {\n      // @ts-ignore: This results in a compile time check for a length property with a better error message\n      if (!isDefined(actual.length))\n        // @as-covers: ignore because this is a compile time error\n        ERROR(\n          \"toHaveLength cannot be called on type T where T.length is not defined.\",\n        );\n      // @ts-ignore: This results in a compile time check for a length property with a better error message\n      length = <i32>actual.length;\n    }\n\n    Actual.report(length);\n    Expected.report(expected, negated);\n\n    let lengthsEqual = i32(length == expected);\n    assert(lengthsEqual ^ negated, message);\n    Actual.clear();\n    Expected.clear();\n  }\n\n  public toInclude<U>(expected: U, message: string = \"\"): void {\n    toIncludeComparison<T, U>(this.actual, expected, this._not, message);\n    Actual.clear();\n    Expected.clear();\n  }\n\n  // @ts-ignore: valueof<T> requires that T extends something with an @operator(\"[]\")\n  // @as-covers: ignore because this is just an alias function\n  public toContain(expected: valueof<T>, message: string = \"\"): void {\n    this.toInclude(expected, message);\n  }\n\n  public toIncludeEqual<U>(expected: U, message: string = \"\"): void {\n    toIncludeEqualComparison<T, U>(this.actual, expected, this._not, message);\n    Actual.clear();\n    Expected.clear();\n  }\n\n  // @as-covers: ignore because this is an alias\n  public toContainEqual<U>(expected: U, message: string = \"\"): void {\n    this.toIncludeEqual(expected, message);\n  }\n\n  public toMatchSnapshot(name: string | null = null): void {\n    assert(i32(!this._not), \"Snapshots cannot be negated.\");\n    Expected.reportSnapshot(this.actual, name);\n  }\n}\n\n// @ts-ignore: decorators *are* valid here\n@global\nexport function expect<T>(actual: T): Expectation<T> {\n  return new Expectation(actual);\n}\n\n// @ts-ignore: decorators *are* valid here\n// @as-covers: ignore because this is deprecated\n@global export function expectFn(cb: () => void): Expectation<() => void> {\n  WARNING(\"expectFn() has been deprecated. Use expect() instead.\");\n  return new Expectation(cb);\n}\n","import { Actual } from \"../Actual\";\nimport { Expected } from \"../Expected\";\nimport { assert } from \"../assert\";\n\nexport function toIncludeComparison<T, U>(\n  actual: T,\n  expected: U,\n  negated: i32,\n  message: string,\n): void {\n  // @ts-ignore: checking if a property is defined is compile safe\n  if (!isDefined(actual[0]))\n    // @as-covers: ignore because this is a compile time error\n    ERROR(\n      \"Cannot call toIncludeEquals on actual value of type T where T does not have an index signature.\",\n    );\n\n  // Assert that the actual value is not null.\n  Actual.report(actual);\n  if (isNullable<T>()) {\n    Expected.report(\"null\", 1);\n    assert(i32(actual !== null), \"\");\n  }\n\n  // We always expect the value to be included\n  Expected.report(\"Included\", negated);\n  // assume it isn't included\n  let includes: bool = false;\n\n  if (actual instanceof Set) {\n    includes = actual.has(expected);\n  } else {\n    if (isNullable(actual)) {\n      includes = includesCheck(actual!, expected);\n    } else {\n      includes = includesCheck(actual, expected);\n    }\n  }\n\n  Actual.report(includes ? \"Included\" : \"Not Included\");\n  assert(negated ^ i32(includes), message);\n}\n\nfunction includesCheck<T, U>(actual: T, expected: U): bool {\n  // @ts-ignore: typesafe check\n  if (!isDefined(actual.length))\n    // @as-covers: ignore because this is a compile time error\n    ERROR(\"Can only call toInclude on array-like objects or Sets.\");\n\n  if (!isDefined(unchecked(actual[0])))\n    // @as-covers: ignore because this is a compile time error\n    ERROR(\"Can only call toInclude on array-like objects or Sets.\");\n\n  // @ts-ignore: typesafe access\n  let length = <indexof<T>>actual.length;\n  // @ts-ignore: typesafe check\n  if (isDefined(unchecked(actual[0]))) {\n    // @ts-ignore: if T does not have a length property, it will throw a compiler error.\n    for (let i = <indexof<T>>0; i < length; i++) {\n      // @ts-ignore: if this expression does not work, it will throw a compiler error.\n      if (unchecked(actual[i]) === expected) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n","// @ts-ignore: Decorators *are* valid here!\n@external(\"__aspect\", \"reportActualReflectedValue\")\ndeclare function reportActualReflectedValue(id: i32): void;\n\n// @ts-ignore: Decorators *are* valid here!\n@external(\"__aspect\", \"clearActual\")\ndeclare function clearActual(): void;\n\n@global\nexport class Actual {\n  static report<T>(actual: T): void {\n    let value = Reflect.toReflectedValue(actual);\n    Reflect.attachStackTrace(value);\n    reportActualReflectedValue(value);\n  }\n\n  static clear(): void {\n    clearActual();\n  }\n}\n","// @ts-ignore: Decorators *are* valid here!\n@external(\"__aspect\", \"reportExpectedReflectedValue\")\ndeclare function reportExpectedReflectedValue(id: i32, negated: i32): void;\n\n// @ts-ignore: Decorators *are* valid here!\n@external(\"__aspect\", \"reportExpectedSnapshot\")\ndeclare function reportExpectedSnapshot(id: i32, name: string | null): void;\n\n// @ts-ignore: Decorators *are* valid here!\n@external(\"__aspect\", \"reportExpectedTruthy\")\ndeclare function reportExpectedTruthy(negated: i32): void;\n\n// @ts-ignore: Decorators *are* valid here!\n@external(\"__aspect\", \"reportExpectedFalsy\")\ndeclare function reportExpectedFalsy(negated: i32): void;\n\n// @ts-ignore: Decorators *are* valid here!\n@external(\"__aspect\", \"reportExpectedFinite\")\ndeclare function reportExpectedFinite(negated: i32): void;\n\n// @ts-ignore: Decorators *are* valid here!\n@external(\"__aspect\", \"clearExpected\")\ndeclare function clearExpected(): void;\n\n@global\nexport class Expected {\n  static report<T>(expected: T, negated: i32 = 0): void {\n    let value = Reflect.toReflectedValue(expected);\n    Reflect.attachStackTrace(value);\n    reportExpectedReflectedValue(value, negated);\n  }\n\n  static reportTruthy(negated: i32 = 0): void {\n    reportExpectedTruthy(negated);\n  }\n\n  static reportFalsy(negated: i32 = 0): void {\n    reportExpectedFalsy(negated);\n  }\n\n  static reportFinite(negated: i32 = 0): void {\n    reportExpectedFinite(negated);\n  }\n\n  static reportSnapshot<T>(actual: T, name: string | null = null): void {\n    reportExpectedSnapshot(\n      Reflect.toReflectedValue(actual, new Map<usize, i32>()),\n      name,\n    );\n  }\n\n  static clear(): void {\n    clearExpected();\n  }\n}\n","export function assert(condition: i32, message: string): void {\n  if (!condition) throw new Error(message);\n}\n","import { Actual } from \"../Actual\";\nimport { Expected } from \"../Expected\";\nimport { assert } from \"../assert\";\n\n// @ts-ignore expected is valueof<T> or it will be a compiler error\nexport function toIncludeEqualComparison<T, U>(\n  actual: T,\n  expected: U,\n  negated: i32,\n  message: string,\n): void {\n  // @ts-ignore: typesafe check\n  if (!isDefined(actual[0]))\n    // @as-covers: ignore beause this is a compile time error\n    ERROR(\n      \"Cannot call toIncludeEquals on actual value of type T where T does not have an index signature.\",\n    );\n\n  // Assert that the actual value is not null.\n  Actual.report(actual);\n  Expected.report(\"null\", 1);\n  assert(i32(changetype<usize>(actual) != 0), \"\");\n\n  // We always expect the value to be included\n  Expected.report(\"Included\", negated);\n  // assume it isn't included\n  let includes = false;\n\n  if (actual instanceof Set) {\n    if (actual.has(expected)) {\n      includes = true;\n    } else {\n      // if it isn't already in the set, we need to look over each value and inspect it for strict equality\n      // @ts-ignore: type safe .values() method call\n      let values = actual.values();\n      let length = values.length;\n      for (let i = 0; i < length; i++) {\n        let key = unchecked(values[i]);\n        if (Reflect.equals(key, expected) === Reflect.SUCCESSFUL_MATCH) {\n          includes = true;\n          break;\n        }\n      }\n    }\n  } else {\n    // @ts-ignore: typesafe check\n    if (!isDefined(actual.length))\n      ERROR(\"Can only call toIncludeEquals on array-like objects or Sets.\");\n\n    if (isNullable<T>()) {\n      let actualNotNull = actual!;\n      // @ts-ignore: typesafe check\n      if (isDefined(unchecked(actualNotNull[0]))) {\n        // @ts-ignore: typesafe access\n        let length = <indexof<T>>actualNotNull.length;\n        // @ts-ignore: if T does not have a length property, it will throw a compiler error.\n        for (let i = <indexof<T>>0; i < length; i++) {\n          if (\n            // @ts-ignore: actual[i] type must match expected, or a compiler error will happen\n            Reflect.equals(unchecked(actualNotNull[i]), expected) ==\n            Reflect.SUCCESSFUL_MATCH\n          ) {\n            includes = true;\n            break;\n          }\n        }\n      }\n    } else {\n      // @ts-ignore: typesafe check\n      if (isDefined(unchecked(actual[0]))) {\n        // @ts-ignore: typesafe access\n        let length = <indexof<T>>actual.length;\n        // @ts-ignore: if T does not have a length property, it will throw a compiler error.\n        for (let i = <indexof<T>>0; i < length; i++) {\n          if (\n            // @ts-ignore: actual[i] type must match expected, or a compiler error will happen\n            Reflect.equals(unchecked(actual[i]), expected) ==\n            Reflect.SUCCESSFUL_MATCH\n          ) {\n            includes = true;\n            break;\n          }\n        }\n      }\n    }\n    // unchecked is always defined...\n  }\n\n  Actual.report(includes ? \"Included\" : \"Not Included\");\n  assert(negated ^ i32(includes), message);\n}\n","import { ArrayBufferView } from \"arraybuffer\";\nimport { Set } from \"set\";\nimport { assert } from \"./assert\";\nimport { ReflectedValueType } from \"./ReflectedValueType\";\nimport { OBJECT, OBJECT_OVERHEAD } from \"rt/common\";\n\nfunction pairSeen(a1: usize, a2: usize, b1: usize, b2: usize): bool {\n  return bool(\n    (i32(a1 == b1) & i32(a2 == b2)) | (i32(a1 == b2) & i32(a2 == b1)),\n  );\n}\n\n// @ts-ignore: Decorators *are* valid here!\n@external(\"__aspect\", \"attachStackTraceToReflectedValue\")\ndeclare function attachStackTraceToReflectedValue(id: i32): void;\n\n// @ts-ignore: linked function decorator\n@external(\"__aspect\", \"createReflectedValue\")\ndeclare function createReflectedValue(\n  isNull: bool,\n  hasKeys: bool,\n  nullable: bool,\n  offset: i32,\n  pointer: usize,\n  signed: bool,\n  size: i32,\n  reflectedTypeValue: ReflectedValueType,\n  typeId: i32,\n  typeName: string,\n  value: usize,\n  hasValues: bool,\n  isManaged: bool,\n): i32;\n\n// @ts-ignore: linked function decorator\n@external(\"__aspect\", \"createReflectedNumber\")\ndeclare function createReflectedNumber(\n  signed: bool,\n  size: i32,\n  reflectedTypeValue: ReflectedValueType,\n  typeName: string,\n  value: f64,\n): i32;\n\n// @ts-ignore: linked function decorator\n@external(\"__aspect\", \"createReflectedLong\")\ndeclare function createReflectedLong(\n  signed: bool,\n  size: i32,\n  reflectedTypeValue: ReflectedValueType,\n  typeName: string,\n  lowValue: i32,\n  highValue: i32,\n): i32;\n\n// @ts-ignore: external declaration\n@external(\"__aspect\", \"pushReflectedObjectValue\")\n@global\ndeclare function __aspectPushReflectedObjectValue(\n  parentID: i32,\n  value: i32,\n): void;\n\n// @ts-ignore: external declaration\n@external(\"__aspect\", \"pushReflectedObjectKey\")\n@global\ndeclare function __aspectPushReflectedObjectKey(\n  parentID: i32,\n  value: i32,\n): void;\n\n@inline function sizeOf(ptr: usize): i32 {\n  return changetype<OBJECT>(ptr - OBJECT_OVERHEAD).rtSize;\n}\n\n@global\n// @ts-ignore: global decorator is allowed here\nexport class Reflect {\n  public static toReflectedValue<T>(\n    value: T,\n    seen: Map<usize, i32> = new Map<usize, i32>(),\n  ): i32 {\n    // if T is a reference\n    if (isReference<T>()) {\n      // if the value is null, create a Null reflected value\n      if (changetype<usize>(value) == 0) {\n        return createReflectedValue(\n          true,\n          false,\n          isNullable<T>(),\n          0,\n          0,\n          false,\n          sizeof<T>(),\n          isFunction<T>()\n            ? ReflectedValueType.Function\n            : ReflectedValueType.Class,\n          isManaged<T>() ? idof<T>() : 0,\n          isFunction<T>() ? \"Function\" : nameof<T>(),\n          0,\n          false,\n          isManaged<T>(),\n        );\n      }\n\n      // check the cache for anything that isn't a function\n      if (!isFunction<T>()) {\n        if (seen.has(changetype<usize>(value))) {\n          return seen.get(changetype<usize>(value));\n        }\n      }\n\n      // @ts-ignore: __aspectReflectAs() can potentially be implemented\n      if (isDefined(value.__aspectReflectAs())) {\n        // @ts-ignore: typesafe call to __aspectReflectAs()\n        let displayValue = value.__aspectReflectAs();\n        if (!isInteger(displayValue)) {\n          if (!isFloat(displayValue)) {\n            // @as-covers: ignore compile time check\n            if (!isManaged(displayValue)) {\n              ERROR(\n                \"__aspectReflectAs() function should return a managed type or a number\",\n              );\n            }\n          }\n        }\n        return Reflect.toReflectedValue(displayValue, seen);\n      }\n\n      if (value instanceof ArrayBuffer) {\n        let reflectedValue = createReflectedValue(\n          false,\n          false,\n          isNullable<T>(),\n          value.byteLength,\n          changetype<usize>(value),\n          false,\n          value.byteLength,\n          ReflectedValueType.ArrayBuffer,\n          idof<T>(),\n          nameof<T>(),\n          0,\n          true,\n          true,\n        );\n        seen.set(changetype<usize>(value), reflectedValue);\n        let length = value.byteLength;\n        for (let i = 0; i < length; i++) {\n          __aspectPushReflectedObjectValue(\n            reflectedValue,\n            Reflect.toReflectedValue(\n              load<u8>(changetype<usize>(value) + <usize>i),\n              seen,\n            ),\n          );\n        }\n        return reflectedValue;\n      } else if (isFunction<T>()) {\n        let func = value;\n        let reflectedValue = createReflectedValue(\n          false,\n          false,\n          isNullable<T>(),\n          0,\n          // @ts-ignore has field\n          func.index,\n          false,\n          0,\n          ReflectedValueType.Function,\n          0,\n          \"Function\",\n          // @ts-ignore has field\n          func.index,\n          false,\n          isManaged<T>(),\n        );\n        return reflectedValue;\n      } else if (value instanceof Set) {\n        // create a Set reflected value\n        let reflectedObject = createReflectedValue(\n          false,\n          false, // sets don't have keys\n          isNullable<T>(),\n          0,\n          changetype<usize>(value),\n          false,\n          value.size,\n          ReflectedValueType.Set,\n          idof<T>(),\n          nameof<T>(),\n          0,\n          true, // sets have values\n          true,\n        );\n\n        // cache this value\n        seen.set(changetype<usize>(value), reflectedObject);\n\n        // loop over each item and push it to the Set\n        let values = value.values();\n        let length = values.length;\n        for (let i = 0; i < length; i++) {\n          let value = unchecked(values[i]);\n          let reflectedValueID = Reflect.toReflectedValue(value, seen);\n          __aspectPushReflectedObjectValue(reflectedObject, reflectedValueID);\n        }\n      } else if (value instanceof Map) {\n        // create a Set reflected object\n        let reflectedValue = createReflectedValue(\n          false,\n          true, // maps have keys\n          isNullable<T>(),\n          0,\n          changetype<usize>(value),\n          false,\n          value.size,\n          ReflectedValueType.Map,\n          idof<T>(),\n          nameof<T>(),\n          0,\n          true, // maps have values\n          true,\n        );\n\n        // cache this value\n        seen.set(changetype<usize>(value), reflectedValue);\n\n        // loop over each key and push the key value pair to the reflected Map\n        let keys = value.keys();\n        let length = keys.length;\n        for (let i = 0; i < length; i++) {\n          let mapKey = unchecked(keys[i]);\n          let reflectedKeyID = Reflect.toReflectedValue(mapKey, seen);\n          __aspectPushReflectedObjectKey(reflectedValue, reflectedKeyID);\n\n          let mapValue = value.get(mapKey);\n          let reflectedValueID = Reflect.toReflectedValue(mapValue, seen);\n          __aspectPushReflectedObjectValue(reflectedValue, reflectedValueID);\n        }\n\n        return reflectedValue;\n      } else if (value instanceof ArrayBufferView) {\n        // @ts-ignore: has field\n        let length = value.length;\n\n        // create an arraylike reflected value\n        let reflectedValue = createReflectedValue(\n          false,\n          false, // arrays don't have keys\n          isNullable<T>(),\n          0,\n          changetype<usize>(value),\n          false,\n          length,\n          ReflectedValueType.TypedArray,\n          idof<T>(),\n          nameof<T>(),\n          0,\n          true, // maps have values\n          isManaged<T>(),\n        );\n\n        // cache this value\n        seen.set(changetype<usize>(value), reflectedValue);\n\n        // loop over each value and push it to the reflected value\n        for (let i = 0; i < length; i++) {\n          // @ts-ignore index signature is garunteed at this point\n          let arrayValue = unchecked(value[i]);\n          let reflectedArrayValueID = Reflect.toReflectedValue(\n            arrayValue,\n            seen,\n          );\n          __aspectPushReflectedObjectValue(\n            reflectedValue,\n            reflectedArrayValueID,\n          );\n        }\n\n        return reflectedValue;\n      } else if (value instanceof String) {\n        let reflectedStringID = createReflectedValue(\n          false,\n          false,\n          isNullable<T>(),\n          0,\n          changetype<usize>(value),\n          false,\n          value.length,\n          ReflectedValueType.String,\n          idof<T>(),\n          nameof<T>(),\n          changetype<usize>(value),\n          false,\n          true,\n        );\n        seen.set(changetype<usize>(value), reflectedStringID);\n        return reflectedStringID;\n      } else if (isArrayLike<T>()) {\n        // @ts-ignore: arraylike has length property\n        let length = <i32>value.length;\n\n        // create an arraylike reflected value\n        let reflectedValue = createReflectedValue(\n          false,\n          false, // arrays don't have keys\n          isNullable<T>(),\n          0,\n          changetype<usize>(value),\n          false,\n          length,\n          ReflectedValueType.Array,\n          isManaged<T>() ? idof<T>() : 0,\n          nameof<T>(),\n          0,\n          true, // maps have values\n          isManaged<T>(),\n        );\n\n        // cache this value\n        seen.set(changetype<usize>(value), reflectedValue);\n\n        // loop over each array item and push it to the reflected value\n        for (let i = 0; i < length; i++) {\n          // @ts-ignore: index signature in arraylike\n          let arrayValue = unchecked(value[i]);\n          let reflectedArrayValueID = Reflect.toReflectedValue(\n            arrayValue,\n            seen,\n          );\n          __aspectPushReflectedObjectValue(\n            reflectedValue,\n            reflectedArrayValueID,\n          );\n        }\n        return reflectedValue;\n      } else {\n        // generic class\n        let reflectedObjectID = createReflectedValue(\n          false,\n          true, // classes have keys\n          isNullable<T>(),\n          offsetof<T>(),\n          changetype<usize>(value),\n          false,\n          sizeOf(changetype<usize>(value)),\n          ReflectedValueType.Class,\n          isManaged<T>() ? idof<T>() : 0,\n          nameof<T>(),\n          0,\n          true, // classes have values\n          isManaged<T>(),\n        );\n\n        // cache this object\n        seen.set(changetype<usize>(value), reflectedObjectID);\n\n        // @ts-ignore: __aspectAddReflectedValueKeyValuePairs is auto-generated by the transform\n        value.__aspectAddReflectedValueKeyValuePairs(\n          reflectedObjectID,\n          seen,\n          [] as StaticArray<i64>,\n        );\n\n        return reflectedObjectID;\n      }\n    } else if (alignof<T>() === 3) {\n      if (isInteger<T>()) {\n        // u64, i64, isize, or usize (when targeting 64 bit WebAssembly)\n        // @ts-ignore: value is a number\n        let reflectedValue = createReflectedLong(\n          isSigned<T>(),\n          sizeof<T>(),\n          ReflectedValueType.Integer,\n          nameof<T>(),\n          // @ts-ignore: value is a 64 bit number\n          <i32>(value & 0xffffffff),\n          // @ts-ignore: value is a 64 bit number\n          <i32>(value >>> 32),\n        );\n        return reflectedValue;\n      }\n      // float64\n      let reflectedValue = createReflectedNumber(\n        isSigned<T>(),\n        sizeof<T>(),\n        ReflectedValueType.Float,\n        nameof<T>(),\n        // @ts-ignore: type is bool, i32, f64, or f32\n        <f64>value,\n      );\n      return reflectedValue;\n    } else {\n      // boolean, i32, u32, f32, isize, usize (when targeting 32 bit WebAssembly), or numbers with less bits\n      let reflectedValue = createReflectedNumber(\n        isSigned<T>(),\n        sizeof<T>(),\n        isBoolean<T>()\n          ? ReflectedValueType.Boolean\n          : isInteger<T>()\n          ? ReflectedValueType.Integer\n          : ReflectedValueType.Float,\n        nameof<T>(),\n        // @ts-ignore: type is bool, i32, f64, or f32\n        <f64>value,\n      );\n      return reflectedValue;\n    }\n    return 0;\n  }\n\n  public static equals<T>(\n    left: T,\n    right: T,\n    stack: usize[] = [],\n    cache: usize[] = [],\n  ): i32 {\n    // use `==` operator to work with operator overloads and strings\n    if (left == right) return Reflect.SUCCESSFUL_MATCH; // works immutably for string comparison\n\n    // floats should equal each other\n    if (isFloat<T>()) {\n      if (i32(isNaN(left)) & i32(isNaN(right))) return Reflect.SUCCESSFUL_MATCH;\n    }\n\n    if (isReference<T>()) {\n      // T can always be null if it's a reference, emit a runtime check for it regardless of type\n      if (\n        i32(changetype<usize>(left) == 0) ^ i32(changetype<usize>(right) == 0)\n      ) {\n        return Reflect.FAILED_MATCH;\n      }\n    }\n\n    // check every reference that isn't a function reference\n    if (isReference<T>()) {\n      if (!isFunction<T>()) {\n        if (isNullable<T>()) {\n          return referencesEqual(left!, right!, stack, cache);\n        } else {\n          return referencesEqual(left, right, stack, cache);\n        }\n      }\n    }\n    // value type, and strict equality cannot be asserted\n    return Reflect.FAILED_MATCH;\n  }\n\n  public static attachStackTrace(id: i32): void {\n    attachStackTraceToReflectedValue(id);\n  }\n}\n\nfunction referencesEqual<T>(\n  left: T,\n  right: T,\n  stack: usize[],\n  cache: usize[],\n): i32 {\n  let a = changetype<usize>(left);\n  let b = changetype<usize>(right);\n\n  let cacheLength = cache.length;\n  // must be EVEN or there's a big problem\n  assert(i32((cacheLength & 0x00000001) == 0), \"cacheLength should be even\");\n\n  // short circuit for strings\n  if (left instanceof String) {\n    return Reflect.FAILED_MATCH;\n  }\n\n  // check the cache for matched pairs\n  for (let i = 0; i < cacheLength; i += 2) {\n    if (pairSeen(a, b, unchecked(cache[i]), unchecked(cache[i + 1])))\n      return Reflect.SUCCESSFUL_MATCH;\n  }\n\n  // short circuit because this pair might already be resolving\n  let length = stack.length;\n  for (let i = 0; i < length; i += 2) {\n    if (pairSeen(a, b, unchecked(stack[i]), unchecked(stack[i + 1])))\n      return Reflect.DEFER_MATCH;\n  }\n\n  // once we've determined we need to check the references for their values, arraybuffers\n  // require a memory compare\n  if (left instanceof ArrayBuffer) {\n    // @ts-ignore: typesafe access to byteLength property because T is ArrayBuffer\n    if (left.byteLength != right.byteLength) return Reflect.FAILED_MATCH;\n    let result = memory.compare(a, b, left.byteLength);\n    if (result == 0) {\n      cache.push(a);\n      cache.push(b);\n      return Reflect.SUCCESSFUL_MATCH;\n    } else return Reflect.FAILED_MATCH;\n  }\n\n  // @ts-ignore: valid index signature check\n  if (isDefined(left[0])) {\n    // test for safe indexof usage\n    // set match\n    if (left instanceof Set) {\n      // @ts-ignore: size is a valid property of Set\n      if (left.size != right.size) return Reflect.FAILED_MATCH;\n      stack.push(a);\n      stack.push(b);\n      // @ts-ignore: values() is a valid function of Set\n      let leftValues = left.values();\n      // @ts-ignore: values() is a valid function of Set\n      let rightValues = right.values();\n      let length = leftValues.length;\n      let leftoverLength = length;\n      for (let i = 0; i < length; i++) {\n        let leftItem = unchecked(leftValues[i]);\n        let continueOuter = false;\n        for (let j = 0; j < leftoverLength; j++) {\n          let rightItem = unchecked(rightValues[j]);\n          if (\n            Reflect.equals(leftItem, rightItem, stack, cache) !=\n            Reflect.FAILED_MATCH\n          ) {\n            rightValues.splice(j, 1);\n            leftoverLength--;\n            continueOuter = true;\n            break;\n          }\n        }\n        if (continueOuter) continue;\n\n        stack.pop();\n        stack.pop();\n        return Reflect.FAILED_MATCH;\n      }\n\n      cache.push(a);\n      cache.push(b);\n\n      stack.pop();\n      stack.pop();\n      return Reflect.SUCCESSFUL_MATCH;\n    }\n\n    if (left instanceof Map) {\n      // @ts-ignore: size is a valid property of Map\n      if (left.size != right.size) return Reflect.FAILED_MATCH;\n      stack.push(a);\n      stack.push(b);\n\n      // collect all the keys and loop over each one\n      let leftKeys = left.keys();\n      // @ts-ignore: keys() is a valid function of Map\n      let rightKeys = right.keys();\n\n      // @ts-ignore: length is a valid property of Array\n      let keyLength = leftKeys.length;\n      let leftoverKeyLength = keyLength;\n\n      // assume we match and determine if the match was a failure\n      let result = Reflect.SUCCESSFUL_MATCH;\n\n      // for each key\n      for (let i = 0; i < keyLength; i++) {\n        let leftKey = unchecked(leftKeys[i]);\n        // assume won't find it\n        let found = false;\n\n        // find a matching key\n        for (let j = 0; j < leftoverKeyLength; j++) {\n          let rightKey = unchecked(rightKeys[j]);\n\n          // if the keys match, or are still being resolved\n          if (\n            Reflect.equals(leftKey, rightKey, stack, cache) !=\n            Reflect.FAILED_MATCH\n          ) {\n            // the key potentially matches, obtain the values associated with the keys\n            let leftValue = left.get(leftKey);\n            // @ts-ignore: get() is a valid function of Map\n            let rightValue = right.get(rightKey);\n\n            // if the values match, or are still being resolved\n            if (\n              Reflect.equals(leftValue, rightValue, stack, cache) !=\n              Reflect.FAILED_MATCH\n            ) {\n              leftoverKeyLength--;\n              rightKeys.splice(j, 1); // remove this key from the list\n              found = true;\n              break;\n            }\n          }\n        }\n\n        // if there was no match for this key value pair, the result is Failed\n        if (!found) {\n          result = Reflect.FAILED_MATCH;\n          break;\n        }\n      }\n\n      // if every key matched, result is still equal to `Reflect.MATCH`\n      if (result == Reflect.SUCCESSFUL_MATCH) {\n        cache.push(a);\n        cache.push(b);\n      }\n\n      stack.pop();\n      stack.pop();\n      return result;\n    }\n\n    // compile time array values should be compared over a for loop\n    // @ts-ignore: typesafe access to length\n    if (isDefined(left.length)) {\n      // @ts-ignore: typesafe access to length\n      let aLength = left.length;\n      // @ts-ignore: typesafe access to length\n      let bLength = right.length;\n\n      // assert the lengths are good\n      if (aLength != bLength) return Reflect.FAILED_MATCH;\n\n      // check each item\n      for (let i = 0; i < aLength; i++) {\n        let result = Reflect.equals(\n          // @ts-ignore: typesafe and runtime check safe array access\n          unchecked(left[i]),\n          // @ts-ignore: typesafe and runtime check safe array access\n          unchecked(right[i]),\n          stack,\n          cache,\n        );\n        if (result == Reflect.FAILED_MATCH) return Reflect.FAILED_MATCH;\n      }\n\n      // cache this result\n      cache.push(a);\n      cache.push(b);\n\n      return Reflect.SUCCESSFUL_MATCH;\n    }\n  }\n\n  // todo: handle Set<keyof<T>> and Map<keyof<T>, valueof<T>>\n\n  // we are trying to resolve this pair, push it to the stack\n  stack.push(a);\n  stack.push(b);\n\n  let result = false;\n  if (isNullable(left)) {\n    // @ts-ignore: __aspectStrictEquals is defined at this point\n    result = left!.__aspectStrictEquals(\n      right,\n      stack,\n      cache,\n      [] as StaticArray<i64>,\n    );\n  } else {\n    // @ts-ignore: __aspectStrictEquals is defined at this point\n    result = left.__aspectStrictEquals(\n      right,\n      stack,\n      cache,\n      [] as StaticArray<i64>,\n    );\n  }\n\n  if (result) {\n    cache.push(a);\n    cache.push(b);\n  }\n\n  stack.pop();\n  stack.pop();\n  return select(Reflect.SUCCESSFUL_MATCH, Reflect.FAILED_MATCH, result);\n}\n\nexport namespace Reflect {\n  export const FAILED_MATCH = 0;\n  export const SUCCESSFUL_MATCH = 1;\n  export const DEFER_MATCH = 2;\n}\n","export function HASH<T>(key: T): u32 {\n  if (isString<T>()) {\n    return hashStr(changetype<string>(key));\n  } else if (isReference<T>()) {\n    if (sizeof<T>() == 4) return hash32(changetype<u32>(key));\n    if (sizeof<T>() == 8) return hash64(changetype<u64>(key));\n  } else if (isFloat<T>()) {\n    if (sizeof<T>() == 4) return hash32(reinterpret<u32>(f32(key)));\n    if (sizeof<T>() == 8) return hash64(reinterpret<u64>(f64(key)));\n  } else {\n    if (sizeof<T>() <= 4) return hash32(u32(key), sizeof<T>());\n    if (sizeof<T>() == 8) return hash64(u64(key));\n  }\n  return unreachable();\n}\n\n// XXHash 32-bit as a starting point, see: https://cyan4973.github.io/xxHash\n\n// primes\n// @ts-ignore: decorator\n@inline const XXH32_P1: u32 = 2654435761;\n// @ts-ignore: decorator\n@inline const XXH32_P2: u32 = 2246822519;\n// @ts-ignore: decorator\n@inline const XXH32_P3: u32 = 3266489917;\n// @ts-ignore: decorator\n@inline const XXH32_P4: u32 = 668265263;\n// @ts-ignore: decorator\n@inline const XXH32_P5: u32 = 374761393;\n// @ts-ignore: decorator\n@inline const XXH32_SEED: u32 = 0;\n\n// @ts-ignore: decorator\n@inline\nfunction hash32(key: u32, len: u32 = 4): u32 {\n  var h: u32 = XXH32_SEED + XXH32_P5 + len;\n  h += key * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction hash64(key: u64): u32 {\n  var h: u32 = XXH32_SEED + XXH32_P5 + 8;\n  h += <u32>key * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h += <u32>(key >> 32) * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction mix(h: u32, key: u32): u32 {\n  return rotl(h + key * XXH32_P2, 13) * XXH32_P1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction hashStr(key: string): u32 {\n  if (key === null) return XXH32_SEED;\n\n  var h: u32 = key.length << 1;\n  var len: usize = h;\n  var pos = changetype<usize>(key);\n\n  if (len >= 16) {\n    let s1 = XXH32_SEED + XXH32_P1 + XXH32_P2;\n    let s2 = XXH32_SEED + XXH32_P2;\n    let s3 = XXH32_SEED;\n    let s4 = XXH32_SEED - XXH32_P1;\n\n    let end = len + pos - 16;\n    while (pos <= end) {\n      s1 = mix(s1, load<u32>(pos    ));\n      s2 = mix(s2, load<u32>(pos,  4));\n      s3 = mix(s3, load<u32>(pos,  8));\n      s4 = mix(s4, load<u32>(pos, 12));\n      pos += 16;\n    }\n    h += rotl(s1, 1) + rotl(s2, 7) + rotl(s3, 12) + rotl(s4, 18);\n  } else {\n    h += XXH32_SEED + XXH32_P5;\n  }\n\n  var end = changetype<usize>(key) + len - 4;\n  while (pos <= end) {\n    h += load<u32>(pos) * XXH32_P3;\n    h = rotl(h, 17) * XXH32_P4;\n    pos += 4;\n  }\n\n  end = changetype<usize>(key) + len;\n  while (pos < end) {\n    h += <u32>load<u8>(pos) * XXH32_P5;\n    h = rotl(h, 11) * XXH32_P1;\n    pos++;\n  }\n\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { HASH } from \"./util/hash\";\n\n// A deterministic hash set based on CloseTable from https://github.com/jorendorff/dht\n\n// @ts-ignore: decorator\n@inline const INITIAL_CAPACITY = 4;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_N = 8;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_D = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_N = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_D = 4;\n\n/** Structure of a set entry. */\n@unmanaged class SetEntry<K> {\n  key: K;\n  taggedNext: usize; // LSB=1 indicates EMPTY\n}\n\n/** Empty bit. */\n// @ts-ignore: decorator\n@inline const EMPTY: usize = 1 << 0;\n\n/** Size of a bucket. */\n// @ts-ignore: decorator\n@inline const BUCKET_SIZE = sizeof<usize>();\n\n/** Computes the alignment of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_ALIGN<T>(): usize {\n  // can align to 4 instead of 8 if 32-bit and K is <= 32-bits\n  const align = (sizeof<T>() > sizeof<usize>() ? sizeof<T>() : sizeof<usize>()) - 1;\n  return align;\n}\n\n/** Computes the aligned size of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_SIZE<T>(): usize {\n  const align = ENTRY_ALIGN<T>();\n  const size = (offsetof<SetEntry<T>>() + align) & ~align;\n  return size;\n}\n\nexport class Set<T> {\n\n  // buckets referencing their respective first entry, usize[bucketsMask + 1]\n  private buckets: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n  private bucketsMask: u32 = INITIAL_CAPACITY - 1;\n\n  // entries in insertion order, SetEntry<K>[entriesCapacity]\n  private entries: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<T>());\n  private entriesCapacity: i32 = INITIAL_CAPACITY;\n  private entriesOffset: i32 = 0;\n  private entriesCount: i32 = 0;\n\n  constructor() {\n    /* nop */\n  }\n\n  get size(): i32 {\n    return this.entriesCount;\n  }\n\n  clear(): void {\n    this.buckets = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n    this.bucketsMask = INITIAL_CAPACITY - 1;\n    this.entries = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<T>());\n    this.entriesCapacity = INITIAL_CAPACITY;\n    this.entriesOffset = 0;\n    this.entriesCount = 0;\n  }\n\n  private find(key: T, hashCode: u32): SetEntry<T> | null {\n    var entry = load<SetEntry<T>>( // unmanaged!\n      changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE\n    );\n    while (entry) {\n      let taggedNext = entry.taggedNext;\n      if (!(taggedNext & EMPTY) && entry.key == key) return entry;\n      entry = changetype<SetEntry<T>>(taggedNext & ~EMPTY);\n    }\n    return null;\n  }\n\n  @operator(\"[]\")\n  has(key: T): bool {\n    return this.find(key, HASH<T>(key)) !== null;\n  }\n\n  add(key: T): this {\n    var hashCode = HASH<T>(key);\n    var entry = this.find(key, hashCode); // unmanaged!\n    if (!entry) {\n      // check if rehashing is necessary\n      if (this.entriesOffset == this.entriesCapacity) {\n        this.rehash(\n          this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n            ?  this.bucketsMask           // just rehash if 1/4+ entries are empty\n            : (this.bucketsMask << 1) | 1 // grow capacity to next 2^N\n        );\n      }\n      // append new entry\n      entry = changetype<SetEntry<T>>(changetype<usize>(this.entries) + <usize>(this.entriesOffset++) * ENTRY_SIZE<T>());\n      entry.key = key;\n      if (isManaged<T>()) {\n        __link(changetype<usize>(this), changetype<usize>(key), true);\n      }\n      ++this.entriesCount;\n      // link with previous entry in bucket\n      let bucketPtrBase = changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE;\n      entry.taggedNext = load<usize>(bucketPtrBase);\n      store<usize>(bucketPtrBase, changetype<usize>(entry));\n    }\n    return this;\n  }\n\n  @operator(\"[]=\")\n  private __set(key: T, value: bool): void {\n    if (value) this.add(key);\n    else this.delete(key);\n  }\n\n  delete(key: T): bool {\n    var entry = this.find(key, HASH<T>(key)); // unmanaged!\n    if (!entry) return false;\n    entry.taggedNext |= EMPTY;\n    --this.entriesCount;\n    // check if rehashing is appropriate\n    var halfBucketsMask = this.bucketsMask >> 1;\n    if (\n      halfBucketsMask + 1 >= max<u32>(INITIAL_CAPACITY, this.entriesCount) &&\n      this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n    ) this.rehash(halfBucketsMask);\n    return true;\n  }\n\n  private rehash(newBucketsMask: u32): void {\n    var newBucketsCapacity = <i32>(newBucketsMask + 1);\n    var newBuckets = new ArrayBuffer(newBucketsCapacity * <i32>BUCKET_SIZE);\n    var newEntriesCapacity = newBucketsCapacity * FILL_FACTOR_N / FILL_FACTOR_D;\n    var newEntries = new ArrayBuffer(newEntriesCapacity * <i32>ENTRY_SIZE<T>());\n\n    // copy old entries to new entries\n    var oldPtr = changetype<usize>(this.entries);\n    var oldEnd = oldPtr + <usize>this.entriesOffset * ENTRY_SIZE<T>();\n    var newPtr = changetype<usize>(newEntries);\n    while (oldPtr != oldEnd) {\n      let oldEntry = changetype<SetEntry<T>>(oldPtr); // unmanaged!\n      if (!(oldEntry.taggedNext & EMPTY)) {\n        let newEntry = changetype<SetEntry<T>>(newPtr); // unmanaged!\n        let oldEntryKey = oldEntry.key;\n        newEntry.key = oldEntryKey;\n        let newBucketIndex = HASH<T>(oldEntryKey) & newBucketsMask;\n        let newBucketPtrBase = changetype<usize>(newBuckets) + <usize>newBucketIndex * BUCKET_SIZE;\n        newEntry.taggedNext = load<usize>(newBucketPtrBase);\n        store<usize>(newBucketPtrBase, newPtr);\n        newPtr += ENTRY_SIZE<T>();\n      }\n      oldPtr += ENTRY_SIZE<T>();\n    }\n\n    this.buckets = newBuckets;\n    this.bucketsMask = newBucketsMask;\n    this.entries = newEntries;\n    this.entriesCapacity = newEntriesCapacity;\n    this.entriesOffset = this.entriesCount;\n  }\n\n  values(): T[] {\n    // FIXME: this is preliminary, needs iterators/closures\n    var start = changetype<usize>(this.entries);\n    var size = this.entriesOffset;\n    var values = new Array<T>(size);\n    var length = 0;\n    for (let i = 0; i < size; ++i) {\n      let entry = changetype<SetEntry<T>>(start + <usize>i * ENTRY_SIZE<T>());\n      if (!(entry.taggedNext & EMPTY)) {\n        values[length++] = entry.key;\n      }\n    }\n    values.length = length;\n    return values;\n  }\n\n  toString(): string {\n    return \"[object Set]\";\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    __visit(changetype<usize>(this.buckets), cookie);\n    var entries = changetype<usize>(this.entries);\n    if (isManaged<T>()) {\n      let cur = entries;\n      let end = cur + <usize>this.entriesOffset * ENTRY_SIZE<T>();\n      while (cur < end) {\n        let entry = changetype<SetEntry<T>>(cur);\n        if (!(entry.taggedNext & EMPTY)) {\n          let val = changetype<usize>(entry.key);\n          if (isNullable<T>()) {\n            if (val) __visit(val, cookie);\n          } else __visit(val, cookie);\n        }\n        cur += ENTRY_SIZE<T>();\n      }\n    }\n    __visit(entries, cookie);\n  }\n}\n","export const enum ReflectedValueType {\n  None = 0,\n  Class = 1,\n  String = 2,\n  ArrayBuffer = 3,\n  Map = 4,\n  Set = 5,\n  Function = 6,\n  Integer = 7,\n  Float = 8,\n  Boolean = 9,\n  Array = 10,\n  TypedArray = 11,\n  Finite = 12,\n  Truthy = 13,\n  Falsy = 14,\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { HASH } from \"./util/hash\";\nimport { E_KEYNOTFOUND } from \"./util/error\";\n\n// A deterministic hash map based on CloseTable from https://github.com/jorendorff/dht\n\n// @ts-ignore: decorator\n@inline const INITIAL_CAPACITY = 4;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_N = 8;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_D = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_N = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_D = 4;\n\n/** Structure of a map entry. */\n@unmanaged class MapEntry<K,V> {\n  key: K;\n  value: V;\n  taggedNext: usize; // LSB=1 indicates EMPTY\n}\n\n/** Empty bit. */\n// @ts-ignore: decorator\n@inline const EMPTY: usize = 1 << 0;\n\n/** Size of a bucket. */\n// @ts-ignore: decorator\n@inline const BUCKET_SIZE = sizeof<usize>();\n\n/** Computes the alignment of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_ALIGN<K,V>(): usize {\n  // can align to 4 instead of 8 if 32-bit and K/V is <= 32-bits\n  const maxkv = sizeof<K>() > sizeof<V>() ? sizeof<K>() : sizeof<V>();\n  const align = (maxkv > sizeof<usize>() ? maxkv : sizeof<usize>()) - 1;\n  return align;\n}\n\n/** Computes the aligned size of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_SIZE<K,V>(): usize {\n  const align = ENTRY_ALIGN<K,V>();\n  const size = (offsetof<MapEntry<K,V>>() + align) & ~align;\n  return size;\n}\n\nexport class Map<K,V> {\n\n  // buckets referencing their respective first entry, usize[bucketsMask + 1]\n  private buckets: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n  private bucketsMask: u32 = INITIAL_CAPACITY - 1;\n\n  // entries in insertion order, MapEntry<K,V>[entriesCapacity]\n  private entries: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>());\n  private entriesCapacity: i32 = INITIAL_CAPACITY;\n  private entriesOffset: i32 = 0;\n  private entriesCount: i32 = 0;\n\n  constructor() {\n    /* nop */\n  }\n\n  get size(): i32 {\n    return this.entriesCount;\n  }\n\n  clear(): void {\n    this.buckets = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n    this.bucketsMask = INITIAL_CAPACITY - 1;\n    this.entries = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>());\n    this.entriesCapacity = INITIAL_CAPACITY;\n    this.entriesOffset = 0;\n    this.entriesCount = 0;\n  }\n\n  private find(key: K, hashCode: u32): MapEntry<K,V> | null {\n    var entry = load<MapEntry<K,V>>( // unmanaged!\n      changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE\n    );\n    while (entry) {\n      let taggedNext = entry.taggedNext;\n      if (!(taggedNext & EMPTY) && entry.key == key) return entry;\n      entry = changetype<MapEntry<K,V>>(taggedNext & ~EMPTY);\n    }\n    return null;\n  }\n\n  has(key: K): bool {\n    return this.find(key, HASH<K>(key)) !== null;\n  }\n\n  @operator(\"[]\")\n  get(key: K): V {\n    var entry = this.find(key, HASH<K>(key));\n    if (!entry) throw new Error(E_KEYNOTFOUND); // cannot represent `undefined`\n    return entry.value;\n  }\n\n  @operator(\"[]=\")\n  set(key: K, value: V): this {\n    var hashCode = HASH<K>(key);\n    var entry = this.find(key, hashCode); // unmanaged!\n    if (entry) {\n      entry.value = value;\n      if (isManaged<V>()) {\n        __link(changetype<usize>(this), changetype<usize>(value), true);\n      }\n    } else {\n      // check if rehashing is necessary\n      if (this.entriesOffset == this.entriesCapacity) {\n        this.rehash(\n          this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n            ?  this.bucketsMask           // just rehash if 1/4+ entries are empty\n            : (this.bucketsMask << 1) | 1 // grow capacity to next 2^N\n        );\n      }\n      // append new entry\n      let entries = this.entries;\n      entry = changetype<MapEntry<K,V>>(changetype<usize>(entries) + <usize>(this.entriesOffset++) * ENTRY_SIZE<K,V>());\n      // link with the map\n      entry.key = key;\n      if (isManaged<K>()) {\n        __link(changetype<usize>(this), changetype<usize>(key), true);\n      }\n      entry.value = value;\n      if (isManaged<V>()) {\n        __link(changetype<usize>(this), changetype<usize>(value), true);\n      }\n      ++this.entriesCount;\n      // link with previous entry in bucket\n      let bucketPtrBase = changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE;\n      entry.taggedNext = load<usize>(bucketPtrBase);\n      store<usize>(bucketPtrBase, changetype<usize>(entry));\n    }\n    return this;\n  }\n\n  delete(key: K): bool {\n    var entry = this.find(key, HASH<K>(key));\n    if (!entry) return false;\n    entry.taggedNext |= EMPTY;\n    --this.entriesCount;\n    // check if rehashing is appropriate\n    var halfBucketsMask = this.bucketsMask >> 1;\n    if (\n      halfBucketsMask + 1 >= max<u32>(INITIAL_CAPACITY, this.entriesCount) &&\n      this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n    ) this.rehash(halfBucketsMask);\n    return true;\n  }\n\n  private rehash(newBucketsMask: u32): void {\n    var newBucketsCapacity = <i32>(newBucketsMask + 1);\n    var newBuckets = new ArrayBuffer(newBucketsCapacity * <i32>BUCKET_SIZE);\n    var newEntriesCapacity = newBucketsCapacity * FILL_FACTOR_N / FILL_FACTOR_D;\n    var newEntries = new ArrayBuffer(newEntriesCapacity * <i32>ENTRY_SIZE<K,V>());\n\n    // copy old entries to new entries\n    var oldPtr = changetype<usize>(this.entries);\n    var oldEnd = oldPtr + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\n    var newPtr = changetype<usize>(newEntries);\n    while (oldPtr != oldEnd) {\n      let oldEntry = changetype<MapEntry<K,V>>(oldPtr);\n      if (!(oldEntry.taggedNext & EMPTY)) {\n        let newEntry = changetype<MapEntry<K,V>>(newPtr);\n        let oldEntryKey = oldEntry.key;\n        newEntry.key = oldEntryKey;\n        newEntry.value = oldEntry.value;\n        let newBucketIndex = HASH<K>(oldEntryKey) & newBucketsMask;\n        let newBucketPtrBase = changetype<usize>(newBuckets) + <usize>newBucketIndex * BUCKET_SIZE;\n        newEntry.taggedNext = load<usize>(newBucketPtrBase);\n        store<usize>(newBucketPtrBase, newPtr);\n        newPtr += ENTRY_SIZE<K,V>();\n      }\n      oldPtr += ENTRY_SIZE<K,V>();\n    }\n\n    this.buckets = newBuckets;\n    this.bucketsMask = newBucketsMask;\n    this.entries = newEntries;\n    this.entriesCapacity = newEntriesCapacity;\n    this.entriesOffset = this.entriesCount;\n  }\n\n  keys(): K[] {\n    // FIXME: this is preliminary, needs iterators/closures\n    var start = changetype<usize>(this.entries);\n    var size = this.entriesOffset;\n    var keys = new Array<K>(size);\n    var length = 0;\n    for (let i = 0; i < size; ++i) {\n      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());\n      if (!(entry.taggedNext & EMPTY)) {\n        keys[length++] = entry.key;\n      }\n    }\n    keys.length = length;\n    return keys;\n  }\n\n  values(): V[] {\n    // FIXME: this is preliminary, needs iterators/closures\n    var start = changetype<usize>(this.entries);\n    var size = this.entriesOffset;\n    var values = new Array<V>(size);\n    var length = 0;\n    for (let i = 0; i < size; ++i) {\n      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());\n      if (!(entry.taggedNext & EMPTY)) {\n        values[length++] = entry.value;\n      }\n    }\n    values.length = length;\n    return values;\n  }\n\n  toString(): string {\n    return \"[object Map]\";\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    __visit(changetype<usize>(this.buckets), cookie);\n    var entries = changetype<usize>(this.entries);\n    if (isManaged<K>() || isManaged<V>()) {\n      let cur = entries;\n      let end = cur + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\n      while (cur < end) {\n        let entry = changetype<MapEntry<K,V>>(cur);\n        if (!(entry.taggedNext & EMPTY)) {\n          if (isManaged<K>()) {\n            let val = changetype<usize>(entry.key);\n            if (isNullable<K>()) {\n              if (val) __visit(val, cookie);\n            } else __visit(val, cookie);\n          }\n          if (isManaged<V>()) {\n            let val = changetype<usize>(entry.value);\n            if (isNullable<V>()) {\n              if (val) __visit(val, cookie);\n            } else __visit(val, cookie);\n          }\n        }\n        cur += ENTRY_SIZE<K,V>();\n      }\n    }\n    __visit(entries, cookie);\n  }\n}\n","/*  eslint-disable */\n// @as-covers: ignore because this is just an empty placeholder function\nexport const noOp = (): void => {};\n","// @ts-ignore: decorators *are* valid here\n@external(\"__aspect\", \"logReflectedValue\")\ndeclare function logReflectedValue(value: i32): void;\n\nlet ignoreLogs: bool = false;\n\nexport function __ignoreLogs(value: bool): void {\n  ignoreLogs = value;\n}\n\n// @ts-ignore: decorators *are* valid here\n@global\nexport function log<T>(value: T): void {\n  if (ignoreLogs) return;\n  // The T parameter must be passed directly\n  let reflectedId = Reflect.toReflectedValue<T>(value);\n  Reflect.attachStackTrace(reflectedId);\n  logReflectedValue(reflectedId);\n}\n","export function __call(func: () => void): void {\n  func();\n}\n","type auto = i32;\n\n@final export abstract class Function<T> {\n  private _index: u32;\n  private _env: usize;\n\n  // @ts-ignore: this on getter\n  get index(this: T): u32 {\n    return load<u32>(changetype<usize>(this), offsetof<Function<T>>(\"_index\"));\n  }\n\n  // @ts-ignore: this on getter\n  get name(this: T): string {\n    return \"\";\n  }\n\n  // @ts-ignore: this on getter\n  get length(this: T): i32 {\n    // @ts-ignore: T is function\n    return lengthof<T>();\n  }\n\n  // @ts-ignore: T is function\n  @builtin call(thisArg: thisof<T> | null, ...args: auto[]): returnof<T> {\n    return unreachable();\n  }\n\n  toString(this: T): string {\n    return \"function() { [native code] }\";\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    // Env is either `null` (nop) or compiler-generated\n    __visit(this._env, cookie);\n  }\n}\n"]}